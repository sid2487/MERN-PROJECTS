{"version":3,"file":"cli.js","sources":["../src/commands/analytics/fetch-org-analytics.mts","../src/commands/analytics/fetch-repo-analytics.mts","../src/commands/analytics/output-analytics.mts","../src/commands/analytics/handle-analytics.mts","../src/commands/analytics/cmd-analytics.mts","../src/commands/audit-log/fetch-audit-log.mts","../src/commands/audit-log/output-audit-log.mts","../src/commands/audit-log/handle-audit-log.mts","../src/commands/audit-log/cmd-audit-log.mts","../src/commands/manifest/run-cdxgen.mts","../src/commands/manifest/cmd-manifest-cdxgen.mts","../src/commands/cdxgen/handle-cdxgen.mts","../src/commands/cdxgen/cmd-cdxgen.mts","../src/commands/ci/fetch-default-org-slug.mts","../src/commands/scan/fetch-create-org-full-scan.mts","../src/commands/scan/fetch-supported-scan-file-names.mts","../src/commands/scan/fetch-report-data.mts","../src/commands/scan/generate-report.mts","../src/commands/scan/output-scan-report.mts","../src/commands/scan/handle-scan-report.mts","../src/commands/scan/output-create-new-scan.mts","../src/commands/manifest/detect-manifest-actions.mts","../src/commands/manifest/convert_gradle_to_maven.mts","../src/commands/manifest/convert_sbt_to_maven.mts","../src/commands/manifest/convert-conda-to-requirements.mts","../src/commands/manifest/output-requirements.mts","../src/commands/manifest/handle-manifest-conda.mts","../src/commands/manifest/generate_auto_manifest.mts","../src/commands/scan/handle-create-new-scan.mts","../src/commands/ci/handle-ci.mts","../src/commands/ci/cmd-ci.mts","../src/commands/config/discover-config-value.mts","../src/commands/config/output-config-auto.mts","../src/commands/config/handle-config-auto.mts","../src/commands/config/cmd-config-auto.mts","../src/commands/config/output-config-get.mts","../src/commands/config/handle-config-get.mts","../src/commands/config/cmd-config-get.mts","../src/commands/config/output-config-list.mts","../src/commands/config/cmd-config-list.mts","../src/commands/config/output-config-set.mts","../src/commands/config/handle-config-set.mts","../src/commands/config/cmd-config-set.mts","../src/commands/config/output-config-unset.mts","../src/commands/config/handle-config-unset.mts","../src/commands/config/cmd-config-unset.mts","../src/commands/config/cmd-config.mts","../src/commands/dependencies/fetch-dependencies.mts","../src/commands/dependencies/output-dependencies.mts","../src/commands/dependencies/handle-dependencies.mts","../src/commands/dependencies/cmd-dependencies.mts","../src/commands/diff-scan/fetch-diff-scan.mts","../src/commands/diff-scan/output-diff-scan.mts","../src/commands/diff-scan/handle-diff-scan.mts","../src/commands/diff-scan/cmd-diff-scan-get.mts","../src/commands/diff-scan/cmd-diff-scan.mts","../src/commands/fix/output-fix-result.mts","../src/commands/fix/git.mts","../src/commands/fix/open-pr.mts","../src/commands/fix/shared.mts","../src/commands/fix/npm-fix.mts","../src/commands/fix/pnpm-fix.mts","../src/commands/fix/run-fix.mts","../src/commands/fix/handle-fix.mts","../src/commands/fix/cmd-fix.mts","../src/commands/info/fetch-package-info.mts","../src/commands/info/output-package-info.mts","../src/commands/info/handle-package-info.mts","../src/commands/info/cmd-info.mts","../src/commands/install/output-install-completion.mts","../src/commands/install/setup-tab-completion.mts","../src/commands/install/handle-install-completion.mts","../src/commands/install/cmd-install-completion.mts","../src/commands/install/cmd-install.mts","../src/commands/json/output-cmd-json.mts","../src/commands/json/handle-cmd-json.mts","../src/commands/json/cmd-json.mts","../src/commands/login/apply-login.mts","../src/commands/login/attempt-login.mts","../src/commands/login/cmd-login.mts","../src/commands/logout/apply-logout.mts","../src/commands/logout/attempt-logout.mts","../src/commands/logout/cmd-logout.mts","../src/commands/manifest/cmd-manifest-auto.mts","../src/commands/manifest/cmd-manifest-conda.mts","../src/commands/manifest/cmd-manifest-gradle.mts","../src/commands/manifest/cmd-manifest-kotlin.mts","../src/commands/manifest/cmd-manifest-scala.mts","../src/commands/manifest/output-manifest-setup.mts","../src/commands/manifest/setup-manifest-config.mts","../src/commands/manifest/handle-manifest-setup.mts","../src/commands/manifest/cmd-manifest-setup.mts","../src/commands/manifest/cmd-manifest.mts","../src/commands/npm/cmd-npm.mts","../src/commands/npx/cmd-npx.mts","../src/commands/oops/cmd-oops.mts","../src/commands/optimize/deps-includes-by-agent.mts","../src/commands/optimize/get-dependency-entries.mts","../src/commands/optimize/get-overrides-by-agent.mts","../src/commands/optimize/lockfile-includes-by-agent.mts","../src/commands/optimize/ls-by-agent.mts","../src/commands/optimize/shared.mts","../src/commands/optimize/update-manifest-by-agent.mts","../src/commands/optimize/add-overrides.mts","../src/commands/optimize/update-lockfile.mts","../src/commands/optimize/apply-optimization.mts","../src/commands/optimize/output-optimize-result.mts","../src/commands/optimize/handle-optimize.mts","../src/commands/optimize/cmd-optimize.mts","../src/commands/organization/fetch-license-policy.mts","../src/commands/organization/output-license-policy.mts","../src/commands/organization/handle-license-policy.mts","../src/commands/organization/cmd-organization-policy-license.mts","../src/commands/organization/fetch-security-policy.mts","../src/commands/organization/output-security-policy.mts","../src/commands/organization/handle-security-policy.mts","../src/commands/organization/cmd-organization-policy-security.mts","../src/commands/organization/fetch-organization-list.mts","../src/commands/organization/output-organization-list.mts","../src/commands/organization/handle-organization-list.mts","../src/commands/organization/cmd-organization-list.mts","../src/commands/organization/cmd-organization-policy.mts","../src/commands/organization/fetch-quota.mts","../src/commands/organization/output-quota.mts","../src/commands/organization/handle-quota.mts","../src/commands/organization/cmd-organization-quota.mts","../src/commands/organization/cmd-organization.mts","../src/commands/package/fetch-purl-deep-score.mts","../src/commands/package/output-purls-deep-score.mts","../src/commands/package/handle-purl-deep-score.mts","../src/commands/package/parse-package-specifiers.mts","../src/commands/package/cmd-package-score.mts","../src/commands/package/fetch-purls-shallow-score.mts","../src/commands/package/output-purls-shallow-score.mts","../src/commands/package/handle-purls-shallow-score.mts","../src/commands/package/cmd-package-shallow.mts","../src/commands/package/cmd-package.mts","../src/commands/raw-npm/run-raw-npm.mts","../src/commands/raw-npm/cmd-raw-npm.mts","../src/commands/raw-npx/run-raw-npx.mts","../src/commands/raw-npx/cmd-raw-npx.mts","../src/commands/report/cmd-report-create.mts","../src/commands/report/cmd-report-view.mts","../src/commands/report/cmd-report.mts","../src/commands/repos/fetch-create-repo.mts","../src/commands/repos/output-create-repo.mts","../src/commands/repos/handle-create-repo.mts","../src/commands/repos/cmd-repos-create.mts","../src/commands/repos/fetch-delete-repo.mts","../src/commands/repos/output-delete-repo.mts","../src/commands/repos/handle-delete-repo.mts","../src/commands/repos/cmd-repos-del.mts","../src/commands/repos/fetch-list-all-repos.mts","../src/commands/repos/fetch-list-repos.mts","../src/commands/repos/output-list-repos.mts","../src/commands/repos/handle-list-repos.mts","../src/commands/repos/cmd-repos-list.mts","../src/commands/repos/fetch-update-repo.mts","../src/commands/repos/output-update-repo.mts","../src/commands/repos/handle-update-repo.mts","../src/commands/repos/cmd-repos-update.mts","../src/commands/repos/fetch-view-repo.mts","../src/commands/repos/output-view-repo.mts","../src/commands/repos/handle-view-repo.mts","../src/commands/repos/cmd-repos-view.mts","../src/commands/repos/cmd-repos.mts","../src/commands/scan/suggest_target.mts","../src/commands/scan/cmd-scan-create.mts","../src/commands/scan/fetch-delete-org-full-scan.mts","../src/commands/scan/output-delete-scan.mts","../src/commands/scan/handle-delete-scan.mts","../src/commands/scan/cmd-scan-del.mts","../src/commands/scan/fetch-diff-scan.mts","../src/commands/scan/output-diff-scan.mts","../src/commands/scan/handle-diff-scan.mts","../src/commands/scan/cmd-scan-diff.mts","../src/commands/scan/create-scan-from-github.mts","../src/commands/scan/handle-create-github-scan.mts","../src/commands/scan/cmd-scan-github.mts","../src/commands/scan/fetch-list-scans.mts","../src/commands/scan/output-list-scans.mts","../src/commands/scan/handle-list-scans.mts","../src/commands/scan/cmd-scan-list.mts","../src/commands/scan/fetch-scan-metadata.mts","../src/commands/scan/output-scan-metadata.mts","../src/commands/scan/handle-scan-metadata.mts","../src/commands/scan/cmd-scan-metadata.mts","../src/commands/scan/output-scan-reach.mts","../src/commands/scan/scan-reachability.mts","../src/commands/scan/handle-reach-scan.mts","../src/commands/scan/cmd-scan-reach.mts","../src/commands/scan/cmd-scan-report.mts","../src/commands/scan/output-scan-config-result.mts","../src/commands/scan/setup-scan-config.mts","../src/commands/scan/handle-scan-config.mts","../src/commands/scan/cmd-scan-setup.mts","../src/commands/scan/fetch-scan.mts","../src/commands/scan/output-scan-view.mts","../src/commands/scan/handle-scan-view.mts","../src/commands/scan/stream-scan.mts","../src/commands/scan/cmd-scan-view.mts","../src/commands/scan/cmd-scan.mts","../src/commands/threat-feed/fetch-threat-feed.mts","../src/commands/threat-feed/output-threat-feed.mts","../src/commands/threat-feed/handle-threat-feed.mts","../src/commands/threat-feed/cmd-threat-feed.mts","../src/commands/uninstall/output-uninstall-completion.mts","../src/commands/uninstall/teardown-tab-completion.mts","../src/commands/uninstall/handle-uninstall-completion.mts","../src/commands/uninstall/cmd-uninstall-completion.mts","../src/commands/uninstall/cmd-uninstall.mts","../src/commands/wrapper/add-socket-wrapper.mts","../src/commands/wrapper/check-socket-wrapper-setup.mts","../src/commands/wrapper/postinstall-wrapper.mts","../src/commands/wrapper/remove-socket-wrapper.mts","../src/commands/wrapper/cmd-wrapper.mts","../src/cli.mts"],"sourcesContent":["import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchOrgAnalyticsData(\n  time: number,\n): Promise<CResult<SocketSdkReturnType<'getOrgAnalytics'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgAnalytics(time.toString()),\n    'analytics data',\n  )\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchRepoAnalyticsData(\n  repo: string,\n  time: number,\n): Promise<CResult<SocketSdkReturnType<'getRepoAnalytics'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getRepoAnalytics(repo, time.toString()),\n    'analytics data',\n  )\n}\n","import fs from 'node:fs/promises'\nimport { createRequire } from 'node:module'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTableStringNumber } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\nimport type { Widgets } from 'blessed' // Note: Widgets does not seem to actually work as code :'(\nimport type { grid as ContribGrid } from 'blessed-contrib'\n\nconst require = createRequire(import.meta.url)\n\nconst METRICS = [\n  'total_critical_alerts',\n  'total_high_alerts',\n  'total_medium_alerts',\n  'total_low_alerts',\n  'total_critical_added',\n  'total_medium_added',\n  'total_low_added',\n  'total_high_added',\n  'total_critical_prevented',\n  'total_high_prevented',\n  'total_medium_prevented',\n  'total_low_prevented',\n] as const\n\n// Note: This maps `new Date(date).getMonth()` to English three letters\nconst Months = [\n  'Jan',\n  'Feb',\n  'Mar',\n  'Apr',\n  'May',\n  'Jun',\n  'Jul',\n  'Aug',\n  'Sep',\n  'Oct',\n  'Nov',\n  'Dec',\n] as const\n\nexport async function outputAnalytics(\n  result: CResult<\n    | SocketSdkReturnType<'getOrgAnalytics'>['data']\n    | SocketSdkReturnType<'getRepoAnalytics'>['data']\n  >,\n  {\n    filePath,\n    outputKind,\n    repo,\n    scope,\n    time,\n  }: {\n    scope: string\n    time: number\n    repo: string\n    outputKind: OutputKind\n    filePath: string\n  },\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'json') {\n    const serialized = serializeResultJson(result)\n\n    if (filePath) {\n      try {\n        await fs.writeFile(filePath, serialized, 'utf8')\n        logger.success(`Data successfully written to ${filePath}`)\n      } catch (e) {\n        process.exitCode = 1\n        logger.log(\n          serializeResultJson({\n            ok: false,\n            message: 'File Write Failure',\n            cause: 'There was an error trying to write the json to disk',\n          }),\n        )\n      }\n    } else {\n      logger.log(serialized)\n    }\n\n    return\n  }\n\n  const fdata =\n    scope === 'org' ? formatDataOrg(result.data) : formatDataRepo(result.data)\n\n  if (outputKind === 'markdown') {\n    const serialized = renderMarkdown(fdata, time, repo)\n\n    // TODO: do we want to write to file even if there was an error...?\n    if (filePath) {\n      try {\n        await fs.writeFile(filePath, serialized, 'utf8')\n        logger.success(`Data successfully written to ${filePath}`)\n      } catch (e) {\n        logger.error(e)\n      }\n    } else {\n      logger.log(serialized)\n    }\n  } else {\n    displayAnalyticsScreen(fdata)\n  }\n}\n\nexport interface FormattedData {\n  top_five_alert_types: Record<string, number>\n  total_critical_alerts: Record<string, number>\n  total_high_alerts: Record<string, number>\n  total_medium_alerts: Record<string, number>\n  total_low_alerts: Record<string, number>\n  total_critical_added: Record<string, number>\n  total_medium_added: Record<string, number>\n  total_low_added: Record<string, number>\n  total_high_added: Record<string, number>\n  total_critical_prevented: Record<string, number>\n  total_high_prevented: Record<string, number>\n  total_medium_prevented: Record<string, number>\n  total_low_prevented: Record<string, number>\n}\n\nexport function renderMarkdown(\n  data: FormattedData,\n  days: number,\n  repoSlug: string,\n): string {\n  return (\n    `\n# Socket Alert Analytics\n\nThese are the Socket.dev analytics for the ${repoSlug ? `${repoSlug} repo` : 'org'} of the past ${days} days\n\n${[\n  [\n    'Total critical alerts',\n    mdTableStringNumber('Date', 'Counts', data['total_critical_alerts']),\n  ],\n  [\n    'Total high alerts',\n    mdTableStringNumber('Date', 'Counts', data['total_high_alerts']),\n  ],\n  [\n    'Total critical alerts added to the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_critical_added']),\n  ],\n  [\n    'Total high alerts added to the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_high_added']),\n  ],\n  [\n    'Total critical alerts prevented from the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_critical_prevented']),\n  ],\n  [\n    'Total high alerts prevented from the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_high_prevented']),\n  ],\n  [\n    'Total medium alerts prevented from the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_medium_prevented']),\n  ],\n  [\n    'Total low alerts prevented from the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_low_prevented']),\n  ],\n]\n  .map(([title, table]) =>\n    `\n## ${title}\n\n${table}\n`.trim(),\n  )\n  .join('\\n\\n')}\n\n## Top 5 alert types\n\n${mdTableStringNumber('Name', 'Counts', data['top_five_alert_types'])}\n`.trim() + '\\n'\n  )\n}\n\nfunction displayAnalyticsScreen(data: FormattedData): void {\n  const ScreenWidget = require('blessed/lib/widgets/screen.js')\n  // Lazily access constants.blessedOptions.\n  const screen: Widgets.Screen = new ScreenWidget({\n    ...constants.blessedOptions,\n  })\n  const GridLayout = require('blessed-contrib/lib/layout/grid.js')\n  const grid = new GridLayout({ rows: 5, cols: 4, screen })\n\n  renderLineCharts(\n    grid,\n    screen,\n    'Total critical alerts',\n    [0, 0, 1, 2],\n    data['total_critical_alerts'],\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total high alerts',\n    [0, 2, 1, 2],\n    data['total_high_alerts'],\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total critical alerts added to the main branch',\n    [1, 0, 1, 2],\n    data['total_critical_added'],\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total high alerts added to the main branch',\n    [1, 2, 1, 2],\n    data['total_high_added'],\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total critical alerts prevented from the main branch',\n    [2, 0, 1, 2],\n    data['total_critical_prevented'],\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total high alerts prevented from the main branch',\n    [2, 2, 1, 2],\n    data['total_high_prevented'],\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total medium alerts prevented from the main branch',\n    [3, 0, 1, 2],\n    data['total_medium_prevented'],\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total low alerts prevented from the main branch',\n    [3, 2, 1, 2],\n    data['total_low_prevented'],\n  )\n\n  const BarChart = require('blessed-contrib/lib/widget/charts/bar.js')\n  const bar = grid.set(4, 0, 1, 2, BarChart, {\n    label: 'Top 5 alert types',\n    barWidth: 10,\n    barSpacing: 17,\n    xOffset: 0,\n    maxHeight: 9,\n    barBgColor: 'magenta',\n  })\n\n  screen.append(bar) //must append before setting data\n\n  bar.setData({\n    titles: Object.keys(data.top_five_alert_types),\n    data: Object.values(data.top_five_alert_types),\n  })\n\n  screen.render()\n  // eslint-disable-next-line n/no-process-exit\n  screen.key(['escape', 'q', 'C-c'], () => process.exit(0))\n}\n\nexport function formatDataRepo(\n  data: SocketSdkReturnType<'getRepoAnalytics'>['data'],\n): FormattedData {\n  const sortedTopFiveAlerts: Record<string, number> = {}\n  const totalTopAlerts: Record<string, number> = {}\n\n  const formattedData = {} as Omit<FormattedData, 'top_five_alert_types'>\n  for (const metric of METRICS) {\n    formattedData[metric] = {}\n  }\n\n  for (const entry of data) {\n    const topFiveAlertTypes = entry['top_five_alert_types']\n    for (const type of Object.keys(topFiveAlertTypes)) {\n      const count = topFiveAlertTypes[type] ?? 0\n      if (!totalTopAlerts[type]) {\n        totalTopAlerts[type] = count\n      } else if (count > (totalTopAlerts[type] ?? 0)) {\n        totalTopAlerts[type] = count\n      }\n    }\n  }\n  for (const entry of data) {\n    for (const metric of METRICS) {\n      formattedData[metric]![formatDate(entry['created_at'])] = entry[metric]\n    }\n  }\n\n  const topFiveAlertEntries = Object.entries(totalTopAlerts)\n    .sort(([_keya, a], [_keyb, b]) => b - a)\n    .slice(0, 5)\n  for (const [key, value] of topFiveAlertEntries) {\n    sortedTopFiveAlerts[key] = value\n  }\n\n  return {\n    ...formattedData,\n    top_five_alert_types: sortedTopFiveAlerts,\n  }\n}\n\nexport function formatDataOrg(\n  data: SocketSdkReturnType<'getOrgAnalytics'>['data'],\n): FormattedData {\n  const sortedTopFiveAlerts: Record<string, number> = {}\n  const totalTopAlerts: Record<string, number> = {}\n\n  const formattedData = {} as Omit<FormattedData, 'top_five_alert_types'>\n  for (const metric of METRICS) {\n    formattedData[metric] = {}\n  }\n\n  for (const entry of data) {\n    const topFiveAlertTypes = entry['top_five_alert_types']\n    for (const type of Object.keys(topFiveAlertTypes)) {\n      const count = topFiveAlertTypes[type] ?? 0\n      if (!totalTopAlerts[type]) {\n        totalTopAlerts[type] = count\n      } else {\n        totalTopAlerts[type] += count\n      }\n    }\n  }\n\n  for (const metric of METRICS) {\n    const formatted = formattedData[metric]\n    for (const entry of data) {\n      const date = formatDate(entry['created_at'])\n      if (!formatted[date]) {\n        formatted[date] = entry[metric]!\n      } else {\n        formatted[date] += entry[metric]!\n      }\n    }\n  }\n\n  const topFiveAlertEntries = Object.entries(totalTopAlerts)\n    .sort(([_keya, a], [_keyb, b]) => b - a)\n    .slice(0, 5)\n  for (const [key, value] of topFiveAlertEntries) {\n    sortedTopFiveAlerts[key] = value\n  }\n\n  return {\n    ...formattedData,\n    top_five_alert_types: sortedTopFiveAlerts,\n  }\n}\n\nfunction formatDate(date: string): string {\n  return `${Months[new Date(date).getMonth()]} ${new Date(date).getDate()}`\n}\n\nfunction renderLineCharts(\n  grid: ContribGrid,\n  screen: Widgets.Screen,\n  title: string,\n  coords: number[],\n  data: Record<string, number>,\n): void {\n  const LineChart = require('blessed-contrib/lib/widget/charts/line.js')\n  const line = grid.set(...coords, LineChart, {\n    style: { line: 'cyan', text: 'cyan', baseline: 'black' },\n    xLabelPadding: 0,\n    xPadding: 0,\n    xOffset: 0,\n    wholeNumbersOnly: true,\n    legend: {\n      width: 1,\n    },\n    label: title,\n  })\n\n  screen.append(line)\n\n  const lineData = {\n    x: Object.keys(data),\n    y: Object.values(data),\n  }\n\n  line.setData([lineData])\n}\n","import { fetchOrgAnalyticsData } from './fetch-org-analytics.mts'\nimport { fetchRepoAnalyticsData } from './fetch-repo-analytics.mts'\nimport { outputAnalytics } from './output-analytics.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function handleAnalytics({\n  filePath,\n  outputKind,\n  repo,\n  scope,\n  time,\n}: {\n  scope: string\n  time: number\n  repo: string\n  outputKind: OutputKind\n  filePath: string\n}) {\n  let result: CResult<\n    | SocketSdkReturnType<'getOrgAnalytics'>['data']\n    | SocketSdkReturnType<'getRepoAnalytics'>['data']\n  >\n  if (scope === 'org') {\n    result = await fetchOrgAnalyticsData(time)\n  } else if (repo) {\n    result = await fetchRepoAnalyticsData(repo, time)\n  } else {\n    result = {\n      ok: false,\n      message: 'Missing repository name in command',\n    }\n  }\n  if (result.ok && !result.data.length) {\n    result = {\n      ok: true,\n      message: `The analytics data for this ${scope === 'org' ? 'organization' : 'repository'} is not yet available.`,\n      data: [],\n    }\n  }\n\n  await outputAnalytics(result, {\n    filePath,\n    outputKind,\n    repo,\n    scope,\n    time,\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleAnalytics } from './handle-analytics.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'analytics',\n  description: `Look up analytics data`,\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    file: {\n      type: 'string',\n      shortFlag: 'f',\n      description:\n        'Filepath to save output when given. Only valid with --json/--markdown.',\n    },\n    repo: {\n      type: 'string',\n      shortFlag: 'r',\n      default: '',\n      description: 'Name of the repository. Only valid when scope=repo',\n    },\n    scope: {\n      type: 'string',\n      shortFlag: 's',\n      default: 'org',\n      description:\n        \"Scope of the analytics data - either 'org' or 'repo', default: org\",\n    },\n    time: {\n      type: 'number',\n      shortFlag: 't',\n      default: 30,\n      description: 'Time filter - either 7, 30 or 90, default: 30',\n    },\n  },\n  help: (command, { flags }) =>\n    `\n    Usage\n      $ ${command} ${isTestingV1() ? '[ org | repo <reponame>] [time]' : '--scope=<scope> --time=<time filter>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: report:write\n\n    ${isTestingV1() ? '' : 'Default parameters are set to show the organization-level analytics over the'}\n    ${isTestingV1() ? '' : 'last 30 days.'}\n\n    ${isTestingV1() ? 'The scope is either org or repo level, defaults to org.' : ''}\n\n    ${isTestingV1() ? 'When scope is repo, a repo slug must be given as well.' : ''}\n\n    ${isTestingV1() ? 'The time argument must be number 7, 30, or 90 and defaults to 30.' : ''}\n\n    Options\n      ${getFlagListOutput(flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? 'org 7' : '--scope=org --time=7'}\n      $ ${command} ${isTestingV1() ? 'repo test-repo 30' : '--scope=org --time=30'}\n      $ ${command} ${isTestingV1() ? '90' : '--scope=repo --repo=test-repo --time=30'}\n  `\n      // Drop consecutive empty lines. Temporarily necessary to deal with v1 prep.\n      .replace(/\\n(?: *\\n)+/g, '\\n\\n'),\n}\n\nexport const cmdAnalytics = {\n  description: config.description,\n  hidden: config.hidden,\n  run: run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { file, json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  // In v1 mode support:\n  // - []        (no args)\n  // - ['org']\n  // - ['org', '30']\n  // - ['repo', 'name']\n  // - ['repo', 'name', '30']\n  // - ['30']\n  // Validate final values in the next step\n  let scope = 'org'\n  let time = isTestingV1() ? '30' : 30\n  let repoName = ''\n  if (isTestingV1()) {\n    if (cli.input[0] === 'org') {\n      if (cli.input[1]) {\n        time = cli.input[1]\n      }\n    } else if (cli.input[0] === 'repo') {\n      scope = 'repo'\n      if (cli.input[1]) {\n        repoName = cli.input[1]\n      }\n      if (cli.input[2]) {\n        time = cli.input[2]\n      }\n    } else if (cli.input[0]) {\n      time = cli.input[0]\n    }\n  } else {\n    if (cli.flags['scope']) {\n      scope = String(cli.flags['scope'] || '')\n    }\n    if (scope === 'repo') {\n      repoName = String(cli.flags['repo'] || '')\n    }\n    if (cli.flags['time']) {\n      time = Number(cli.flags['time'] || 30)\n    }\n  }\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      // In v1 this can't go wrong anymore since the unknown value goes to time\n      nook: !isTestingV1(),\n      test: scope === 'org' || scope === 'repo',\n      message: 'Scope must be \"repo\" or \"org\"',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      nook: true,\n      // Before v1 there were no args, only flags\n      test: isTestingV1() || cli.input.length === 0,\n      message: 'This command does not accept any arguments (use flags instead)',\n      pass: 'ok',\n      fail: `bad`,\n    },\n    {\n      nook: true,\n      test: scope === 'org' || !!repoName,\n      message: isTestingV1()\n        ? 'When scope=repo, repo name should be the second argument'\n        : 'When scope=repo, repo name should be set through --repo',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test:\n        scope === 'org' ||\n        !isTestingV1() ||\n        (repoName !== '7' && repoName !== '30' && repoName !== '90'),\n      message: 'When scope is repo, the second arg should be repo, not time',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      test: isTestingV1()\n        ? time === '7' || time === '30' || time === '90'\n        : time === 7 || time === 30 || time === 90,\n      message: 'The time filter must either be 7, 30 or 90',\n      pass: 'ok',\n      fail: isTestingV1()\n        ? 'invalid range set, see --help for command arg details.'\n        : 'bad',\n    },\n    {\n      nook: true,\n      test: !file || !!json || !!markdown,\n      message:\n        'The `--file` flag is only valid when using `--json` or `--markdown`',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  return await handleAnalytics({\n    scope,\n    time:\n      time === '90' || time === 90 ? 90 : time === '30' || time === 30 ? 30 : 7,\n    repo: repoName,\n    outputKind,\n    filePath: String(file || ''),\n  })\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchAuditLog({\n  logType,\n  orgSlug,\n  outputKind,\n  page,\n  perPage,\n}: {\n  outputKind: OutputKind\n  orgSlug: string\n  page: number\n  perPage: number\n  logType: string\n}): Promise<CResult<SocketSdkReturnType<'getAuditLogEvents'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getAuditLogEvents(orgSlug, {\n      // I'm not sure this is used at all.\n      outputJson: String(outputKind === 'json'),\n      // I'm not sure this is used at all.\n      outputMarkdown: String(outputKind === 'markdown'),\n      orgSlug,\n      type: logType,\n      page: String(page),\n      per_page: String(perPage),\n    }),\n    `audit log for ${orgSlug}`,\n  )\n}\n","import { debugFn, isDebug } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTable } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nconst { REDACTED } = constants\n\nexport async function outputAuditLog(\n  auditLogs: CResult<SocketSdkReturnType<'getAuditLogEvents'>['data']>,\n  {\n    logType,\n    orgSlug,\n    outputKind,\n    page,\n    perPage,\n  }: {\n    outputKind: OutputKind\n    orgSlug: string\n    page: number\n    perPage: number\n    logType: string\n  },\n): Promise<void> {\n  if (!auditLogs.ok) {\n    process.exitCode = auditLogs.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(\n      await outputAsJson(auditLogs, {\n        logType,\n        orgSlug,\n        page,\n        perPage,\n      }),\n    )\n  } else if (outputKind !== 'markdown' && !auditLogs.ok) {\n    logger.fail(failMsgWithBadge(auditLogs.message, auditLogs.cause))\n  } else {\n    logger.log(\n      await outputAsMarkdown(auditLogs, {\n        logType,\n        orgSlug,\n        page,\n        perPage,\n      }),\n    )\n  }\n}\n\nexport async function outputAsJson(\n  auditLogs: CResult<SocketSdkReturnType<'getAuditLogEvents'>['data']>,\n  {\n    logType,\n    orgSlug,\n    page,\n    perPage,\n  }: {\n    orgSlug: string\n    page: number\n    perPage: number\n    logType: string\n  },\n): Promise<string> {\n  if (!auditLogs.ok) {\n    return serializeResultJson(auditLogs)\n  }\n\n  return serializeResultJson({\n    ok: true,\n    data: {\n      desc: 'Audit logs for given query',\n      // Lazily access constants.ENV.VITEST.\n      generated: constants.ENV.VITEST ? REDACTED : new Date().toISOString(),\n      org: orgSlug,\n      logType,\n      page,\n      nextPage: auditLogs.data.nextPage,\n      perPage,\n      logs: auditLogs.data.results.map(log => {\n        // Note: The subset is pretty arbitrary\n        const {\n          created_at,\n          event_id,\n          ip_address,\n          type,\n          user_agent,\n          user_email,\n        } = log\n        return {\n          event_id,\n          created_at,\n          ip_address,\n          type,\n          user_agent,\n          user_email,\n        }\n      }),\n    },\n  })\n}\n\nexport async function outputAsMarkdown(\n  auditLogs: CResult<SocketSdkReturnType<'getAuditLogEvents'>['data']>,\n  {\n    logType,\n    orgSlug,\n    page,\n    perPage,\n  }: {\n    orgSlug: string\n    page: number\n    perPage: number\n    logType: string\n  },\n): Promise<string> {\n  if (!auditLogs.ok) {\n    return `\n# Socket Audit Logs\n\nThere was a problem fetching the audit logs:\n\n> ${auditLogs.message}\n${\n  auditLogs.cause\n    ? '>\\n' +\n      (\n        auditLogs.cause\n          .split('\\n')\n          .map(s => `> ${s}\\n`)\n          .join('') ?? ''\n      )\n    : ''\n}\nParameters:\n\n- org: ${orgSlug}\n- type filter: ${logType || '(none)'}\n- page: ${page}\n- per page: ${perPage}\n`\n  }\n\n  try {\n    const table = mdTable<any>(auditLogs.data.results, [\n      'event_id',\n      'created_at',\n      'type',\n      'user_email',\n      'ip_address',\n      'user_agent',\n    ])\n\n    return `\n# Socket Audit Logs\n\nThese are the Socket.dev audit logs as per requested query.\n- org: ${orgSlug}\n- type filter: ${logType || '(none)'}\n- page: ${page}\n- next page: ${auditLogs.data.nextPage}\n- per page: ${perPage}\n- generated: ${constants.ENV.VITEST ? REDACTED : new Date().toISOString()}\n\n${table}\n`\n  } catch (e) {\n    process.exitCode = 1\n    logger.fail(\n      'There was a problem converting the logs to Markdown, please try the `--json` flag',\n    )\n    if (isDebug()) {\n      debugFn('catch: unexpected\\n', e)\n    }\n    return ''\n  }\n}\n","import { fetchAuditLog } from './fetch-audit-log.mts'\nimport { outputAuditLog } from './output-audit-log.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleAuditLog({\n  logType,\n  orgSlug,\n  outputKind,\n  page,\n  perPage,\n}: {\n  outputKind: OutputKind\n  orgSlug: string\n  page: number\n  perPage: number\n  logType: string\n}): Promise<void> {\n  const auditLogs = await fetchAuditLog({\n    orgSlug,\n    outputKind,\n    page,\n    perPage,\n    logType,\n  })\n\n  await outputAuditLog(auditLogs, {\n    logType,\n    orgSlug,\n    outputKind,\n    page,\n    perPage,\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleAuditLog } from './handle-audit-log.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW, SOCKET_WEBSITE_URL } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'audit-log',\n  description: 'Look up the audit log for an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n    type: {\n      type: 'string',\n      shortFlag: 't',\n      default: '',\n      description: 'Type of log event',\n    },\n    perPage: {\n      type: 'number',\n      shortFlag: 'pp',\n      default: 30,\n      description: 'Results per page - default is 30',\n    },\n    page: {\n      type: 'number',\n      shortFlag: 'p',\n      default: 1,\n      description: 'Page number - default is 1',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '<repo>' : '<org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: audit-log:list\n\n    This feature requires an Enterprise Plan. To learn more about getting access\n    to this feature and many more, please visit ${SOCKET_WEBSITE_URL}/pricing\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? '' : 'FakeOrg'}\n  `,\n}\n\nexport const cmdAuditLog = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const {\n    dryRun,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n    page,\n    perPage,\n    type,\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n  const logType = String(type || '')\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleAuditLog({\n    orgSlug,\n    outputKind,\n    page: Number(page || 0),\n    perPage: Number(perPage || 0),\n    logType: logType.charAt(0).toUpperCase() + logType.slice(1),\n  })\n}\n","import { existsSync, promises as fs } from 'node:fs'\nimport path from 'node:path'\n\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport shadowBin from '../../shadow/npm/bin.mts'\n\nconst { NPM, NPX, PACKAGE_LOCK_JSON, PNPM, YARN, YARN_LOCK } = constants\n\nconst nodejsPlatformTypes = new Set([\n  'javascript',\n  'js',\n  'nodejs',\n  NPM,\n  PNPM,\n  'ts',\n  'tsx',\n  'typescript',\n])\n\nfunction argvToArray(argv: {\n  [key: string]: boolean | null | number | string | Array<string | number>\n}): string[] {\n  if (argv['help']) {\n    return ['--help']\n  }\n  const result = []\n  for (const { 0: key, 1: value } of Object.entries(argv)) {\n    if (key === '_' || key === '--') {\n      continue\n    }\n    if (key === 'babel' || key === 'install-deps' || key === 'validate') {\n      // cdxgen documents no-babel, no-install-deps, and no-validate flags so\n      // use them when relevant.\n      result.push(`--${value ? key : `no-${key}`}`)\n    } else if (value === true) {\n      result.push(`--${key}`)\n    } else if (typeof value === 'string') {\n      result.push(`--${key}`, String(value))\n    } else if (Array.isArray(value)) {\n      result.push(`--${key}`, ...value.map(String))\n    }\n  }\n  if (argv['--']) {\n    result.push('--', ...(argv as any)['--'])\n  }\n  return result\n}\n\nexport async function runCdxgen(yargvWithYes: any) {\n  let cleanupPackageLock = false\n  const { yes, ...yargv } = { __proto__: null, ...yargvWithYes } as any\n  const yesArgs = yes ? ['--yes'] : []\n  if (\n    yargv.type !== YARN &&\n    nodejsPlatformTypes.has(yargv.type) &&\n    existsSync(`./${YARN_LOCK}`)\n  ) {\n    if (existsSync(`./${PACKAGE_LOCK_JSON}`)) {\n      yargv.type = NPM\n    } else {\n      // Use synp to create a package-lock.json from the yarn.lock,\n      // based on the node_modules folder, for a more accurate SBOM.\n      try {\n        await shadowBin(NPX, [\n          ...yesArgs,\n          // Lazily access constants.ENV.INLINED_SYNP_VERSION.\n          `synp@${constants.ENV.INLINED_SYNP_VERSION}`,\n          '--source-file',\n          `./${YARN_LOCK}`,\n        ])\n        yargv.type = NPM\n        cleanupPackageLock = true\n      } catch {}\n    }\n  }\n  await shadowBin(NPX, [\n    ...yesArgs,\n    // Lazily access constants.ENV.INLINED_CYCLONEDX_CDXGEN_VERSION.\n    `@cyclonedx/cdxgen@${constants.ENV.INLINED_CYCLONEDX_CDXGEN_VERSION}`,\n    ...argvToArray(yargv),\n  ])\n  if (cleanupPackageLock) {\n    try {\n      await fs.rm(`./${PACKAGE_LOCK_JSON}`)\n    } catch {}\n  }\n  const fullOutputPath = path.join(process.cwd(), yargv.output)\n  if (existsSync(fullOutputPath)) {\n    logger.log(colors.cyanBright(`${yargv.output} created!`))\n  }\n}\n","import terminalLink from 'terminal-link'\nimport yargsParse from 'yargs-parser'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { pluralize } from '@socketsecurity/registry/lib/words'\n\nimport { runCdxgen } from './run-cdxgen.mts'\nimport constants from '../../constants.mts'\nimport { isHelpFlag } from '../../utils/cmd.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\n// TODO: Convert yargs to meow.\nconst toLower = (arg: string) => arg.toLowerCase()\nconst arrayToLower = (arg: string[]) => arg.map(toLower)\n\n// npx @cyclonedx/cdxgen@11.2.7 --help\n//\n// Options:\n//   -o, --output                 Output file. Default bom.json                                       [default: \"bom.json\"]\n//   -t, --type                   Project type. Please refer to https://cyclonedx.github.io/cdxgen/#/PROJECT_TYPES for supp\n//                                orted languages/platforms.                                                        [array]\n//       --exclude-type           Project types to exclude. Please refer to https://cyclonedx.github.io/cdxgen/#/PROJECT_TY\n//                                PES for supported languages/platforms.\n//   -r, --recurse                Recurse mode suitable for mono-repos. Defaults to true. Pass --no-recurse to disable.\n//                                                                                                [boolean] [default: true]\n//   -p, --print                  Print the SBOM as a table with tree.                                            [boolean]\n//   -c, --resolve-class          Resolve class names for packages. jars only for now.                            [boolean]\n//       --deep                   Perform deep searches for components. Useful while scanning C/C++ apps, live OS and oci i\n//                                mages.                                                                          [boolean]\n//       --server-url             Dependency track url. Eg: https://deptrack.cyclonedx.io\n//       --skip-dt-tls-check      Skip TLS certificate check when calling Dependency-Track.      [boolean] [default: false]\n//       --api-key                Dependency track api key\n//       --project-group          Dependency track project group\n//       --project-name           Dependency track project name. Default use the directory name\n//       --project-version        Dependency track project version                                   [string] [default: \"\"]\n//       --project-id             Dependency track project id. Either provide the id or the project name and version togeth\n//                                er                                                                               [string]\n//       --parent-project-id      Dependency track parent project id                                               [string]\n//       --required-only          Include only the packages with required scope on the SBOM. Would set compositions.aggrega\n//                                te to incomplete unless --no-auto-compositions is passed.                       [boolean]\n//       --fail-on-error          Fail if any dependency extractor fails.                                         [boolean]\n//       --no-babel               Do not use babel to perform usage analysis for JavaScript/TypeScript projects.  [boolean]\n//       --generate-key-and-sign  Generate an RSA public/private key pair and then sign the generated SBOM using JSON Web S\n//                                ignatures.                                                                      [boolean]\n//       --server                 Run cdxgen as a server                                                          [boolean]\n//       --server-host            Listen address                                                     [default: \"127.0.0.1\"]\n//       --server-port            Listen port                                                             [default: \"9090\"]\n//       --install-deps           Install dependencies automatically for some projects. Defaults to true but disabled for c\n//                                ontainers and oci scans. Use --no-install-deps to disable this feature.\n//                                                                                                [boolean] [default: true]\n//       --validate               Validate the generated SBOM using json schema. Defaults to true. Pass --no-validate to di\n//                                sable.                                                          [boolean] [default: true]\n//       --evidence               Generate SBOM with evidence for supported languages.           [boolean] [default: false]\n//       --spec-version           CycloneDX Specification version to use. Defaults to 1.6\n//                                                                         [number] [choices: 1.4, 1.5, 1.6] [default: 1.6]\n//       --filter                 Filter components containing this word in purl or component.properties.value. Multiple va\n//                                lues allowed.                                                                     [array]\n//       --only                   Include components only containing this word in purl. Useful to generate BOM with first p\n//                                arty components alone. Multiple values allowed.                                   [array]\n//       --author                 The person(s) who created the BOM. Set this value if you're intending the modify the BOM\n//                                and claim authorship.                               [array] [default: \"OWASP Foundation\"]\n//       --profile                BOM profile to use for generation. Default generic.\n//   [choices: \"appsec\", \"research\", \"operational\", \"threat-modeling\", \"license-compliance\", \"generic\", \"machine-learning\",\n//                                                        \"ml\", \"deep-learning\", \"ml-deep\", \"ml-tiny\"] [default: \"generic\"]\n//       --exclude                Additional glob pattern(s) to ignore                                              [array]\n//       --include-formulation    Generate formulation section with git metadata and build tools. Defaults to false.\n//                                                                                               [boolean] [default: false]\n//       --include-crypto         Include crypto libraries as components.                        [boolean] [default: false]\n//       --standard               The list of standards which may consist of regulations, industry or organizational-specif\n//                                ic standards, maturity models, best practices, or any other requirements which can be eva\n//                                luated against or attested to.\n//   [array] [choices: \"asvs-5.0\", \"asvs-4.0.3\", \"bsimm-v13\", \"masvs-2.0.0\", \"nist_ssdf-1.1\", \"pcissc-secure-slc-1.1\", \"scv\n//                                                                                          s-1.0.0\", \"ssaf-DRAFT-2023-11\"]\n//       --json-pretty            Pretty-print the generated BOM json.                           [boolean] [default: false]\n//       --min-confidence         Minimum confidence needed for the identity of a component from 0 - 1, where 1 is 100% con\n//                                fidence.                                                            [number] [default: 0]\n//       --technique              Analysis technique to use\n//   [array] [choices: \"auto\", \"source-code-analysis\", \"binary-analysis\", \"manifest-analysis\", \"hash-comparison\", \"instrume\n//                                                                                                    ntation\", \"filename\"]\n//       --auto-compositions      Automatically set compositions when the BOM was filtered. Defaults to true\n//                                                                                                [boolean] [default: true]\n//   -h, --help                   Show help                                                                       [boolean]\n//   -v, --version                Show version number                                                             [boolean]\n\n// isSecureMode defined at:\n// https://github.com/CycloneDX/cdxgen/blob/v11.2.7/lib/helpers/utils.js#L66\n// const isSecureMode =\n//   ['true', '1'].includes(process.env?.CDXGEN_SECURE_MODE) ||\n//   process.env?.NODE_OPTIONS?.includes('--permission')\n\n// Yargs CDXGEN configuration defined at:\n// https://github.com/CycloneDX/cdxgen/blob/v11.2.7/bin/cdxgen.js#L64\nconst yargsConfig = {\n  configuration: {\n    'camel-case-expansion': false,\n    'greedy-arrays': false,\n    'parse-numbers': false,\n    'populate--': true,\n    'short-option-groups': false,\n    'strip-aliased': true,\n    'unknown-options-as-args': true,\n  },\n  coerce: {\n    'exclude-type': arrayToLower,\n    'feature-flags': arrayToLower,\n    filter: arrayToLower,\n    only: arrayToLower,\n    profile: toLower,\n    standard: arrayToLower,\n    technique: arrayToLower,\n    type: arrayToLower,\n  },\n  default: {\n    //author: ['OWASP Foundation'],\n    //'auto-compositions': true,\n    //babel: true,\n    //banner: false, // hidden\n    //'deps-slices-file': 'deps.slices.json', // hidden\n    //evidence: false,\n    //'exclude-type': [],\n    //'export-proto': true, // hidden\n    //'fail-on-error': isSecureMode,\n    //'feature-flags': [], // hidden\n    //'include-crypto': false,\n    //'include-formulation': false,\n    //'install-deps': !isSecureMode\n    //lifecycle: 'build', // hidden\n    //'min-confidence': '0',\n    //output: 'bom.json',\n    //profile: 'generic',\n    //'project-version': '',\n    //'proto-bin-file': 'bom.cdx', // hidden\n    //recurse: true,\n    //'skip-dt-tls-check': false,\n    //'semantics-slices-file': 'semantics.slices.json',\n    //'server-host': '127.0.0.1',\n    //'server-port': '9090',\n    //'spec-version': '1.6',\n    type: ['js'],\n    //validate: true,\n  },\n  alias: {\n    help: ['h'],\n    output: ['o'],\n    print: ['p'],\n    recurse: ['r'],\n    'resolve-class': ['c'],\n    type: ['t'],\n    version: ['v'],\n    yes: ['y'],\n  },\n  array: [\n    { key: 'author', type: 'string' },\n    { key: 'exclude', type: 'string' },\n    { key: 'exclude-type', type: 'string' },\n    { key: 'feature-flags', type: 'string' }, // hidden\n    { key: 'filter', type: 'string' },\n    { key: 'only', type: 'string' },\n    { key: 'standard', type: 'string' },\n    { key: 'technique', type: 'string' },\n    { key: 'type', type: 'string' },\n  ],\n  boolean: [\n    'auto-compositions',\n    'babel',\n    'banner', // hidden\n    'deep',\n    'evidence',\n    'export-proto', // hidden\n    'fail-on-error',\n    'generate-key-and-sign',\n    'help',\n    'include-crypto',\n    'include-formulation',\n    'install-deps',\n    'json-pretty',\n    'print',\n    'recurse',\n    'required-only',\n    'resolve-class',\n    'skip-dt-tls-check',\n    'server',\n    'validate',\n    'version',\n    // The --yes flag and -y alias map to the corresponding flag and alias of npx.\n    // https://docs.npmjs.com/cli/v7/commands/npx#compatibility-with-older-npx-versions\n    'yes',\n  ],\n  string: [\n    'api-key',\n    'data-flow-slices-file', // hidden\n    'deps-slices-file', // hidden\n    'evinse-output', // hidden\n    'lifecycle',\n    'min-confidence', // number\n    'openapi-spec-file', // hidden\n    'output',\n    'parent-project-id',\n    'profile',\n    'project-group',\n    'project-name',\n    'project-version',\n    'project-id',\n    'proto-bin-file', // hidden\n    'reachables-slices-file', // hidden\n    'semantics-slices-file', // hidden\n    'server-host',\n    'server-port',\n    'server-url',\n    'spec-version', // number\n    'usages-slices-file', // hidden\n  ],\n}\n\nconst config: CliCommandConfig = {\n  commandName: 'cdxgen',\n  description: 'Create an SBOM with CycloneDX generator (cdxgen)',\n  hidden: false,\n  // Stub out flags and help.\n  // TODO: Convert yargs to meow.\n  flags: {},\n  help: () => '',\n}\n\nexport const cmdManifestCdxgen = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    allowUnknownFlags: true,\n    // Don't let meow take over --help.\n    argv: argv.filter(a => !isHelpFlag(a)),\n    config,\n    importMeta,\n    parentName,\n  })\n\n  // TODO: Convert yargs to meow.\n  const yargv = {\n    ...yargsParse(argv as string[], yargsConfig),\n  } as any\n\n  const unknown: string[] = yargv._\n  const { length: unknownLength } = unknown\n  if (unknownLength) {\n    // Use exit status of 2 to indicate incorrect usage, generally invalid\n    // options or missing arguments.\n    // https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html\n    process.exitCode = 2\n    logger.fail(\n      `Unknown ${pluralize('argument', unknownLength)}: ${yargv._.join(', ')}`,\n    )\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  // Change defaults when not passing the --help flag.\n  if (!yargv.help) {\n    // Make 'lifecycle' default to 'pre-build', which also sets 'install-deps' to `false`,\n    // to avoid arbitrary code execution on the cdxgen scan.\n    // https://github.com/CycloneDX/cdxgen/issues/1328\n    if (yargv.lifecycle === undefined) {\n      yargv.lifecycle = 'pre-build'\n      yargv['install-deps'] = false\n      logger.info(\n        `Socket set cdxgen --lifecycle to \"${yargv.lifecycle}\" to avoid arbitrary code execution on this scan.\\n  Pass \"--lifecycle build\" to generate a BOM consisting of information obtained during the build process.\\n  See cdxgen ${terminalLink(\n          'BOM lifecycles documentation',\n          'https://cyclonedx.github.io/cdxgen/#/ADVANCED?id=bom-lifecycles',\n        )} for more details.\\n`,\n      )\n    }\n    if (yargv.output === undefined) {\n      yargv.output = 'socket-cdx.json'\n    }\n  }\n\n  await runCdxgen(yargv)\n}\n","import { cmdManifestCdxgen } from '../manifest/cmd-manifest-cdxgen.mts'\n\nexport async function handleCdxgen(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  await cmdManifestCdxgen.run(argv, importMeta, { parentName })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleCdxgen } from './handle-cdxgen.mts'\nimport { commonFlags } from '../../flags.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst config: CliCommandConfig = {\n  commandName: 'cdxgen',\n  description: 'Create an SBOM with CycloneDX generator (cdxgen)',\n  hidden: true,\n  flags: {\n    ...commonFlags,\n  },\n  help: (parentName, _config) => `\n    Usage\n      $ ${parentName}\n  `,\n}\n\nexport const cmdCdxgen = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  logger.warn(\n    'Warning: The `socket cdxgen` command moved to `socket manifest cdxgen` and will be removed as a toplevel command in the next major bump.',\n  )\n\n  await handleCdxgen(argv, importMeta, { parentName })\n}\n","import { debugFn } from '@socketsecurity/registry/lib/debug'\n\nimport { handleApiCall } from '../../utils/api.mts'\nimport { getConfigValueOrUndef } from '../../utils/config.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\n\n// Use the config defaultOrg when set, otherwise discover from remote\nexport async function getDefaultOrgSlug(): Promise<CResult<string>> {\n  const defaultOrgResult = getConfigValueOrUndef('defaultOrg')\n\n  if (defaultOrgResult) {\n    debugFn('use: default org', defaultOrgResult)\n    return { ok: true, data: defaultOrgResult }\n  }\n\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  const result = await handleApiCall(\n    sockSdk.getOrganizations(),\n    'list of organizations',\n  )\n\n  if (!result.ok) {\n    return result\n  }\n\n  const orgs = result.data.organizations\n  const keys = Object.keys(orgs)\n\n  if (!keys[0]) {\n    return {\n      ok: false,\n      message: 'Failed to establish identity',\n      data: `API did not return any organization associated with the current API token. Unable to continue.`,\n    }\n  }\n\n  const slug = (keys[0] in orgs && orgs?.[keys[0]]?.name) ?? undefined\n\n  if (!slug) {\n    return {\n      ok: false,\n      message: 'Failed to establish identity',\n      data: `Was unable to determine the default organization for the current API token. Unable to continue.`,\n    }\n  }\n\n  debugFn('resolve: org', slug)\n\n  return {\n    ok: true,\n    message: 'Retrieved default org from server',\n    data: slug,\n  }\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchCreateOrgFullScan(\n  packagePaths: string[],\n  orgSlug: string,\n  defaultBranch: boolean,\n  pendingHead: boolean,\n  tmp: boolean,\n  cwd: string,\n  {\n    branchName,\n    commitHash,\n    commitMessage,\n    committers,\n    pullRequest,\n    repoName,\n  }: {\n    branchName: string\n    commitHash: string\n    commitMessage: string\n    committers: string\n    pullRequest: number\n    repoName: string\n  },\n): Promise<CResult<SocketSdkReturnType<'CreateOrgFullScan'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.createOrgFullScan(\n      orgSlug,\n      {\n        ...(branchName ? { branch: branchName } : {}),\n        ...(commitHash ? { commit_hash: commitHash } : {}),\n        ...(commitMessage ? { commit_message: commitMessage } : {}),\n        ...(committers ? { committers } : {}),\n        make_default_branch: String(defaultBranch),\n        ...(pullRequest ? { pull_request: String(pullRequest) } : {}),\n        repo: repoName || 'socket-default-repository', // mandatory, this is server default for repo\n        set_as_pending_head: String(pendingHead),\n        tmp: String(tmp),\n      },\n      packagePaths,\n      cwd,\n    ),\n    'to create a scan',\n  )\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchSupportedScanFileNames(): Promise<\n  CResult<SocketSdkReturnType<'getReportSupportedFiles'>['data']>\n> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getReportSupportedFiles(),\n    'supported scan file types',\n  )\n}\n","import { debugFn } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { handleApiCallNoSpinner, queryApiSafeText } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketArtifact } from '../../utils/alert/artifact.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\n/**\n * This fetches all the relevant pieces of data to generate a report, given a\n * full scan ID.\n */\nexport async function fetchReportData(\n  orgSlug: string,\n  scanId: string,\n  includeLicensePolicy: boolean,\n): Promise<\n  CResult<{\n    scan: SocketArtifact[]\n    securityPolicy: SocketSdkReturnType<'getOrgSecurityPolicy'>['data']\n  }>\n> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  let scanStatus = 'requested..'\n  let policyStatus = 'requested..'\n  let finishedFetching = false\n\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n\n  function updateScan(desc: string) {\n    scanStatus = desc\n    updateProgress()\n  }\n\n  function updatePolicy(desc: string) {\n    policyStatus = desc\n    updateProgress()\n  }\n\n  function updateProgress() {\n    if (finishedFetching) {\n      spinner.stop()\n      logger.info(\n        `Scan result: ${scanStatus}. Security policy: ${policyStatus}.`,\n      )\n    } else {\n      spinner.start(\n        `Scan result: ${scanStatus}. Security policy: ${policyStatus}.`,\n      )\n    }\n  }\n\n  async function fetchScanResult(): Promise<CResult<SocketArtifact[]>> {\n    const result = await queryApiSafeText(\n      `orgs/${orgSlug}/full-scans/${encodeURIComponent(scanId)}${includeLicensePolicy ? '?include_license_details=true' : ''}`,\n    )\n\n    updateScan(`response received`)\n\n    if (!result.ok) {\n      return result\n    }\n\n    const jsonsString = result.data\n\n    // This is nd-json; each line is a json object.\n    const lines = jsonsString.split('\\n').filter(Boolean)\n    let ok = true\n    const data = lines.map(line => {\n      try {\n        return JSON.parse(line)\n      } catch {\n        ok = false\n        debugFn('fail: parse NDJSON\\n', line)\n        return\n      }\n    }) as unknown as SocketArtifact[]\n\n    if (ok) {\n      updateScan(`success`)\n      return { ok: true, data }\n    }\n\n    updateScan(`received invalid JSON response`)\n\n    return {\n      ok: false,\n      message: 'Invalid API response',\n      cause:\n        'The API responded with at least one line that was not valid JSON. Please report if this persists.',\n    }\n  }\n\n  async function fetchSecurityPolicy(): Promise<\n    CResult<SocketSdkReturnType<'getOrgSecurityPolicy'>['data']>\n  > {\n    const result = await handleApiCallNoSpinner(\n      sockSdk.getOrgSecurityPolicy(orgSlug),\n      'GetOrgSecurityPolicy',\n    )\n\n    updatePolicy('received policy')\n\n    return result\n  }\n\n  updateProgress()\n\n  const [scan, securityPolicy]: [\n    CResult<SocketArtifact[]>,\n    CResult<SocketSdkReturnType<'getOrgSecurityPolicy'>['data']>,\n  ] = await Promise.all([\n    fetchScanResult().catch(e => {\n      updateScan(`failure; unknown blocking problem occurred`)\n      return {\n        ok: false as const,\n        message: 'Unexpected API problem',\n        cause: `We encountered an unexpected problem while requesting the Scan from the API: ${e?.message || '(no error message found)'}${e?.cause ? ` (cause: ${e.cause})` : ''}`,\n      }\n    }),\n    fetchSecurityPolicy().catch(e => {\n      updatePolicy(`failure; unknown blocking problem occurred`)\n      return {\n        ok: false as const,\n        message: 'Unexpected API problem',\n        cause: `We encountered an unexpected problem while requesting the policy from the API: ${e?.message || '(no error message found)'}${e?.cause ? ` (cause: ${e.cause})` : ''}`,\n      }\n    }),\n  ]).finally(() => {\n    finishedFetching = true\n    updateProgress()\n  })\n\n  if (!scan.ok) {\n    return scan\n  }\n  if (!securityPolicy.ok) {\n    return securityPolicy\n  }\n\n  if (!Array.isArray(scan.data)) {\n    return {\n      ok: false,\n      message: 'Failed to fetch',\n      cause: 'Was unable to fetch scan result, bailing',\n    }\n  }\n\n  return {\n    ok: true,\n    data: {\n      scan: scan.data satisfies SocketArtifact[],\n      securityPolicy: securityPolicy.data,\n    },\n  }\n}\n","import { getSocketDevPackageOverviewUrlFromPurl } from '../../utils/socket-url.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketArtifact } from '../../utils/alert/artifact.mts'\nimport type { Spinner } from '@socketsecurity/registry/lib/spinner'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\ntype AlertAction = 'defer' | 'ignore' | 'monitor' | 'error' | 'warn'\ntype AlertKey = string\n\ntype FileMap = Map<string, ReportLeafNode | Map<AlertKey, ReportLeafNode>>\ntype VersionMap = Map<string, ReportLeafNode | FileMap>\ntype PackageMap = Map<string, ReportLeafNode | VersionMap>\ntype EcoMap = Map<string, ReportLeafNode | PackageMap>\nexport type ViolationsMap = Map<string, EcoMap>\n\nexport interface ShortScanReport {\n  healthy: boolean\n}\nexport interface ScanReport {\n  orgSlug: string\n  scanId: string\n  options: { fold: string; reportLevel: string }\n  healthy: boolean\n  alerts: ViolationsMap\n}\n\nexport type ReportLeafNode = {\n  type: string\n  policy: 'defer' | 'ignore' | 'monitor' | 'warn' | 'error'\n  url: string\n  manifest: string[]\n}\n\n// Note: The returned cresult will only be ok:false when the generation\n//       failed. It won't reflect the healthy state.\nexport function generateReport(\n  scan: SocketArtifact[],\n  securityPolicy: SocketSdkReturnType<'getOrgSecurityPolicy'>['data'],\n  {\n    fold,\n    orgSlug,\n    reportLevel,\n    scanId,\n    short,\n    spinner,\n  }: {\n    fold: 'pkg' | 'version' | 'file' | 'none'\n    orgSlug: string\n    reportLevel: 'defer' | 'ignore' | 'monitor' | 'warn' | 'error'\n    scanId: string\n    short?: boolean | undefined\n    spinner?: Spinner | undefined\n  },\n): CResult<ScanReport | { healthy: boolean }> {\n  const now = Date.now()\n\n  spinner?.start('Generating report...')\n\n  // Create an object that includes:\n  //   healthy: boolean\n  //   worst violation level;\n  //   per eco\n  //     per package\n  //       per version\n  //         per offending file\n  //           reported issue -> policy action\n\n  // In the context of a report;\n  // - the alert.severity is irrelevant\n  // - the securityPolicyDefault is irrelevant\n  // - the report defaults to healthy:true with no alerts\n  // - the appearance of an alert will trigger the policy action;\n  //   - error: healthy will end up as false, add alerts to report\n  //   - warn: healthy unchanged, add alerts to report\n  //   - monitor/ignore: no action\n  //   - defer: unknown (no action)\n\n  // Note: the server will emit alerts for license policy violations but\n  //       those are only included if you set the flag when requesting the scan\n  //       data. The alerts map to a single security policy key that determines\n  //       what to do with any violation, regardless of the concrete license.\n  //       That rule is called \"License Policy Violation\".\n  // The license policy part is implicitly handled here. Either they are\n  // included and may show up, or they are not and won't show up.\n\n  const violations = new Map()\n\n  let healthy = true\n\n  const securityRules = securityPolicy.securityPolicyRules\n  if (securityRules) {\n    // Note: reportLevel: error > warn > monitor > ignore > defer\n    scan.forEach(artifact => {\n      const {\n        alerts,\n        name: pkgName = '<unknown>',\n        type: ecosystem,\n        version = '<unknown>',\n      } = artifact\n\n      alerts?.forEach(\n        (alert: NonNullable<SocketArtifact['alerts']>[number]) => {\n          const alertName = alert.type as keyof typeof securityRules // => policy[type]\n          const action = securityRules[alertName]?.action || ''\n          switch (action) {\n            case 'error': {\n              healthy = false\n              if (!short) {\n                addAlert(\n                  artifact,\n                  violations,\n                  fold,\n                  ecosystem,\n                  pkgName,\n                  version,\n                  alert,\n                  action,\n                )\n              }\n              break\n            }\n            case 'warn': {\n              if (!short && reportLevel !== 'error') {\n                addAlert(\n                  artifact,\n                  violations,\n                  fold,\n                  ecosystem,\n                  pkgName,\n                  version,\n                  alert,\n                  action,\n                )\n              }\n              break\n            }\n            case 'monitor': {\n              if (!short && reportLevel !== 'warn' && reportLevel !== 'error') {\n                addAlert(\n                  artifact,\n                  violations,\n                  fold,\n                  ecosystem,\n                  pkgName,\n                  version,\n                  alert,\n                  action,\n                )\n              }\n              break\n            }\n\n            case 'ignore': {\n              if (\n                !short &&\n                reportLevel !== 'warn' &&\n                reportLevel !== 'error' &&\n                reportLevel !== 'monitor'\n              ) {\n                addAlert(\n                  artifact,\n                  violations,\n                  fold,\n                  ecosystem,\n                  pkgName,\n                  version,\n                  alert,\n                  action,\n                )\n              }\n              break\n            }\n\n            case 'defer': {\n              // Not sure but ignore for now. Defer to later ;)\n              if (!short && reportLevel === 'defer') {\n                addAlert(\n                  artifact,\n                  violations,\n                  fold,\n                  ecosystem,\n                  pkgName,\n                  version,\n                  alert,\n                  action,\n                )\n              }\n              break\n            }\n\n            default: {\n              // This value was not emitted from the api at the time of writing.\n            }\n          }\n        },\n      )\n    })\n  }\n\n  spinner?.successAndStop(`Generated reported in ${Date.now() - now} ms`)\n\n  if (short) {\n    return {\n      ok: true,\n      data: { healthy },\n    }\n  }\n\n  const report = {\n    healthy,\n    orgSlug,\n    scanId,\n    options: { fold, reportLevel },\n    alerts: violations,\n  }\n\n  if (!healthy) {\n    return {\n      ok: true,\n      message:\n        'The report contains at least one alert that violates the policies set by your organization',\n      data: report,\n    }\n  }\n\n  return {\n    ok: true,\n    data: report,\n  }\n}\n\nfunction createLeaf(\n  art: SocketArtifact,\n  alert: NonNullable<SocketArtifact['alerts']>[number],\n  policyAction: AlertAction,\n): ReportLeafNode {\n  const leaf: ReportLeafNode = {\n    type: alert.type,\n    policy: policyAction,\n    url: getSocketDevPackageOverviewUrlFromPurl(art),\n    manifest: art.manifestFiles?.map(obj => obj.file) ?? [],\n  }\n  return leaf\n}\n\nfunction addAlert(\n  art: SocketArtifact,\n  violations: ViolationsMap,\n  foldSetting: 'pkg' | 'version' | 'file' | 'none',\n  ecosystem: string,\n  pkgName: string,\n  version: string,\n  alert: NonNullable<SocketArtifact['alerts']>[number],\n  policyAction: AlertAction,\n): void {\n  if (!violations.has(ecosystem)) {\n    violations.set(ecosystem, new Map())\n  }\n  const ecomap: EcoMap = violations.get(ecosystem)!\n  if (foldSetting === 'pkg') {\n    const existing = ecomap.get(pkgName) as ReportLeafNode | undefined\n    if (!existing || isStricterPolicy(existing.policy, policyAction)) {\n      ecomap.set(pkgName, createLeaf(art, alert, policyAction))\n    }\n  } else {\n    if (!ecomap.has(pkgName)) {\n      ecomap.set(pkgName, new Map())\n    }\n    const pkgmap = ecomap.get(pkgName) as PackageMap\n    if (foldSetting === 'version') {\n      const existing = pkgmap.get(version) as ReportLeafNode | undefined\n      if (!existing || isStricterPolicy(existing.policy, policyAction)) {\n        pkgmap.set(version, createLeaf(art, alert, policyAction))\n      }\n    } else {\n      if (!pkgmap.has(version)) {\n        pkgmap.set(version, new Map())\n      }\n      const file = alert.file || '<unknown>'\n      const vermap = pkgmap.get(version) as VersionMap\n\n      if (foldSetting === 'file') {\n        const existing = vermap.get(file) as ReportLeafNode | undefined\n        if (!existing || isStricterPolicy(existing.policy, policyAction)) {\n          vermap.set(file, createLeaf(art, alert, policyAction))\n        }\n      } else {\n        if (!vermap.has(file)) {\n          vermap.set(file, new Map())\n        }\n        const key = `${alert.type} at ${alert.start}:${alert.end}`\n        const filemap: FileMap = vermap.get(file) as FileMap\n        const existing = filemap.get(key) as ReportLeafNode | undefined\n        if (!existing || isStricterPolicy(existing.policy, policyAction)) {\n          filemap.set(key, createLeaf(art, alert, policyAction))\n        }\n      }\n    }\n  }\n}\n\nfunction isStricterPolicy(\n  was: 'error' | 'warn' | 'monitor' | 'ignore' | 'defer',\n  is: 'error' | 'warn' | 'monitor' | 'ignore' | 'defer',\n): boolean {\n  // error > warn > monitor > ignore > defer > {unknown}\n  if (was === 'error') {\n    return false\n  }\n  if (is === 'error') {\n    return true\n  }\n  if (was === 'warn') {\n    return false\n  }\n  if (is === 'warn') {\n    return false\n  }\n  if (was === 'monitor') {\n    return false\n  }\n  if (is === 'monitor') {\n    return false\n  }\n  if (was === 'ignore') {\n    return false\n  }\n  if (is === 'ignore') {\n    return false\n  }\n  if (was === 'defer') {\n    return false\n  }\n  if (is === 'defer') {\n    return false\n  }\n  // unreachable?\n  return false\n}\n","import fs from 'node:fs/promises'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { generateReport } from './generate-report.mts'\nimport constants from '../../constants.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mapToObject } from '../../utils/map-to-object.mts'\nimport { mdTable } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\nimport { walkNestedMap } from '../../utils/walk-nested-map.mts'\n\nimport type { ReportLeafNode, ScanReport } from './generate-report.mts'\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketArtifact } from '../../utils/alert/artifact.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputScanReport(\n  result: CResult<{\n    scan: SocketArtifact[]\n    securityPolicy: SocketSdkReturnType<'getOrgSecurityPolicy'>['data']\n  }>,\n  {\n    filePath,\n    fold,\n    includeLicensePolicy,\n    orgSlug,\n    outputKind,\n    reportLevel,\n    scanId,\n    short,\n  }: {\n    orgSlug: string\n    scanId: string\n    includeLicensePolicy: boolean\n    outputKind: OutputKind\n    filePath: string\n    fold: 'pkg' | 'version' | 'file' | 'none'\n    reportLevel: 'defer' | 'ignore' | 'monitor' | 'warn' | 'error'\n    short: boolean\n  },\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const scanReport = generateReport(\n    result.data.scan,\n    result.data.securityPolicy,\n    {\n      orgSlug,\n      scanId,\n      fold,\n      reportLevel,\n      short,\n      // Lazily access constants.spinner.\n      spinner: constants.spinner,\n    },\n  )\n\n  if (!scanReport.ok) {\n    // Note: this means generation failed, it does not reflect the healthy state\n    process.exitCode = scanReport.code ?? 1\n\n    // If report generation somehow failed then .data should not be set.\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(scanReport))\n      return\n    }\n    logger.fail(failMsgWithBadge(scanReport.message, scanReport.cause))\n    return\n  }\n\n  // I don't think we emit the default error message with banner for an unhealhty report, do we?\n  // if (!scanReport.data.healhty) {\n  //   logger.fail(failMsgWithBadge(scanReport.message, scanReport.cause))\n  //   return\n  // }\n\n  if (\n    outputKind === 'json' ||\n    (outputKind === 'text' && filePath && filePath.endsWith('.json'))\n  ) {\n    const json = short\n      ? serializeResultJson(scanReport)\n      : toJsonReport(scanReport.data as ScanReport, includeLicensePolicy)\n\n    if (filePath && filePath !== '-') {\n      logger.log('Writing json report to', filePath)\n      return await fs.writeFile(filePath, json)\n    }\n\n    logger.log(json)\n    return\n  }\n\n  if (outputKind === 'markdown' || (filePath && filePath.endsWith('.md'))) {\n    const md = short\n      ? `healthy = ${scanReport.data.healthy}`\n      : toMarkdownReport(\n          scanReport.data as ScanReport, // not short so must be regular report\n          includeLicensePolicy,\n        )\n\n    if (filePath && filePath !== '-') {\n      logger.log('Writing markdown report to', filePath)\n      return await fs.writeFile(filePath, md)\n    }\n\n    logger.log(md)\n    logger.log('')\n    return\n  }\n\n  if (short) {\n    logger.log(scanReport.data.healthy ? 'OK' : 'ERR')\n  } else {\n    logger.dir(scanReport.data, { depth: null })\n  }\n}\n\nexport function toJsonReport(\n  report: ScanReport,\n  includeLicensePolicy?: boolean | undefined,\n): string {\n  const obj = mapToObject(report.alerts)\n\n  const newReport = {\n    includeLicensePolicy,\n    ...report,\n    alerts: obj,\n  }\n\n  return serializeResultJson({\n    ok: true,\n    data: newReport,\n  })\n}\n\nexport function toMarkdownReport(\n  report: ScanReport,\n  includeLicensePolicy?: boolean | undefined,\n): string {\n  const flatData = Array.from(walkNestedMap(report.alerts)).map(\n    ({ keys, value }: { keys: string[]; value: ReportLeafNode }) => {\n      const { manifest, policy, type, url } = value\n      return {\n        'Alert Type': type,\n        Package: keys[1] || '<unknown>',\n        'Introduced by': keys[2] || '<unknown>',\n        url,\n        'Manifest file': manifest.join(', '),\n        Policy: policy,\n      }\n    },\n  )\n\n  const md =\n    `\n# Scan Policy Report\n\nThis report tells you whether the results of a Socket scan results violate the\nsecurity${includeLicensePolicy ? ' or license' : ''} policy set by your organization.\n\n## Health status\n\n${\n  report.healthy\n    ? `The scan *PASSES* all requirements set by your security${includeLicensePolicy ? ' and license' : ''} policy.`\n    : 'The scan *VIOLATES* one or more policies set to the \"error\" level.'\n}\n\n## Settings\n\nConfiguration used to generate this report:\n\n- Organization: ${report.orgSlug}\n- Scan ID: ${report.scanId}\n- Alert folding: ${report.options.fold === 'none' ? 'none' : `up to ${report.options.fold}`}\n- Minimal policy level for alert to be included in report: ${report.options.reportLevel === 'defer' ? 'everything' : report.options.reportLevel}\n- Include license alerts: ${includeLicensePolicy ? 'yes' : 'no'}\n\n## Alerts\n\n${\n  report.alerts.size\n    ? `All the alerts from the scan with a policy set to at least \"${report.options.reportLevel}\".`\n    : `The scan contained no alerts with a policy set to at least \"${report.options.reportLevel}\".`\n}\n\n${\n  !report.alerts.size\n    ? ''\n    : mdTable(flatData, [\n        'Policy',\n        'Alert Type',\n        'Package',\n        'Introduced by',\n        'url',\n        'Manifest file',\n      ])\n}\n  `.trim() + '\\n'\n\n  return md\n}\n","import { fetchReportData } from './fetch-report-data.mts'\nimport { outputScanReport } from './output-scan-report.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleScanReport({\n  filePath,\n  fold,\n  includeLicensePolicy,\n  orgSlug,\n  outputKind,\n  reportLevel,\n  scanId,\n  short,\n}: {\n  orgSlug: string\n  scanId: string\n  includeLicensePolicy: boolean\n  outputKind: OutputKind\n  filePath: string\n  fold: 'pkg' | 'version' | 'file' | 'none'\n  reportLevel: 'defer' | 'ignore' | 'monitor' | 'warn' | 'error'\n  short: boolean\n}): Promise<void> {\n  const result = await fetchReportData(orgSlug, scanId, includeLicensePolicy)\n\n  await outputScanReport(result, {\n    filePath,\n    fold,\n    scanId: scanId,\n    includeLicensePolicy,\n    orgSlug,\n    outputKind,\n    reportLevel,\n    short,\n  })\n}\n","import open from 'open'\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { confirm } from '@socketsecurity/registry/lib/prompts'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputCreateNewScan(\n  result: CResult<SocketSdkReturnType<'CreateOrgFullScan'>['data']>,\n  outputKind: OutputKind,\n  interactive: boolean,\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (!result.data.id) {\n    logger.fail('Did not receive a scan ID from the API...')\n    process.exitCode = 1\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log('# Create New Scan')\n    logger.log('')\n    if (result.data.id) {\n      logger.log(\n        `A [new Scan](${result.data.html_report_url}) was created with ID: ${result.data.id}`,\n      )\n      logger.log('')\n    } else {\n      logger.log(\n        `The server did not return a Scan ID while trying to create a new Scan. This could be an indication something went wrong.`,\n      )\n    }\n    logger.log('')\n    return\n  }\n\n  const link = colors.underline(colors.cyan(`${result.data.html_report_url}`))\n  logger.log(`Available at: ${link}`)\n\n  if (\n    interactive &&\n    (await confirm({\n      message: 'Would you like to open it in your browser?',\n      default: false,\n    }))\n  ) {\n    await open(`${result.data.html_report_url}`)\n  }\n}\n","// The point here is to attempt to detect the various supported manifest files\n// the CLI can generate. This would be environments that we can't do server side\n\nimport { existsSync } from 'node:fs'\nimport path from 'node:path'\n\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\n\nimport type { SocketJson } from '../../utils/socketjson.mts'\n\nexport interface GeneratableManifests {\n  cdxgen: boolean\n  count: number\n  conda: boolean\n  gradle: boolean\n  sbt: boolean\n}\n\nexport async function detectManifestActions(\n  // Passing in null means we attempt detection for every supported language\n  // regardless of local socket.json status. Sometimes we want that.\n  socketJson: SocketJson | null,\n  cwd = process.cwd(),\n): Promise<GeneratableManifests> {\n  const output = {\n    cdxgen: false, // TODO\n    count: 0,\n    conda: false,\n    gradle: false,\n    sbt: false,\n  }\n\n  if (socketJson?.defaults?.manifest?.sbt?.disabled) {\n    debugLog('[DEBUG] - sbt auto-detection is disabled in socket.json')\n  } else if (existsSync(path.join(cwd, 'build.sbt'))) {\n    debugLog('[DEBUG] - Detected a Scala sbt build file')\n\n    output.sbt = true\n    output.count += 1\n  }\n\n  if (socketJson?.defaults?.manifest?.gradle?.disabled) {\n    debugLog('[DEBUG] - gradle auto-detection is disabled in socket.json')\n  } else if (existsSync(path.join(cwd, 'gradlew'))) {\n    debugLog('[DEBUG] - Detected a gradle build file')\n    output.gradle = true\n    output.count += 1\n  }\n\n  if (socketJson?.defaults?.manifest?.conda?.disabled) {\n    debugLog('[DEBUG] - conda auto-detection is disabled in socket.json')\n  } else {\n    const envyml = path.join(cwd, 'environment.yml')\n    const hasEnvyml = existsSync(envyml)\n    const envyaml = path.join(cwd, 'environment.yaml')\n    const hasEnvyaml = !hasEnvyml && existsSync(envyaml)\n    if (hasEnvyml || hasEnvyaml) {\n      debugLog('[DEBUG] - Detected an environment.yml Conda file')\n      output.conda = true\n      output.count += 1\n    }\n  }\n\n  return output\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\n\nexport async function convertGradleToMaven({\n  bin,\n  cwd,\n  gradleOpts,\n  verbose,\n}: { bin: string; cwd: string; verbose: boolean; gradleOpts: string[] }) {\n  // TODO: impl json/md\n\n  // Note: use resolve because the bin could be an absolute path, away from cwd\n  // TODO: what about $PATH resolved commands? (`gradlew` without dir prefix)\n  const rBin = path.resolve(cwd, bin)\n  const binExists = fs.existsSync(rBin)\n  const cwdExists = fs.existsSync(cwd)\n\n  logger.group('gradle2maven:')\n  logger.info(`- executing: \\`${rBin}\\``)\n  if (!binExists) {\n    logger.warn(\n      `Warning: It appears the executable could not be found. An error might be printed later because of that.`,\n    )\n  }\n  logger.info(`- src dir: \\`${cwd}\\``)\n  if (!cwdExists) {\n    logger.warn(\n      `Warning: It appears the src dir could not be found. An error might be printed later because of that.`,\n    )\n  }\n  logger.groupEnd()\n\n  try {\n    // Run gradlew with the init script we provide which should yield zero or more\n    // pom files. We have to figure out where to store those pom files such that\n    // we can upload them and predict them through the GitHub API. We could do a\n    // .socket folder. We could do a socket.pom.gz with all the poms, although\n    // I'd prefer something plain-text if it is to be committed.\n    // Note: init.gradle will be exported by .config/rollup.dist.config.mjs\n    const initLocation = path.join(constants.distPath, 'init.gradle')\n    const commandArgs = ['--init-script', initLocation, ...gradleOpts, 'pom']\n    if (verbose) {\n      logger.log('[VERBOSE] Executing:', [bin], ', args:', commandArgs)\n    }\n    logger.log(`Converting gradle to maven from \\`${bin}\\` on \\`${cwd}\\` ...`)\n    const output = await execGradleWithSpinner(rBin, commandArgs, cwd)\n    if (verbose) {\n      logger.group('[VERBOSE] gradle stdout:')\n      logger.log(output)\n      logger.groupEnd()\n    }\n    if (output.code !== 0) {\n      process.exitCode = 1\n      logger.fail(`Gradle exited with exit code ${output.code}`)\n      // (In verbose mode, stderr was printed above, no need to repeat it)\n      if (!verbose) {\n        logger.group('stderr:')\n        logger.error(output.stderr)\n        logger.groupEnd()\n      }\n      return\n    }\n    logger.success('Executed gradle successfully')\n    logger.log('Reported exports:')\n    output.stdout.replace(\n      /^POM file copied to: (.*)/gm,\n      (_all: string, fn: string) => {\n        logger.log('- ', fn)\n        return fn\n      },\n    )\n    logger.log('')\n    logger.log(\n      'Next step is to generate a Scan by running the `socket scan create` command on the same directory',\n    )\n  } catch (e) {\n    process.exitCode = 1\n    logger.fail(\n      'There was an unexpected error while generating manifests' +\n        (verbose ? '' : '  (use --verbose for details)'),\n    )\n    if (verbose) {\n      logger.group('[VERBOSE] error:')\n      logger.log(e)\n      logger.groupEnd()\n    }\n  }\n}\n\nasync function execGradleWithSpinner(\n  bin: string,\n  commandArgs: string[],\n  cwd: string,\n): Promise<{ code: number; stdout: string; stderr: string }> {\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n\n  let pass = false\n  try {\n    logger.info(\n      '(Running gradle can take a while, it depends on how long gradlew has to run)',\n    )\n    logger.info(\n      '(It will show no output, you can use --verbose to see its output)',\n    )\n    spinner.start(`Running gradlew`)\n\n    const output = await spawn(bin, commandArgs, {\n      // We can pipe the output through to have the user see the result\n      // of running gradlew, but then we can't (easily) gather the output\n      // to discover the generated files... probably a flag we should allow?\n      // stdio: isDebug() ? 'inherit' : undefined,\n      cwd,\n    })\n\n    pass = true\n    const { code, stderr, stdout } = output\n    return { code, stdout, stderr }\n  } finally {\n    if (pass) {\n      spinner.successAndStop('Gracefully completed gradlew execution.')\n    } else {\n      spinner.failAndStop('There was an error while trying to run gradlew.')\n    }\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\nimport { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\nimport { safeReadFile } from '../../utils/fs.mts'\n\nexport async function convertSbtToMaven({\n  bin,\n  cwd,\n  out,\n  sbtOpts,\n  verbose,\n}: {\n  bin: string\n  cwd: string\n  out: string\n  sbtOpts: string[]\n  verbose: boolean\n}) {\n  // TODO: impl json/md\n\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n\n  logger.group('sbt2maven:')\n  logger.info(`- executing: \\`${bin}\\``)\n  logger.info(`- src dir: \\`${cwd}\\``)\n  logger.groupEnd()\n\n  try {\n    spinner.start(`Converting sbt to maven from \\`${bin}\\` on \\`${cwd}\\`...`)\n\n    // Run sbt with the init script we provide which should yield zero or more\n    // pom files. We have to figure out where to store those pom files such that\n    // we can upload them and predict them through the GitHub API. We could do a\n    // .socket folder. We could do a socket.pom.gz with all the poms, although\n    // I'd prefer something plain-text if it is to be committed.\n    const output = await spawn(bin, ['makePom', ...sbtOpts], { cwd })\n\n    spinner.stop()\n\n    if (verbose) {\n      logger.group('[VERBOSE] sbt stdout:')\n      logger.log(output)\n      logger.groupEnd()\n    }\n    if (output.stderr) {\n      process.exitCode = 1\n      logger.fail('There were errors while running sbt')\n      // (In verbose mode, stderr was printed above, no need to repeat it)\n      if (!verbose) {\n        logger.group('[VERBOSE] stderr:')\n        logger.error(output.stderr)\n        logger.groupEnd()\n      }\n      return\n    }\n    const poms: string[] = []\n    output.stdout.replace(/Wrote (.*?.pom)\\n/g, (_all: string, fn: string) => {\n      poms.push(fn)\n      return fn\n    })\n    if (!poms.length) {\n      process.exitCode = 1\n      logger.fail(\n        'There were no errors from sbt but it seems to not have generated any poms either',\n      )\n      return\n    }\n    // Move the pom file to ...? initial cwd? loc will be an absolute path, or dump to stdout\n    // TODO: what to do with multiple output files? Do we want to dump them to stdout? Raw or with separators or ?\n    // TODO: maybe we can add an option to target a specific file to dump to stdout\n    if (out === '-' && poms.length === 1) {\n      logger.log('Result:\\n```')\n      logger.log(await safeReadFile(poms[0]!))\n      logger.log('```')\n      logger.success(`OK`)\n    } else if (out === '-') {\n      process.exitCode = 1\n      logger.error('')\n      logger.fail(\n        'Requested output target was stdout but there are multiple generated files',\n      )\n      logger.error('')\n      poms.forEach(fn => logger.info('-', fn))\n      if (poms.length > 10) {\n        logger.error('')\n        logger.fail(\n          'Requested output target was stdout but there are multiple generated files',\n        )\n      }\n      logger.error('')\n      logger.info('Exiting now...')\n      return\n    } else {\n      // if (verbose) {\n      //   logger.log(\n      //     `Moving manifest file from \\`${loc.replace(/^\\/home\\/[^/]*?\\//, '~/')}\\` to \\`${out}\\``\n      //   )\n      // } else {\n      //   logger.log('Moving output pom file')\n      // }\n      // TODO: do we prefer fs-extra? renaming can be gnarly on windows and fs-extra's version is better\n      // await renamep(loc, out)\n      logger.success(`Generated ${poms.length} pom files`)\n      poms.forEach(fn => logger.log('-', fn))\n      logger.success(`OK`)\n    }\n  } catch (e) {\n    process.exitCode = 1\n    spinner.stop()\n    logger.fail(\n      'There was an unexpected error while running this' +\n        (verbose ? '' : ' (use --verbose for details)'),\n    )\n    if (verbose) {\n      logger.group('[VERBOSE] error:')\n      logger.log(e)\n      logger.groupEnd()\n    }\n  }\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport type { CResult } from '../../types.mts'\n\nexport async function convertCondaToRequirements(\n  filename: string,\n  cwd: string,\n  verbose: boolean,\n): Promise<CResult<{ contents: string; pip: string }>> {\n  let contents: string\n  if (filename === '-') {\n    if (verbose) {\n      logger.info(`[VERBOSE] reading input from stdin`)\n    }\n\n    const buf: string[] = []\n    contents = await new Promise((resolve, reject) => {\n      process.stdin.on('data', chunk => {\n        const input = chunk.toString()\n        buf.push(input)\n      })\n      process.stdin.on('end', () => {\n        resolve(buf.join(''))\n      })\n      process.stdin.on('error', e => {\n        if (verbose) {\n          logger.error('Unexpected error while reading from stdin:', e)\n        }\n        reject(e)\n      })\n      process.stdin.on('close', () => {\n        if (buf.length === 0) {\n          if (verbose) {\n            logger.error('stdin closed explicitly without data received')\n          }\n          reject(new Error('No data received from stdin'))\n        } else {\n          if (verbose) {\n            logger.error(\n              'warning: stdin closed explicitly with some data received',\n            )\n          }\n          resolve(buf.join(''))\n        }\n      })\n    })\n\n    if (!contents) {\n      return {\n        ok: false,\n        message: 'Manifest Generation Failed',\n        cause: 'No data received from stdin',\n      }\n    }\n  } else {\n    const filepath = path.join(cwd, filename)\n\n    if (verbose) {\n      logger.info(`[VERBOSE] target: ${filepath}`)\n    }\n\n    if (!fs.existsSync(filepath)) {\n      return {\n        ok: false,\n        message: 'Manifest Generation Failed',\n        cause: `The file was not found at ${filepath}`,\n      }\n    }\n\n    contents = fs.readFileSync(filepath, 'utf8')\n\n    if (!contents) {\n      return {\n        ok: false,\n        message: 'Manifest Generation Failed',\n        cause: `File at ${filepath} is empty`,\n      }\n    }\n  }\n\n  return {\n    ok: true,\n    data: {\n      contents,\n      pip: convertCondaToRequirementsFromInput(contents),\n    },\n  }\n}\n\n// Just extract the first pip block, if one exists at all.\nexport function convertCondaToRequirementsFromInput(input: string): string {\n  const keeping: string[] = []\n  let collecting = false\n  let delim = '-'\n  let indent = ''\n  input.split('\\n').some(line => {\n    if (!line) {\n      // Ignore empty lines\n      return\n    }\n    if (collecting) {\n      if (line.startsWith('#')) {\n        // Ignore comment lines (keep?)\n        return\n      }\n      if (line.startsWith(delim)) {\n        // In this case we have a line with the same indentation as the\n        // `- pip:` line, so we have reached the end of the pip block.\n        return true // the end\n      } else {\n        if (!indent) {\n          // Store the indentation of the block\n          if (line.trim().startsWith('-')) {\n            indent = line.split('-')[0] + '-'\n            if (indent.length <= delim.length) {\n              // The first line after the `pip:` line does not indent further\n              // than that so the block is empty?\n              return true\n            }\n          }\n        }\n        if (line.startsWith(indent)) {\n          keeping.push(line.slice(indent.length).trim())\n        } else {\n          // Unexpected input. bail.\n          return true\n        }\n      }\n    } else {\n      // Note: the line may end with a line comment so don't === it.\n      if (line.trim().startsWith('- pip:')) {\n        delim = line.split('-')[0] + '-'\n        collecting = true\n      }\n    }\n  })\n\n  return keeping.join('\\n')\n}\n","import fs from 'node:fs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\n\nexport async function outputRequirements(\n  result: CResult<{ contents: string; pip: string }>,\n  outputKind: OutputKind,\n  out: string,\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'json') {\n    const json = serializeResultJson(result)\n\n    if (out === '-') {\n      logger.log(json)\n    } else {\n      fs.writeFileSync(out, json, 'utf8')\n    }\n\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    const arr = []\n    arr.push('# Converted Conda file')\n    arr.push('')\n    arr.push(\n      'This is the Conda `environment.yml` file converted to python `requirements.txt`:',\n    )\n    arr.push('')\n    arr.push('```file=requirements.txt')\n    arr.push(result.data.pip)\n    arr.push('```')\n    arr.push('')\n    const md = arr.join('\\n')\n\n    if (out === '-') {\n      logger.log(md)\n    } else {\n      fs.writeFileSync(out, md, 'utf8')\n    }\n    return\n  }\n\n  if (out === '-') {\n    logger.log(result.data.pip)\n    logger.log('')\n  } else {\n    fs.writeFileSync(out, result.data.pip, 'utf8')\n  }\n}\n","import { convertCondaToRequirements } from './convert-conda-to-requirements.mts'\nimport { outputRequirements } from './output-requirements.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleManifestConda({\n  cwd,\n  filename,\n  out,\n  outputKind,\n  verbose,\n}: {\n  cwd: string\n  filename: string\n  out: string\n  outputKind: OutputKind\n  verbose: boolean\n}): Promise<void> {\n  const data = await convertCondaToRequirements(filename, cwd, verbose)\n\n  await outputRequirements(data, outputKind, out)\n}\n","import path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { convertGradleToMaven } from './convert_gradle_to_maven.mts'\nimport { convertSbtToMaven } from './convert_sbt_to_maven.mts'\nimport { handleManifestConda } from './handle-manifest-conda.mts'\nimport { readOrDefaultSocketJson } from '../../utils/socketjson.mts'\n\nimport type { GeneratableManifests } from './detect-manifest-actions.mts'\nimport type { OutputKind } from '../../types.mts'\n\nexport async function generateAutoManifest({\n  cwd,\n  detected,\n  outputKind,\n  verbose,\n}: {\n  detected: GeneratableManifests\n  cwd: string\n  outputKind: OutputKind\n  verbose: boolean\n}) {\n  const socketJson = await readOrDefaultSocketJson(cwd)\n\n  if (verbose) {\n    logger.info('Using this socket.json for defaults:', socketJson)\n  }\n\n  if (!socketJson?.defaults?.manifest?.sbt?.disabled && detected.sbt) {\n    logger.log('Detected a Scala sbt build, generating pom files with sbt...')\n    await convertSbtToMaven({\n      // Note: `sbt` is more likely to be resolved against PATH env\n      bin: socketJson.defaults?.manifest?.sbt?.bin ?? 'sbt',\n      cwd,\n      out:\n        socketJson.defaults?.manifest?.sbt?.outfile ?? './socket.sbt.pom.xml',\n      sbtOpts:\n        socketJson.defaults?.manifest?.sbt?.sbtOpts\n          ?.split(' ')\n          .map(s => s.trim())\n          .filter(Boolean) ?? [],\n      verbose: Boolean(socketJson.defaults?.manifest?.sbt?.verbose),\n    })\n  }\n\n  if (!socketJson?.defaults?.manifest?.gradle?.disabled && detected.gradle) {\n    logger.log(\n      'Detected a gradle build (Gradle, Kotlin, Scala), running default gradle generator...',\n    )\n    await convertGradleToMaven({\n      // Note: `gradlew` is more likely to be resolved against cwd\n      // Note: .resolve() wont butcher an absolute path\n      // TODO: `gradlew` (or anything else given) may want to resolve against PATH\n      bin: socketJson.defaults?.manifest?.gradle?.bin\n        ? path.resolve(cwd, socketJson.defaults.manifest.gradle.bin)\n        : path.join(cwd, 'gradlew'),\n      cwd,\n      verbose: Boolean(socketJson.defaults?.manifest?.gradle?.verbose),\n      gradleOpts:\n        socketJson.defaults?.manifest?.gradle?.gradleOpts\n          ?.split(' ')\n          .map(s => s.trim())\n          .filter(Boolean) ?? [],\n    })\n  }\n\n  if (!socketJson?.defaults?.manifest?.conda?.disabled && detected.conda) {\n    logger.log(\n      'Detected an environment.yml file, running default Conda generator...',\n    )\n    await handleManifestConda({\n      cwd,\n      filename:\n        socketJson.defaults?.manifest?.conda?.infile ?? 'environment.yml',\n      outputKind,\n      out: socketJson.defaults?.manifest?.conda?.outfile ?? 'requirements.txt',\n      verbose: Boolean(socketJson.defaults?.manifest?.conda?.verbose),\n    })\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { fetchCreateOrgFullScan } from './fetch-create-org-full-scan.mts'\nimport { fetchSupportedScanFileNames } from './fetch-supported-scan-file-names.mts'\nimport { handleScanReport } from './handle-scan-report.mts'\nimport { outputCreateNewScan } from './output-create-new-scan.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getPackageFilesForScan } from '../../utils/path-resolve.mts'\nimport { readOrDefaultSocketJson } from '../../utils/socketjson.mts'\nimport { detectManifestActions } from '../manifest/detect-manifest-actions.mts'\nimport { generateAutoManifest } from '../manifest/generate_auto_manifest.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleCreateNewScan({\n  autoManifest,\n  branchName,\n  commitHash,\n  commitMessage,\n  committers,\n  cwd,\n  defaultBranch,\n  interactive,\n  orgSlug,\n  outputKind,\n  pendingHead,\n  pullRequest,\n  readOnly,\n  repoName,\n  report,\n  targets,\n  tmp,\n}: {\n  autoManifest: boolean\n  branchName: string\n  commitHash: string\n  commitMessage: string\n  committers: string\n  cwd: string\n  defaultBranch: boolean\n  interactive: boolean\n  orgSlug: string\n  pendingHead: boolean\n  pullRequest: number\n  outputKind: OutputKind\n  readOnly: boolean\n  repoName: string\n  report: boolean\n  targets: string[]\n  tmp: boolean\n}): Promise<void> {\n  if (autoManifest) {\n    logger.info('Auto generating manifest files ...')\n    const socketJson = await readOrDefaultSocketJson(cwd)\n    const detected = await detectManifestActions(socketJson, cwd)\n    await generateAutoManifest({\n      detected,\n      cwd,\n      outputKind,\n      verbose: false,\n    })\n    logger.info('Auto generation finished. Proceeding with Scan creation.')\n  }\n\n  const supportedFileNames = await fetchSupportedScanFileNames()\n  if (!supportedFileNames.ok) {\n    await outputCreateNewScan(supportedFileNames, outputKind, interactive)\n    return\n  }\n\n  const packagePaths = await getPackageFilesForScan(\n    cwd,\n    targets,\n    supportedFileNames.data,\n  )\n\n  const wasValidInput = checkCommandInput(outputKind, {\n    nook: true,\n    test: packagePaths.length > 0,\n    pass: 'ok',\n    fail: 'found no eligible files to scan',\n    message:\n      'TARGET (file/dir) must contain matching / supported file types for a scan',\n  })\n  if (!wasValidInput) {\n    return\n  }\n\n  if (readOnly) {\n    logger.log('[ReadOnly] Bailing now')\n    return\n  }\n\n  const data = await fetchCreateOrgFullScan(\n    packagePaths,\n    orgSlug,\n    defaultBranch,\n    pendingHead,\n    tmp,\n    cwd,\n    {\n      commitHash,\n      commitMessage,\n      committers,\n      pullRequest,\n      repoName,\n      branchName,\n    },\n  )\n\n  if (data.ok && report) {\n    if (data.data?.id) {\n      await handleScanReport({\n        filePath: '-',\n        fold: 'version',\n        includeLicensePolicy: true,\n        orgSlug,\n        outputKind,\n        reportLevel: 'error',\n        scanId: data.data.id,\n        short: false,\n      })\n    } else {\n      await outputCreateNewScan(\n        {\n          ok: false,\n          message: 'Missing Scan ID',\n          cause: 'Server did not respond with a scan ID',\n          data: data.data,\n        },\n        outputKind,\n        interactive,\n      )\n    }\n  } else {\n    await outputCreateNewScan(data, outputKind, interactive)\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { getDefaultOrgSlug } from './fetch-default-org-slug.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\nimport { handleCreateNewScan } from '../scan/handle-create-new-scan.mts'\n\nexport async function handleCI(autoManifest: boolean): Promise<void> {\n  // ci: {\n  //   description: 'Alias for \"report create --view --strict\"',\n  //     argv: ['report', 'create', '--view', '--strict']\n  // }\n  const result = await getDefaultOrgSlug()\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n    // Always assume json mode\n    logger.log(serializeResultJson(result))\n    return\n  }\n\n  // TODO: does it make sense to discover the commit details from local git?\n  // TODO: does it makes sense to use custom branch/repo names here? probably socket.yml, right\n  await handleCreateNewScan({\n    autoManifest,\n    branchName: 'socket-default-branch',\n    commitMessage: '',\n    commitHash: '',\n    committers: '',\n    cwd: process.cwd(),\n    defaultBranch: false,\n    interactive: false,\n    orgSlug: result.data,\n    outputKind: 'json',\n    pendingHead: true, // when true, requires branch name set, tmp false\n    pullRequest: 0,\n    repoName: 'socket-default-repository',\n    readOnly: false,\n    report: true,\n    targets: ['.'],\n    tmp: false, // don't set when pendingHead is true\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleCI } from './handle-ci.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'ci',\n  description:\n    'Create a new scan and report whether it passes your security policy',\n  hidden: true,\n  flags: {\n    ...commonFlags,\n    autoManifest: {\n      type: 'boolean',\n      default: false, // dev tools is not likely to be set up so this is safer\n      description:\n        'Auto generate manifest files where detected? See autoManifest flag in `socket scan create`',\n    },\n  },\n  help: (parentName, _config) => `\n    Usage\n      $ ${parentName}\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    This command is intended to use in CI runs to allow automated systems to\n    accept or reject a current build. When the scan does not pass your security\n    policy, the exit code will be non-zero.\n\n    It will use the default org for the set API token.\n\n    The --autoManifest flag does the same as the one from \\`socket scan create\\`\n    but is not enabled by default since the CI is less likely to be set up with\n    all the necessary dev tooling. Enable it if you want the scan to include\n    locally generated manifests like for gradle and sbt.\n  `,\n}\n\nexport const cmdCI = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleCI(Boolean(cli.flags['autoManifest']))\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { hasDefaultToken, setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function discoverConfigValue(\n  key: string,\n): Promise<CResult<unknown>> {\n  // This will have to be a specific implementation per key because certain\n  // keys should request information from particular API endpoints while\n  // others should simply return their default value, like endpoint URL.\n\n  if (!supportedConfigKeys.has(key as keyof LocalConfig)) {\n    return {\n      ok: false,\n      message: 'Auto discover failed',\n      cause: 'Requested key is not a valid config key.',\n    }\n  }\n\n  if (key === 'apiBaseUrl') {\n    // Return the default value\n    return {\n      ok: false,\n      message: 'Auto discover failed',\n      cause:\n        \"If you're unsure about the base endpoint URL then simply unset it.\",\n    }\n  }\n\n  if (key === 'apiProxy') {\n    // I don't think we can auto-discover this with any order of reliability..?\n    return {\n      ok: false,\n      message: 'Auto discover failed',\n      cause:\n        'When uncertain, unset this key. Otherwise ask your network administrator',\n    }\n  }\n\n  if (key === 'apiToken') {\n    return {\n      ok: false,\n      message: 'Auto discover failed',\n      cause:\n        'You can find/create your API token in your Socket dashboard > settings > API tokens.\\nYou should then use `socket login` to login instead of this command.',\n    }\n  }\n\n  if (key === 'defaultOrg') {\n    const hasApiToken = hasDefaultToken()\n    if (!hasApiToken) {\n      return {\n        ok: false,\n        message: 'Auto discover failed',\n        cause:\n          'No API token set, must have a token to resolve its default org.',\n      }\n    }\n\n    const org = await getDefaultOrgFromToken()\n    if (!org?.length) {\n      return {\n        ok: false,\n        message: 'Auto discover failed',\n        cause: 'Was unable to determine default org for the current API token.',\n      }\n    }\n\n    if (Array.isArray(org)) {\n      return {\n        ok: true,\n        data: org,\n        message: 'These are the orgs that the current API token can access.',\n      }\n    }\n\n    return {\n      ok: true,\n      data: org,\n      message: 'This is the org that belongs to the current API token.',\n    }\n  }\n\n  if (key === 'enforcedOrgs') {\n    const hasApiToken = hasDefaultToken()\n    if (!hasApiToken) {\n      return {\n        ok: false,\n        message: 'Auto discover failed',\n        cause:\n          'No API token set, must have a token to resolve orgs to enforce.',\n      }\n    }\n\n    const orgs = await getEnforceableOrgsFromToken()\n    if (!orgs?.length) {\n      return {\n        ok: false,\n        message: 'Auto discover failed',\n        cause:\n          'Was unable to determine any orgs to enforce for the current API token.',\n      }\n    }\n\n    return {\n      ok: true,\n      data: orgs,\n      message: 'These are the orgs whose security policy you can enforce.',\n    }\n  }\n\n  if (key === 'test') {\n    return {\n      ok: false,\n      message: 'Auto discover failed',\n      cause: 'congrats, you found the test key',\n    }\n  }\n\n  // Mostly to please TS, because we're not telling it `key` is keyof LocalConfig\n  return {\n    ok: false,\n    message: 'Auto discover failed',\n    cause: 'unreachable?',\n  }\n}\n\nasync function getDefaultOrgFromToken(): Promise<\n  string[] | string | undefined\n> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return undefined\n  }\n  const sockSdk = sockSdkResult.data\n\n  const result = await handleApiCall(\n    sockSdk.getOrganizations(),\n    'list of organizations',\n  )\n\n  if (result.ok) {\n    const arr = Array.from(Object.values(result.data.organizations)).map(\n      ({ slug }) => slug,\n    )\n    if (arr.length === 0) {\n      return undefined\n    }\n    if (arr.length === 1) {\n      return arr[0]\n    }\n    return arr\n  }\n\n  return undefined\n}\n\nasync function getEnforceableOrgsFromToken(): Promise<string[] | undefined> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return undefined\n  }\n  const sockSdk = sockSdkResult.data\n\n  const result = await handleApiCall(\n    sockSdk.getOrganizations(),\n    'list of organizations',\n  )\n\n  if (result.ok) {\n    const arr = Array.from(Object.values(result.data.organizations)).map(\n      ({ slug }) => slug,\n    )\n    if (arr.length === 0) {\n      return undefined\n    }\n    return arr\n  }\n\n  return undefined\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\nimport { select } from '@socketsecurity/registry/lib/prompts'\n\nimport { isReadOnlyConfig, updateConfigValue } from '../../utils/config.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function outputConfigAuto(\n  key: keyof LocalConfig,\n  result: CResult<unknown>,\n  outputKind: OutputKind,\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log(`# Auto discover config value`)\n    logger.log('')\n    logger.log(\n      `Attempted to automatically discover the value for config key: \"${key}\"`,\n    )\n    logger.log('')\n    if (result.ok) {\n      logger.log(`The discovered value is: \"${result.data}\"`)\n      if (result.message) {\n        logger.log('')\n        logger.log(result.message)\n      }\n    }\n    logger.log('')\n  } else {\n    if (result.message) {\n      logger.log(result.message)\n      logger.log('')\n    }\n    logger.log(`- ${key}: ${result.data}`)\n    logger.log('')\n\n    if (isReadOnlyConfig()) {\n      logger.log(\n        '(Unable to persist this value because the config is in read-only mode, meaning it was overridden through env or flag.)',\n      )\n    } else if (key === 'defaultOrg') {\n      const proceed = await select<string>({\n        message:\n          'Would you like to update the default org in local config to this value?',\n        choices: (Array.isArray(result.data) ? result.data : [result.data])\n          .map(slug => ({\n            name: 'Yes [' + slug + ']',\n            value: slug,\n            description: `Use \"${slug}\" as the default organization`,\n          }))\n          .concat({\n            name: 'No',\n            value: '',\n            description: 'Do not use any of these organizations',\n          }),\n      })\n      if (proceed) {\n        logger.log(`Setting defaultOrg to \"${proceed}\"...`)\n        const updateResult = updateConfigValue('defaultOrg', proceed)\n        if (updateResult.ok) {\n          logger.log(\n            `OK. Updated defaultOrg to \"${proceed}\".\\nYou should no longer need to add the org to commands that normally require it.`,\n          )\n        } else {\n          logger.log(failMsgWithBadge(updateResult.message, updateResult.cause))\n        }\n      } else {\n        logger.log('OK. No changes made.')\n      }\n    } else if (key === 'enforcedOrgs') {\n      const proceed = await select<string>({\n        message:\n          'Would you like to update the enforced orgs in local config to this value?',\n        choices: (Array.isArray(result.data) ? result.data : [result.data])\n          .map(slug => ({\n            name: 'Yes [' + slug + ']',\n            value: slug,\n            description: `Enforce the security policy of \"${slug}\" on this machine`,\n          }))\n          .concat({\n            name: 'No',\n            value: '',\n            description: 'Do not use any of these organizations',\n          }),\n      })\n      if (proceed) {\n        logger.log(`Setting enforcedOrgs key to \"${proceed}\"...`)\n        const updateResult = updateConfigValue('defaultOrg', proceed)\n        if (updateResult.ok) {\n          logger.log(`OK. Updated enforcedOrgs to \"${proceed}\".`)\n        } else {\n          logger.log(failMsgWithBadge(updateResult.message, updateResult.cause))\n        }\n      } else {\n        logger.log('OK. No changes made.')\n      }\n    }\n  }\n}\n","import { discoverConfigValue } from './discover-config-value.mts'\nimport { outputConfigAuto } from './output-config-auto.mts'\n\nimport type { OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function handleConfigAuto({\n  key,\n  outputKind,\n}: {\n  key: keyof LocalConfig\n  outputKind: OutputKind\n}) {\n  const result = await discoverConfigValue(key)\n\n  await outputConfigAuto(key, result, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleConfigAuto } from './handle-config-auto.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { LocalConfig } from '../../utils/config.mts'\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'auto',\n  description: 'Automatically discover and set the correct value config item',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <org slug>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Attempt to automatically discover the correct value for a certain config key.\n\n    For certain keys it will request the value from server, for others it will\n    reset the value to the default. For some keys this has no effect.\n\n    Keys:\n\n${Array.from(supportedConfigKeys.entries())\n  .map(([key, desc]) => `     - ${key} -- ${desc}`)\n  .join('\\n')}\n\n    Examples\n      $ ${command} auto defaultOrg\n  `,\n}\n\nexport const cmdConfigAuto = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [key = ''] = cli.input\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: supportedConfigKeys.has(key as keyof LocalConfig) && key !== 'test',\n      message: 'Config key should be the first arg',\n      pass: 'ok',\n      fail: key ? 'invalid config key' : 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleConfigAuto({\n    key: key as keyof LocalConfig,\n    outputKind,\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { isReadOnlyConfig } from '../../utils/config.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function outputConfigGet(\n  key: keyof LocalConfig,\n  result: CResult<LocalConfig[keyof LocalConfig]>,\n  outputKind: OutputKind,\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const readOnly = isReadOnlyConfig()\n\n  if (outputKind === 'markdown') {\n    logger.log(`# Config Value`)\n    logger.log('')\n    logger.log(`Config key '${key}' has value '${result.data}`)\n    if (readOnly) {\n      logger.log('')\n      logger.log(\n        'Note: the config is in read-only mode, meaning at least one key was temporarily\\n      overridden from an env var or command flag.',\n      )\n    }\n  } else {\n    logger.log(`${key}: ${result.data}`)\n    if (readOnly) {\n      logger.log('')\n      logger.log(\n        'Note: the config is in read-only mode, meaning at least one key was temporarily overridden from an env var or command flag.',\n      )\n    }\n  }\n}\n","import { outputConfigGet } from './output-config-get.mts'\nimport { getConfigValue } from '../../utils/config.mts'\n\nimport type { OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function handleConfigGet({\n  key,\n  outputKind,\n}: {\n  key: keyof LocalConfig\n  outputKind: OutputKind\n}) {\n  const result = getConfigValue(key)\n\n  await outputConfigGet(key, result, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleConfigGet } from './handle-config-get.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { LocalConfig } from '../../utils/config.mts'\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'get',\n  description: 'Get the value of a local CLI config item',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <org slug>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Keys:\n\n${Array.from(supportedConfigKeys.entries())\n  .map(([key, desc]) => `     - ${key} -- ${desc}`)\n  .join('\\n')}\n\n    Examples\n      $ ${command} FakeOrg --repoName=test-repo\n  `,\n}\n\nexport const cmdConfigGet = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [key = ''] = cli.input\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: supportedConfigKeys.has(key as keyof LocalConfig) || key === 'test',\n      message: 'Config key should be the first arg',\n      pass: 'ok',\n      fail: key ? 'invalid config key' : 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleConfigGet({\n    key: key as keyof LocalConfig,\n    outputKind,\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport {\n  getConfigValue,\n  isReadOnlyConfig,\n  sensitiveConfigKeys,\n  supportedConfigKeys,\n} from '../../utils/config.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function outputConfigList({\n  full,\n  outputKind,\n}: {\n  full: boolean\n  outputKind: OutputKind\n}) {\n  const readOnly = isReadOnlyConfig()\n  if (outputKind === 'json') {\n    let failed = false\n    const obj: Record<string, unknown> = {}\n    for (const key of supportedConfigKeys.keys()) {\n      const result = getConfigValue(key)\n      let value = result.data\n      if (!result.ok) {\n        value = `Failed to retrieve: ${result.message}`\n        failed = true\n      } else if (!full && sensitiveConfigKeys.has(key)) {\n        value = '********'\n      }\n      if (full || value !== undefined) {\n        obj[key as any] = value ?? '<none>'\n      }\n    }\n    if (failed) {\n      process.exitCode = 1\n    }\n    logger.log(\n      serializeResultJson(\n        failed\n          ? {\n              ok: false,\n              message: 'At least one config key failed to be fetched...',\n              data: JSON.stringify({\n                full,\n                config: obj,\n                readOnly,\n              }),\n            }\n          : {\n              ok: true,\n              data: {\n                full,\n                config: obj,\n                readOnly,\n              },\n            },\n      ),\n    )\n  } else {\n    const maxWidth = Array.from(supportedConfigKeys.keys()).reduce(\n      (a, b) => Math.max(a, b.length),\n      0,\n    )\n\n    logger.log('# Local CLI Config')\n    logger.log('')\n    logger.log(`This is the local CLI config (full=${!!full}):`)\n    logger.log('')\n    for (const key of supportedConfigKeys.keys()) {\n      const result = getConfigValue(key)\n      if (!result.ok) {\n        logger.log(`- ${key}: failed to read: ${result.message}`)\n      } else {\n        let value = result.data\n        if (!full && sensitiveConfigKeys.has(key)) {\n          value = '********'\n        }\n        if (full || value !== undefined) {\n          logger.log(\n            `- ${key}:${' '.repeat(Math.max(0, maxWidth - key.length + 3))} ${Array.isArray(value) ? value.join(', ') || '<none>' : (value ?? '<none>')}`,\n          )\n        }\n      }\n    }\n    if (readOnly) {\n      logger.log('')\n      logger.log(\n        'Note: the config is in read-only mode, meaning at least one key was temporarily\\n      overridden from an env var or command flag.',\n      )\n    }\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { outputConfigList } from './output-config-list.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'list',\n  description: 'Show all local CLI config items and their values',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    full: {\n      type: 'boolean',\n      default: false,\n      description: 'Show full tokens in plaintext (unsafe)',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <org slug>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Keys:\n\n${Array.from(supportedConfigKeys.entries())\n  .map(([key, desc]) => `     - ${key} -- ${desc}`)\n  .join('\\n')}\n\n    Examples\n      $ ${command} FakeOrg --repoName=test-repo\n  `,\n}\n\nexport const cmdConfigList = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { full, json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const wasValidInput = checkCommandInput(outputKind, {\n    nook: true,\n    test: !json || !markdown,\n    message:\n      'The `--json` and `--markdown` flags can not be used at the same time',\n    pass: 'ok',\n    fail: 'bad',\n  })\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await outputConfigList({\n    full: !!full,\n    outputKind,\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\n\nexport async function outputConfigSet(\n  result: CResult<undefined | string>,\n  outputKind: OutputKind,\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log(`# Update config`)\n    logger.log('')\n    logger.log(result.message)\n    if (result.data) {\n      logger.log('')\n      logger.log(result.data)\n    }\n  } else {\n    logger.log(`OK`)\n    logger.log(result.message)\n    if (result.data) {\n      logger.log('')\n      logger.log(result.data)\n    }\n  }\n}\n","import { outputConfigSet } from './output-config-set.mts'\nimport { updateConfigValue } from '../../utils/config.mts'\n\nimport type { OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function handleConfigSet({\n  key,\n  outputKind,\n  value,\n}: {\n  key: keyof LocalConfig\n  outputKind: OutputKind\n  value: string\n}) {\n  const result = updateConfigValue(key, value)\n\n  await outputConfigSet(result, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleConfigSet } from './handle-config-set.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { LocalConfig } from '../../utils/config.mts'\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'set',\n  description: 'Update the value of a local CLI config item',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <key> <value>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    This is a crude way of updating the local configuration for this CLI tool.\n\n    Note that updating a value here is nothing more than updating a key/value\n    store entry. No validation is happening. The server may reject your config.\n\n    Keys:\n\n${Array.from(supportedConfigKeys.entries())\n  .map(([key, desc]) => `     - ${key} -- ${desc}`)\n  .join('\\n')}\n\n    Examples\n      $ ${command} apiProxy https://example.com\n  `,\n}\n\nexport const cmdConfigSet = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [key = '', ...rest] = cli.input\n  const value = rest.join(' ')\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: key === 'test' || supportedConfigKeys.has(key as keyof LocalConfig),\n      message: 'Config key should be the first arg',\n      pass: 'ok',\n      fail: key ? 'invalid config key' : 'missing',\n    },\n    {\n      test: !!value, // This is a string, empty string is not ok\n      message:\n        'Key value should be the remaining args (use `unset` to unset a value)',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleConfigSet({\n    key: key as keyof LocalConfig,\n    outputKind,\n    value,\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\n\nexport async function outputConfigUnset(\n  updateResult: CResult<undefined | string>,\n  outputKind: OutputKind,\n) {\n  if (!updateResult.ok) {\n    process.exitCode = updateResult.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(updateResult))\n    return\n  }\n  if (!updateResult.ok) {\n    logger.fail(failMsgWithBadge(updateResult.message, updateResult.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log(`# Update config`)\n    logger.log('')\n    logger.log(updateResult.message)\n    if (updateResult.data) {\n      logger.log('')\n      logger.log(updateResult.data)\n    }\n  } else {\n    logger.log(`OK`)\n    logger.log(updateResult.message)\n    if (updateResult.data) {\n      logger.log('')\n      logger.log(updateResult.data)\n    }\n  }\n}\n","import { outputConfigUnset } from './output-config-unset.mts'\nimport { updateConfigValue } from '../../utils/config.mts'\n\nimport type { OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function handleConfigUnset({\n  key,\n  outputKind,\n}: {\n  key: keyof LocalConfig\n  outputKind: OutputKind\n}) {\n  const updateResult = updateConfigValue(key, undefined)\n\n  await outputConfigUnset(updateResult, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleConfigUnset } from './handle-config-unset.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { LocalConfig } from '../../utils/config.mts'\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'unset',\n  description: 'Clear the value of a local CLI config item',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <org slug>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Keys:\n\n${Array.from(supportedConfigKeys.entries())\n  .map(([key, desc]) => `     - ${key} -- ${desc}`)\n  .join('\\n')}\n\n    Examples\n      $ ${command} FakeOrg --repoName=test-repo\n  `,\n}\n\nexport const cmdConfigUnset = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [key = ''] = cli.input\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: key === 'test' || supportedConfigKeys.has(key as keyof LocalConfig),\n      message: 'Config key should be the first arg',\n      pass: 'ok',\n      fail: key ? 'invalid config key' : 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleConfigUnset({\n    key: key as keyof LocalConfig,\n    outputKind,\n  })\n}\n","import { cmdConfigAuto } from './cmd-config-auto.mts'\nimport { cmdConfigGet } from './cmd-config-get.mts'\nimport { cmdConfigList } from './cmd-config-list.mts'\nimport { cmdConfigSet } from './cmd-config-set.mts'\nimport { cmdConfigUnset } from './cmd-config-unset.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Commands related to the local CLI configuration'\n\nexport const cmdConfig: CliSubcommand = {\n  description,\n  hidden: true, // [beta]; isTestingV1\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        auto: cmdConfigAuto,\n        get: cmdConfigGet,\n        list: cmdConfigList,\n        set: cmdConfigSet,\n        unset: cmdConfigUnset,\n      },\n      {\n        argv,\n        description,\n        importMeta,\n        name: `${parentName} config`,\n      },\n    )\n  },\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchDependencies({\n  limit,\n  offset,\n}: {\n  limit: number\n  offset: number\n}): Promise<CResult<SocketSdkReturnType<'searchDependencies'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.searchDependencies({ limit, offset }),\n    'organization dependencies',\n  )\n}\n","// @ts-ignore\nimport chalkTable from 'chalk-table'\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputDependencies(\n  result: CResult<SocketSdkReturnType<'searchDependencies'>['data']>,\n  {\n    limit,\n    offset,\n    outputKind,\n  }: {\n    limit: number\n    offset: number\n    outputKind: OutputKind\n  },\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.log(\n    'Request details: Offset:',\n    offset,\n    ', limit:',\n    limit,\n    ', is there more data after this?',\n    result.data.end ? 'no' : 'yes',\n  )\n\n  const options = {\n    columns: [\n      { field: 'namespace', name: colors.cyan('Namespace') },\n      { field: 'name', name: colors.cyan('Name') },\n      { field: 'version', name: colors.cyan('Version') },\n      { field: 'repository', name: colors.cyan('Repository') },\n      { field: 'branch', name: colors.cyan('Branch') },\n      { field: 'type', name: colors.cyan('Type') },\n      { field: 'direct', name: colors.cyan('Direct') },\n    ],\n  }\n\n  logger.log(chalkTable(options, result.data.rows))\n}\n","import { fetchDependencies } from './fetch-dependencies.mts'\nimport { outputDependencies } from './output-dependencies.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleDependencies({\n  limit,\n  offset,\n  outputKind,\n}: {\n  limit: number\n  offset: number\n  outputKind: OutputKind\n}): Promise<void> {\n  const result = await fetchDependencies({ limit, offset })\n\n  await outputDependencies(result, { limit, offset, outputKind })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleDependencies } from './handle-dependencies.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'dependencies',\n  description:\n    'Search for any dependency that is being used in your organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    limit: {\n      type: 'number',\n      shortFlag: 'l',\n      default: 50,\n      description: 'Maximum number of dependencies returned',\n    },\n    offset: {\n      type: 'number',\n      shortFlag: 'o',\n      default: 0,\n      description: 'Page number',\n    },\n    ...outputFlags,\n  },\n  help: (command, config) => `\n    Usage\n      ${command}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: none (does need token with access to target org)\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      ${command} --limit 20 --offset 10\n  `,\n}\n\nexport const cmdScanCreate = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json, limit, markdown, offset } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleDependencies({\n    limit: Number(limit || 0) || 0,\n    offset: Number(offset || 0) || 0,\n    outputKind,\n  })\n}\n","import { queryApiSafeJson } from '../../utils/api.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchDiffScan({\n  after,\n  before,\n  orgSlug,\n}: {\n  after: string\n  before: string\n  orgSlug: string\n}): Promise<CResult<SocketSdkReturnType<'GetOrgDiffScan'>['data']>> {\n  return await queryApiSafeJson<SocketSdkReturnType<'GetOrgDiffScan'>['data']>(\n    `orgs/${orgSlug}/full-scans/diff?before=${encodeURIComponent(before)}&after=${encodeURIComponent(after)}`,\n    'a scan diff',\n  )\n}\n","import fs from 'node:fs'\nimport util from 'node:util'\n\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputDiffScan(\n  result: CResult<SocketSdkReturnType<'GetOrgDiffScan'>['data']>,\n  {\n    depth,\n    file,\n    outputKind,\n  }: {\n    depth: number\n    file: string\n    outputKind: OutputKind\n  },\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const dashboardUrl = result.data.diff_report_url\n  const dashboardMessage = dashboardUrl\n    ? `\\n View this diff scan in the Socket dashboard: ${colors.cyan(dashboardUrl)}`\n    : ''\n\n  // When forcing json, or dumping to file, serialize to string such that it\n  // won't get truncated. The only way to dump the full raw JSON to stdout is\n  // to use `--json --file -` (the dash is a standard notation for stdout)\n  if (outputKind === 'json' || file) {\n    const json = serializeResultJson(result)\n\n    if (file && file !== '-') {\n      logger.info(`Writing json to \\`${file}\\``)\n      fs.writeFile(file, JSON.stringify(result, null, 2), err => {\n        if (err) {\n          logger.fail(`Writing to \\`${file}\\` failed...`)\n          logger.error(err)\n        } else {\n          logger.success(`Data successfully written to \\`${file}\\``)\n        }\n        logger.info(dashboardMessage)\n      })\n    } else {\n      // Note: only the .log will go to stdout\n      logger.success(`\\n Diff scan result: \\n`)\n      logger.log(json)\n      logger.info(dashboardMessage)\n    }\n\n    return\n  }\n\n  // In this case neither the --json nor the --file flag was passed\n  // Dump the JSON to CLI and let NodeJS deal with truncation\n\n  logger.success('Diff scan result:')\n  logger.log(\n    util.inspect(result, {\n      showHidden: false,\n      depth: depth > 0 ? depth : null,\n      colors: true,\n      maxArrayLength: null,\n    }),\n  )\n  logger.info(\n    `\\n 📝 To display the detailed report in the terminal, use the --json flag \\n`,\n  )\n  logger.log(dashboardMessage)\n}\n","import { fetchDiffScan } from './fetch-diff-scan.mts'\nimport { outputDiffScan } from './output-diff-scan.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleDiffScan({\n  after,\n  before,\n  depth,\n  file,\n  orgSlug,\n  outputKind,\n}: {\n  after: string\n  before: string\n  depth: number\n  file: string\n  orgSlug: string\n  outputKind: OutputKind\n}): Promise<void> {\n  const data = await fetchDiffScan({\n    after,\n    before,\n    orgSlug,\n  })\n\n  await outputDiffScan(data, {\n    depth,\n    file,\n    outputKind,\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleDiffScan } from './handle-diff-scan.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getConfigValueOrUndef, isTestingV1 } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'get',\n  description: 'Get a diff scan for an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    after: {\n      type: 'string',\n      shortFlag: 'a',\n      default: '',\n      description: 'The scan ID of the head scan',\n    },\n    before: {\n      type: 'string',\n      shortFlag: 'b',\n      default: '',\n      description: 'The scan ID of the base scan',\n    },\n    depth: {\n      type: 'number',\n      default: 2,\n      description:\n        'Max depth of JSON to display before truncating, use zero for no limit (without --json/--file)',\n    },\n    json: {\n      type: 'boolean',\n      shortFlag: 'j',\n      default: false,\n      description:\n        'Output result as json. This can be big. Use --file to store it to disk without truncation.',\n    },\n    file: {\n      type: 'string',\n      shortFlag: 'f',\n      default: '',\n      description:\n        'Path to a local file where the output should be saved. Use `-` to force stdout.',\n    },\n  },\n  help: (command, config) =>\n    isTestingV1()\n      ? 'This command will be removed in v1'\n      : `\n    Note: This command is deprecated, to be dropped in the next major bump.\n          Please see \\`socket scan diff\\`\n\n    Usage\n      $ ${command} <org slug> --before=<before> --after=<after>\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:list\n\n    This command displays the package changes between two scans. The full output\n    can be pretty large depending on the size of your repo and time range. It is\n    best stored to disk to be further analyzed by other tools.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} FakeCorp --before=aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 --after=aaa1aa1a-aaaa-1111-1a1a-1111111a11a1\n  `,\n}\n\nexport const cmdDiffScanGet = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { after, before, depth, file, json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const defaultOrgSlugResult = getConfigValueOrUndef('defaultOrg')\n  const orgSlug = defaultOrgSlugResult || cli.input[0] || ''\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!(before && after),\n      message:\n        'Specify a before and after scan ID.\\nThe args are expecting a full `aaa0aa0a-aaaa-0000-0a0a-0000000a00a0` scan ID.',\n      pass: 'ok',\n      fail:\n        !before && !after\n          ? 'missing before and after'\n          : !before\n            ? 'missing before'\n            : 'missing after',\n    },\n    {\n      test: !!orgSlug,\n      nook: true,\n      message: 'Org name as the first argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  logger.fail(\n    'Warning: this command is deprecated in favor of `socket scan diff` and will be removed in the next major bump.',\n  )\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleDiffScan({\n    before: String(before || ''),\n    after: String(after || ''),\n    depth: Number(depth),\n    orgSlug,\n    outputKind,\n    file: String(file || ''),\n  })\n}\n","import { cmdDiffScanGet } from './cmd-diff-scan-get.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Diff scans related commands'\n\nexport const cmdDiffScan: CliSubcommand = {\n  description,\n  // Hidden because it was broken all this time (nobody could be using it)\n  // and we're not sure if it's useful to anyone in its current state.\n  // Until we do, we'll hide this to keep the help tidier.\n  // And later, we may simply move this under `scan`, anyways.\n  hidden: true,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        get: cmdDiffScanGet,\n      },\n      {\n        argv,\n        description,\n        importMeta,\n        name: parentName + ' diff-scan',\n      },\n    )\n  },\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\n\nexport async function outputFixResult(\n  result: CResult<unknown>,\n  outputKind: OutputKind,\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.log('')\n  logger.success('Finished!')\n}\n","import semver from 'semver'\n\nimport { PackageURL } from '@socketregistry/packageurl-js'\nimport { debugFn } from '@socketsecurity/registry/lib/debug'\nimport { normalizePath } from '@socketsecurity/registry/lib/path'\nimport { escapeRegExp } from '@socketsecurity/registry/lib/regexps'\nimport { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\nimport { getPurlObject } from '../../utils/purl.mts'\nimport {\n  getPkgFullNameFromPurl,\n  getSocketDevPackageOverviewUrlFromPurl,\n} from '../../utils/socket-url.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketArtifact } from '../../utils/alert/artifact.mts'\nimport type { SpawnOptions } from '@socketsecurity/registry/lib/spawn'\n\nexport type GitCreateAndPushBranchOptions = {\n  cwd?: string | undefined\n  email?: string | undefined\n  user?: string | undefined\n}\n\nfunction formatBranchName(name: string): string {\n  return name.replace(/[^-a-zA-Z0-9/._-]+/g, '+')\n}\n\nexport function getBaseGitBranch(): string {\n  // Lazily access constants.ENV.GITHUB_REF_NAME.\n  return (\n    constants.ENV.GITHUB_REF_NAME ||\n    // GitHub defaults to branch name \"main\"\n    // https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-branches#about-the-default-branch\n    'main'\n  )\n}\n\nexport function getSocketBranchPurlTypeComponent(\n  purl: string | PackageURL | SocketArtifact,\n): string {\n  const purlObj = getPurlObject(purl)\n  return formatBranchName(purlObj.type)\n}\n\nexport function getSocketBranchFullNameComponent(\n  pkgName: string | PackageURL | SocketArtifact,\n): string {\n  const purlObj = getPurlObject(\n    typeof pkgName === 'string' && !pkgName.startsWith('pkg:')\n      ? PackageURL.fromString(`pkg:unknown/${pkgName}`)\n      : pkgName,\n  )\n  const fmtMaybeNamespace = purlObj.namespace\n    ? `${formatBranchName(purlObj.namespace)}--`\n    : ''\n  return `${fmtMaybeNamespace}${formatBranchName(purlObj.name)}`\n}\n\nexport function getSocketBranchPackageVersionComponent(\n  version: string | PackageURL | SocketArtifact,\n): string {\n  const purlObj = getPurlObject(\n    typeof version === 'string' && !version.startsWith('pkg:')\n      ? PackageURL.fromString(`pkg:unknown/unknown@${version}`)\n      : version,\n  )\n  return formatBranchName(purlObj.version!)\n}\n\nexport function getSocketBranchWorkspaceComponent(\n  workspace: string | undefined,\n): string {\n  return workspace ? formatBranchName(workspace) : 'root'\n}\n\nexport function getSocketBranchName(\n  purl: string | PackageURL | SocketArtifact,\n  newVersion: string,\n  workspace?: string | undefined,\n): string {\n  const purlObj = getPurlObject(purl)\n  const fmtType = getSocketBranchPurlTypeComponent(purlObj)\n  const fmtWorkspace = getSocketBranchWorkspaceComponent(workspace)\n  const fmtFullName = getSocketBranchFullNameComponent(purlObj)\n  const fmtVersion = getSocketBranchPackageVersionComponent(purlObj.version!)\n  const fmtNewVersion = formatBranchName(newVersion)\n  return `socket/${fmtType}/${fmtWorkspace}/${fmtFullName}_${fmtVersion}_${fmtNewVersion}`\n}\n\nexport type SocketBranchPatternOptions = {\n  newVersion?: string | undefined\n  purl?: string | undefined\n  workspace?: string | undefined\n}\n\nexport function getSocketBranchPattern(\n  options?: SocketBranchPatternOptions | undefined,\n): RegExp {\n  const { newVersion, purl, workspace } = {\n    __proto__: null,\n    ...options,\n  } as SocketBranchPatternOptions\n  const purlObj = purl ? getPurlObject(purl) : null\n  const escType = purlObj ? escapeRegExp(purlObj.type) : '[^/]+'\n  const escWorkspace = workspace\n    ? `${escapeRegExp(formatBranchName(workspace))}`\n    : '.+'\n  const escMaybeNamespace = purlObj?.namespace\n    ? `${escapeRegExp(formatBranchName(purlObj.namespace))}--`\n    : ''\n  const escFullName = purlObj\n    ? `${escMaybeNamespace}${escapeRegExp(formatBranchName(purlObj.name))}`\n    : '[^/_]+'\n  const escVersion = purlObj\n    ? escapeRegExp(formatBranchName(purlObj.version!))\n    : '[^_]+'\n  const escNewVersion = newVersion\n    ? escapeRegExp(formatBranchName(newVersion))\n    : '[^_]+'\n  return new RegExp(\n    `^socket/(${escType})/(${escWorkspace})/(${escFullName})_(${escVersion})_(${escNewVersion})$`,\n  )\n}\n\nexport type SocketBranchParser = (\n  branch: string,\n) => SocketBranchParseResult | null\n\nexport type SocketBranchParseResult = {\n  fullName: string\n  newVersion: string\n  type: string\n  workspace: string\n  version: string\n}\n\nexport function createSocketBranchParser(\n  options?: SocketBranchPatternOptions | undefined,\n): SocketBranchParser {\n  const pattern = getSocketBranchPattern(options)\n  return function parse(branch: string): SocketBranchParseResult | null {\n    const match = pattern.exec(branch) as\n      | [string, string, string, string, string, string]\n      | null\n    if (!match) {\n      return null\n    }\n    const {\n      1: type,\n      2: workspace,\n      3: fullName,\n      4: version,\n      5: newVersion,\n    } = match\n    return {\n      fullName,\n      newVersion: semver.coerce(newVersion.replaceAll('+', '.'))?.version,\n      type,\n      workspace,\n      version: semver.coerce(version.replaceAll('+', '.'))?.version,\n    } as SocketBranchParseResult\n  }\n}\n\nexport function getSocketPullRequestTitle(\n  purl: string | PackageURL | SocketArtifact,\n  newVersion: string,\n  workspace?: string | undefined,\n): string {\n  const purlObj = getPurlObject(purl)\n  const fullName = getPkgFullNameFromPurl(purlObj)\n  return `Bump ${fullName} from ${purlObj.version} to ${newVersion}${workspace ? ` in ${workspace}` : ''}`\n}\n\nexport function getSocketPullRequestBody(\n  purl: string | PackageURL | SocketArtifact,\n  newVersion: string,\n  workspace?: string | undefined,\n): string {\n  const purlObj = getPurlObject(purl)\n  const fullName = getPkgFullNameFromPurl(purlObj)\n  const pkgOverviewUrl = getSocketDevPackageOverviewUrlFromPurl(purlObj)\n  return `Bump [${fullName}](${pkgOverviewUrl}) from ${purlObj.version} to ${newVersion}${workspace ? ` in ${workspace}` : ''}.`\n}\n\nexport function getSocketCommitMessage(\n  purl: string | PackageURL | SocketArtifact,\n  newVersion: string,\n  workspace?: string | undefined,\n): string {\n  const purlObj = getPurlObject(purl)\n  const fullName = getPkgFullNameFromPurl(purlObj)\n  return `socket: Bump ${fullName} from ${purlObj.version} to ${newVersion}${workspace ? ` in ${workspace}` : ''}`\n}\n\nexport async function gitCleanFdx(cwd = process.cwd()): Promise<void> {\n  const stdioIgnoreOptions: SpawnOptions = { cwd, stdio: 'ignore' }\n  // TODO: propagate CResult?\n  await spawn('git', ['clean', '-fdx'], stdioIgnoreOptions)\n}\n\nexport async function gitCreateAndPushBranch(\n  branch: string,\n  commitMsg: string,\n  filepaths: string[],\n  options?: GitCreateAndPushBranchOptions | undefined,\n): Promise<boolean> {\n  const {\n    cwd = process.cwd(),\n    // Lazily access constants.ENV.SOCKET_CLI_GIT_USER_EMAIL.\n    email = constants.ENV.SOCKET_CLI_GIT_USER_EMAIL,\n    // Lazily access constants.ENV.SOCKET_CLI_GIT_USER_NAME.\n    user = constants.ENV.SOCKET_CLI_GIT_USER_NAME,\n  } = { __proto__: null, ...options } as GitCreateAndPushBranchOptions\n  const stdioIgnoreOptions: SpawnOptions = { cwd, stdio: 'ignore' }\n  try {\n    await gitEnsureIdentity(user, email, cwd)\n    await spawn('git', ['checkout', '-b', branch], stdioIgnoreOptions)\n    await spawn('git', ['add', ...filepaths], stdioIgnoreOptions)\n    await spawn('git', ['commit', '-m', commitMsg], stdioIgnoreOptions)\n    await spawn(\n      'git',\n      ['push', '--force', '--set-upstream', 'origin', branch],\n      stdioIgnoreOptions,\n    )\n    return true\n  } catch (e) {\n    debugFn('catch: unexpected\\n', e)\n  }\n  try {\n    // Will throw with exit code 1 if branch does not exist.\n    await spawn('git', ['branch', '-D', branch], stdioIgnoreOptions)\n  } catch {}\n  return false\n}\n\nexport async function gitEnsureIdentity(\n  name: string,\n  email: string,\n  cwd = process.cwd(),\n): Promise<void> {\n  const stdioIgnoreOptions: SpawnOptions = { cwd, stdio: 'ignore' }\n  const stdioPipeOptions: SpawnOptions = { cwd }\n  const identEntries: Array<[string, string]> = [\n    ['user.email', name],\n    ['user.name', email],\n  ]\n  await Promise.all(\n    identEntries.map(async ({ 0: prop, 1: value }) => {\n      let configValue\n      try {\n        // Will throw with exit code 1 if the config property is not set.\n        configValue = (\n          await spawn('git', ['config', '--get', prop], stdioPipeOptions)\n        ).stdout.trim()\n      } catch {}\n      if (configValue !== value) {\n        try {\n          await spawn('git', ['config', prop, value], stdioIgnoreOptions)\n        } catch (e) {\n          debugFn('catch: unexpected\\n', e)\n        }\n      }\n    }),\n  )\n}\n\nexport async function gitRemoteBranchExists(\n  branch: string,\n  cwd = process.cwd(),\n): Promise<boolean> {\n  const stdioPipeOptions: SpawnOptions = { cwd }\n  try {\n    return (\n      (\n        await spawn(\n          'git',\n          ['ls-remote', '--heads', 'origin', branch],\n          stdioPipeOptions,\n        )\n      ).stdout.trim().length > 0\n    )\n  } catch {\n    return false\n  }\n}\n\nexport async function gitResetAndClean(\n  branch = 'HEAD',\n  cwd = process.cwd(),\n): Promise<void> {\n  // Discards tracked changes.\n  await gitResetHard(branch, cwd)\n  // Deletes all untracked files and directories.\n  await gitCleanFdx(cwd)\n}\n\nexport async function gitResetHard(\n  branch = 'HEAD',\n  cwd = process.cwd(),\n): Promise<void> {\n  const stdioIgnoreOptions: SpawnOptions = { cwd, stdio: 'ignore' }\n  await spawn('git', ['reset', '--hard', branch], stdioIgnoreOptions)\n}\n\nexport async function gitUnstagedModifiedFiles(\n  cwd = process.cwd(),\n): Promise<CResult<string[]>> {\n  try {\n    const stdioPipeOptions: SpawnOptions = { cwd }\n    const stdout = (\n      await spawn('git', ['diff', '--name-only'], stdioPipeOptions)\n    ).stdout.trim()\n    const rawFiles = stdout.split('\\n') ?? []\n    return { ok: true, data: rawFiles.map(relPath => normalizePath(relPath)) }\n  } catch (e) {\n    debugFn('catch: git diff --name-only failed\\n', e)\n\n    return {\n      ok: false,\n      message: 'Git Error',\n      cause: 'Unexpected error while trying to ask git whether repo is dirty',\n    }\n  }\n}\n","import { existsSync, promises as fs, statSync } from 'node:fs'\nimport path from 'node:path'\n\nimport {\n  GraphqlResponseError,\n  graphql as OctokitGraphql,\n} from '@octokit/graphql'\nimport { RequestError } from '@octokit/request-error'\nimport { Octokit } from '@octokit/rest'\nimport semver from 'semver'\n\nimport { PackageURL } from '@socketregistry/packageurl-js'\nimport { debugFn } from '@socketsecurity/registry/lib/debug'\nimport { readJson, writeJson } from '@socketsecurity/registry/lib/fs'\nimport { spawn } from '@socketsecurity/registry/lib/spawn'\nimport { isNonEmptyString } from '@socketsecurity/registry/lib/strings'\n\nimport {\n  createSocketBranchParser,\n  getSocketBranchPattern,\n  getSocketPullRequestBody,\n  getSocketPullRequestTitle,\n} from './git.mts'\nimport constants from '../../constants.mts'\nimport { getPurlObject } from '../../utils/purl.mts'\n\nimport type { SocketArtifact } from '../../utils/alert/artifact.mts'\nimport type { components } from '@octokit/openapi-types'\nimport type { OctokitResponse } from '@octokit/types'\nimport type { JsonContent } from '@socketsecurity/registry/lib/fs'\nimport type { SpawnOptions } from '@socketsecurity/registry/lib/spawn'\n\nlet _octokit: Octokit | undefined\nfunction getOctokit() {\n  if (_octokit === undefined) {\n    // Lazily access constants.ENV.SOCKET_CLI_GITHUB_TOKEN.\n    const { SOCKET_CLI_GITHUB_TOKEN } = constants.ENV\n    if (!SOCKET_CLI_GITHUB_TOKEN) {\n      debugFn('miss: SOCKET_CLI_GITHUB_TOKEN env var')\n    }\n    _octokit = new Octokit({\n      auth: SOCKET_CLI_GITHUB_TOKEN,\n    })\n  }\n  return _octokit\n}\n\nlet _octokitGraphql: typeof OctokitGraphql | undefined\nexport function getOctokitGraphql(): typeof OctokitGraphql {\n  if (!_octokitGraphql) {\n    // Lazily access constants.ENV.SOCKET_CLI_GITHUB_TOKEN.\n    const { SOCKET_CLI_GITHUB_TOKEN } = constants.ENV\n    if (!SOCKET_CLI_GITHUB_TOKEN) {\n      debugFn('miss: SOCKET_CLI_GITHUB_TOKEN env var')\n    }\n    _octokitGraphql = OctokitGraphql.defaults({\n      headers: {\n        authorization: `token ${SOCKET_CLI_GITHUB_TOKEN}`,\n      },\n    })\n  }\n  return _octokitGraphql\n}\n\nexport async function cacheFetch<T>(\n  key: string,\n  fetcher: () => Promise<T>,\n  ttlMs?: number | undefined,\n): Promise<T> {\n  // Optionally disable cache.\n  // Lazily access constants.ENV.DISABLE_GITHUB_CACHE.\n  if (constants.ENV.DISABLE_GITHUB_CACHE) {\n    return await fetcher()\n  }\n  let data = (await readCache(key, ttlMs)) as T\n  if (!data) {\n    data = await fetcher()\n    await writeCache(key, data as JsonContent)\n  }\n  return data\n}\n\nasync function readCache(\n  key: string,\n  // 5 minute in milliseconds time to live (TTL).\n  ttlMs = 5 * 60 * 1000,\n): Promise<JsonContent | null> {\n  // Lazily access constants.githubCachePath.\n  const cacheJsonPath = path.join(constants.githubCachePath, `${key}.json`)\n  try {\n    const stat = statSync(cacheJsonPath)\n    const isExpired = Date.now() - stat.mtimeMs > ttlMs\n    if (!isExpired) {\n      return await readJson(cacheJsonPath)\n    }\n  } catch {}\n  return null\n}\n\nasync function writeCache(key: string, data: JsonContent): Promise<void> {\n  // Lazily access constants.githubCachePath.\n  const { githubCachePath } = constants\n  const cacheJsonPath = path.join(githubCachePath, `${key}.json`)\n  if (!existsSync(githubCachePath)) {\n    await fs.mkdir(githubCachePath, { recursive: true })\n  }\n  await writeJson(cacheJsonPath, data as JsonContent)\n}\n\nexport type Pr = components['schemas']['pull-request']\n\nexport type MERGE_STATE_STATUS =\n  | 'BEHIND'\n  | 'BLOCKED'\n  | 'CLEAN'\n  | 'DIRTY'\n  | 'DRAFT'\n  | 'HAS_HOOKS'\n  | 'UNKNOWN'\n  | 'UNSTABLE'\n\nexport type PrMatch = {\n  author: string\n  baseRefName: string\n  headRefName: string\n  mergeStateStatus: MERGE_STATE_STATUS\n  number: number\n  title: string\n}\n\nexport type CleanupPrsOptions = {\n  newVersion?: string | undefined\n  purl?: string | undefined\n  workspace?: string | undefined\n}\n\nexport async function cleanupOpenPrs(\n  owner: string,\n  repo: string,\n  options?: CleanupPrsOptions | undefined,\n): Promise<PrMatch[]> {\n  const contextualMatches = await getOpenSocketPrsWithContext(\n    owner,\n    repo,\n    options,\n  )\n\n  if (!contextualMatches.length) {\n    return []\n  }\n\n  const cachesToSave = new Map<string, JsonContent>()\n  const { newVersion } = { __proto__: null, ...options } as CleanupPrsOptions\n  const branchParser = createSocketBranchParser(options)\n  const octokit = getOctokit()\n\n  const settledMatches = await Promise.allSettled(\n    contextualMatches.map(async ({ context, match }) => {\n      const { number: prNum } = match\n      const prRef = `PR #${prNum}`\n      const parsedBranch = branchParser(match.headRefName)\n      const prToVersion = parsedBranch?.newVersion\n\n      // Close older PRs.\n      if (prToVersion && newVersion && semver.lt(prToVersion, newVersion)) {\n        try {\n          await octokit.pulls.update({\n            owner,\n            repo,\n            pull_number: prNum,\n            state: 'closed',\n          })\n          debugFn(`close: ${prRef} for ${prToVersion}`)\n          // Remove entry from parent object.\n          context.parent.splice(context.index, 1)\n          // Mark cache to be saved.\n          cachesToSave.set(context.cacheKey, context.data)\n          return null\n        } catch (e) {\n          debugFn(\n            `fail: close ${prRef} for ${prToVersion}\\n`,\n            (e as Error)?.message || 'unknown error',\n          )\n        }\n      }\n      // Update stale PRs.\n      // https://docs.github.com/en/graphql/reference/enums#mergestatestatus\n      if (match.mergeStateStatus === 'BEHIND') {\n        try {\n          await octokit.repos.merge({\n            owner,\n            repo,\n            base: match.headRefName,\n            head: match.baseRefName,\n          })\n          debugFn('update: stale', prRef)\n          // Update entry entry.\n          if (context.apiType === 'graphql') {\n            context.entry.mergeStateStatus = 'CLEAN'\n          } else if (context.apiType === 'rest') {\n            context.entry.mergeable_state = 'clean'\n          }\n          // Mark cache to be saved.\n          cachesToSave.set(context.cacheKey, context.data)\n        } catch (e) {\n          const message = (e as Error)?.message || 'Unknown error'\n          debugFn(`fail: update ${prRef} - ${message}`)\n        }\n      }\n      return match\n    }),\n  )\n\n  if (cachesToSave.size) {\n    await Promise.allSettled(\n      [...cachesToSave].map(({ 0: key, 1: data }) => writeCache(key, data)),\n    )\n  }\n\n  const fulfilledMatches = settledMatches.filter(\n    r => r.status === 'fulfilled' && r.value,\n  ) as unknown as Array<PromiseFulfilledResult<ContextualPrMatch>>\n\n  return fulfilledMatches.map(r => r.value.match)\n}\n\nexport type PrAutoMergeState = {\n  enabled: boolean\n  details?: string[]\n}\n\nexport async function enablePrAutoMerge({\n  node_id: prId,\n}: Pr): Promise<PrAutoMergeState> {\n  const octokitGraphql = getOctokitGraphql()\n  let error: unknown\n  try {\n    const response = await octokitGraphql(\n      `\n      mutation EnableAutoMerge($pullRequestId: ID!) {\n        enablePullRequestAutoMerge(input: {\n          pullRequestId: $pullRequestId,\n          mergeMethod: SQUASH\n        }) {\n          pullRequest {\n            number\n          }\n        }\n      }`,\n      { pullRequestId: prId },\n    )\n    const respPrNumber = (response as any)?.enablePullRequestAutoMerge\n      ?.pullRequest?.number\n    if (respPrNumber) {\n      return { enabled: true }\n    }\n  } catch (e) {\n    error = e\n  }\n  if (\n    error instanceof GraphqlResponseError &&\n    Array.isArray(error.errors) &&\n    error.errors.length\n  ) {\n    const details = error.errors.map(({ message }) => message.trim())\n    return { enabled: false, details }\n  }\n  return { enabled: false }\n}\n\nexport type GithubRepoInfo = {\n  owner: string\n  repo: string\n}\n\nexport function getGithubEnvRepoInfo(): GithubRepoInfo | null {\n  // Lazily access constants.ENV.GITHUB_REPOSITORY.\n  const { GITHUB_REPOSITORY } = constants.ENV\n  if (!GITHUB_REPOSITORY) {\n    debugFn('miss: GITHUB_REPOSITORY env var')\n  }\n  const ownerSlashRepo = GITHUB_REPOSITORY\n  const slashIndex = ownerSlashRepo.indexOf('/')\n  if (slashIndex === -1) {\n    return null\n  }\n  return {\n    owner: ownerSlashRepo.slice(0, slashIndex),\n    repo: ownerSlashRepo.slice(slashIndex + 1),\n  }\n}\n\nexport type GetOpenSocketPrsOptions = {\n  author?: string | undefined\n  newVersion?: string | undefined\n  purl?: string | undefined\n  workspace?: string | undefined\n}\n\nexport async function getOpenSocketPrs(\n  owner: string,\n  repo: string,\n  options?: GetOpenSocketPrsOptions | undefined,\n): Promise<PrMatch[]> {\n  return (await getOpenSocketPrsWithContext(owner, repo, options)).map(\n    d => d.match,\n  )\n}\n\ntype ContextualPrMatch = {\n  context: {\n    apiType: 'graphql' | 'rest'\n    cacheKey: string\n    data: any\n    entry: any\n    index: number\n    parent: any[]\n  }\n  match: PrMatch\n}\n\nasync function getOpenSocketPrsWithContext(\n  owner: string,\n  repo: string,\n  options_?: GetOpenSocketPrsOptions | undefined,\n): Promise<ContextualPrMatch[]> {\n  const options = { __proto__: null, ...options_ } as GetOpenSocketPrsOptions\n  const { author } = options\n  const checkAuthor = isNonEmptyString(author)\n  const octokit = getOctokit()\n  const octokitGraphql = getOctokitGraphql()\n  const branchPattern = getSocketBranchPattern(options)\n\n  const contextualMatches: ContextualPrMatch[] = []\n  try {\n    // Optimistically fetch only the first 50 open PRs using GraphQL to minimize\n    // API quota usage. Fallback to REST if no matching PRs are found.\n    const gqlCacheKey = `${repo}-pr-graphql-snapshot`\n    const gqlResp = await cacheFetch(gqlCacheKey, () =>\n      octokitGraphql(\n        `\n          query($owner: String!, $repo: String!) {\n            repository(owner: $owner, name: $repo) {\n              pullRequests(first: 50, states: OPEN, orderBy: {field: CREATED_AT, direction: DESC}) {\n                nodes {\n                  author {\n                    login\n                  }\n                  baseRefName\n                  headRefName\n                  mergeStateStatus\n                  number\n                  title\n                }\n              }\n            }\n          }\n          `,\n        { owner, repo },\n      ),\n    )\n\n    type GqlPrNode = {\n      author?: {\n        login: string\n      }\n      baseRefName: string\n      headRefName: string\n      mergeStateStatus: MERGE_STATE_STATUS\n      number: number\n      title: string\n    }\n    const nodes: GqlPrNode[] =\n      (gqlResp as any)?.repository?.pullRequests?.nodes ?? []\n    for (let i = 0, { length } = nodes; i < length; i += 1) {\n      const node = nodes[i]!\n      const login = node.author?.login\n      const matchesAuthor = checkAuthor ? login === author : true\n      const matchesBranch = branchPattern.test(node.headRefName)\n      if (matchesAuthor && matchesBranch) {\n        contextualMatches.push({\n          context: {\n            apiType: 'graphql',\n            cacheKey: gqlCacheKey,\n            data: gqlResp,\n            entry: node,\n            index: i,\n            parent: nodes,\n          },\n          match: {\n            ...node,\n            author: login ?? '<unknown>',\n          },\n        })\n      }\n    }\n  } catch {}\n\n  if (contextualMatches.length) {\n    return contextualMatches\n  }\n\n  // Fallback to REST if GraphQL found no matching PRs.\n  let allOpenPrs: Pr[] | undefined\n  const cacheKey = `${repo}-open-prs`\n  try {\n    allOpenPrs = await cacheFetch(\n      cacheKey,\n      async () =>\n        (await octokit.paginate(octokit.pulls.list, {\n          owner,\n          repo,\n          state: 'open',\n          per_page: 100,\n        })) as Pr[],\n    )\n  } catch {}\n\n  if (!allOpenPrs) {\n    return contextualMatches\n  }\n\n  for (let i = 0, { length } = allOpenPrs; i < length; i += 1) {\n    const pr = allOpenPrs[i]!\n    const login = pr.user?.login\n    const matchesAuthor = checkAuthor ? login === author : true\n    const matchesBranch = branchPattern.test(pr.head.ref)\n    if (matchesAuthor && matchesBranch) {\n      contextualMatches.push({\n        context: {\n          apiType: 'rest',\n          cacheKey,\n          data: allOpenPrs,\n          entry: pr,\n          index: i,\n          parent: allOpenPrs,\n        },\n        match: {\n          author: login ?? '<unknown>',\n          baseRefName: pr.base.ref,\n          headRefName: pr.head.ref,\n          // Upper cased mergeable_state is equivalent to mergeStateStatus.\n          // https://docs.github.com/en/rest/pulls/pulls?apiVersion=2022-11-28#get-a-pull-request\n          mergeStateStatus: (pr.mergeable_state?.toUpperCase?.() ??\n            'UNKNOWN') as MERGE_STATE_STATUS,\n          number: pr.number,\n          title: pr.title,\n        },\n      })\n    }\n  }\n  return contextualMatches\n}\n\nexport type OpenPrOptions = {\n  baseBranch?: string | undefined\n  cwd?: string | undefined\n  workspace?: string | undefined\n}\n\nexport async function openPr(\n  owner: string,\n  repo: string,\n  branch: string,\n  purl: string | PackageURL | SocketArtifact,\n  newVersion: string,\n  options?: OpenPrOptions | undefined,\n): Promise<OctokitResponse<Pr> | null> {\n  const { baseBranch = 'main', workspace } = {\n    __proto__: null,\n    ...options,\n  } as OpenPrOptions\n  // Lazily access constants.ENV.GITHUB_ACTIONS.\n  if (!constants.ENV.GITHUB_ACTIONS) {\n    debugFn('miss: GITHUB_ACTIONS env var')\n    return null\n  }\n  const purlObj = getPurlObject(purl)\n  const octokit = getOctokit()\n  try {\n    return await octokit.pulls.create({\n      owner,\n      repo,\n      title: getSocketPullRequestTitle(purlObj, newVersion, workspace),\n      head: branch,\n      base: baseBranch,\n      body: getSocketPullRequestBody(purlObj, newVersion, workspace),\n    })\n  } catch (e) {\n    let message = `Failed to open pull request`\n    const errors =\n      e instanceof RequestError\n        ? (e.response?.data as any)?.['errors']\n        : undefined\n    if (Array.isArray(errors) && errors.length) {\n      const details = errors\n        .map(\n          d =>\n            `- ${d.message?.trim() ?? `${d.resource}.${d.field} (${d.code})`}`,\n        )\n        .join('\\n')\n      message += `:\\n${details}`\n    }\n    debugFn(message)\n  }\n  return null\n}\n\nexport async function prExistForBranch(\n  owner: string,\n  repo: string,\n  branch: string,\n): Promise<boolean> {\n  const octokit = getOctokit()\n  try {\n    const { data: prs } = await octokit.pulls.list({\n      owner,\n      repo,\n      head: `${owner}:${branch}`,\n      state: 'open',\n      per_page: 1,\n    })\n    return prs.length > 0\n  } catch {}\n  return false\n}\n\nexport async function setGitRemoteGithubRepoUrl(\n  owner: string,\n  repo: string,\n  token: string,\n  cwd = process.cwd(),\n): Promise<void> {\n  const stdioIgnoreOptions: SpawnOptions = { cwd, stdio: 'ignore' }\n  const url = `https://x-access-token:${token}@github.com/${owner}/${repo}`\n  try {\n    await spawn('git', ['remote', 'set-url', 'origin', url], stdioIgnoreOptions)\n  } catch (e) {\n    debugFn('catch: unexpected\\n', e)\n  }\n}\n","import type { GetAlertsMapFromPurlsOptions } from '../../utils/alerts-map.mts'\nimport type { Remap } from '@socketsecurity/registry/lib/objects'\n\nexport const CMD_NAME = 'socket fix'\n\nexport function getAlertsMapOptions(\n  options: GetAlertsMapFromPurlsOptions = {},\n) {\n  return {\n    __proto__: null,\n    consolidate: true,\n    nothrow: true,\n    ...options,\n    include: {\n      __proto__: null,\n      existing: true,\n      unfixable: false,\n      upgradable: false,\n      ...options?.include,\n    },\n  } as Remap<\n    Omit<GetAlertsMapFromPurlsOptions, 'include' | 'overrides' | 'spinner'> & {\n      include: Exclude<GetAlertsMapFromPurlsOptions['include'], undefined>\n    }\n  >\n}\n","import path from 'node:path'\n\nimport semver from 'semver'\n\nimport { getManifestData } from '@socketsecurity/registry'\nimport { arrayUnique } from '@socketsecurity/registry/lib/arrays'\nimport { debugFn, isDebug } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { runScript } from '@socketsecurity/registry/lib/npm'\nimport {\n  fetchPackagePackument,\n  readPackageJson,\n  resolvePackageName,\n} from '@socketsecurity/registry/lib/packages'\nimport { naturalCompare } from '@socketsecurity/registry/lib/sorts'\n\nimport {\n  createSocketBranchParser,\n  getBaseGitBranch,\n  getSocketBranchFullNameComponent,\n  getSocketBranchName,\n  getSocketBranchPurlTypeComponent,\n  getSocketBranchWorkspaceComponent,\n  getSocketCommitMessage,\n  gitCreateAndPushBranch,\n  gitRemoteBranchExists,\n  gitResetAndClean,\n  gitUnstagedModifiedFiles,\n} from './git.mts'\nimport {\n  cleanupOpenPrs,\n  enablePrAutoMerge,\n  getGithubEnvRepoInfo,\n  getOpenSocketPrs,\n  openPr,\n  prExistForBranch,\n  setGitRemoteGithubRepoUrl,\n} from './open-pr.mts'\nimport { getAlertsMapOptions } from './shared.mts'\nimport constants from '../../constants.mts'\nimport {\n  Arborist,\n  SAFE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n} from '../../shadow/npm/arborist/index.mts'\nimport {\n  findBestPatchVersion,\n  findPackageNode,\n  findPackageNodes,\n  getAlertsMapFromArborist,\n  updateNode,\n  updatePackageJsonFromNode,\n} from '../../shadow/npm/arborist-helpers.mts'\nimport { getAlertsMapFromPurls } from '../../utils/alerts-map.mts'\nimport { removeNodeModules } from '../../utils/fs.mts'\nimport { globWorkspace } from '../../utils/glob.mts'\nimport { getPurlObject } from '../../utils/purl.mts'\nimport { applyRange } from '../../utils/semver.mts'\nimport { getCveInfoFromAlertsMap } from '../../utils/socket-package-alert.mts'\nimport { idToPurl } from '../../utils/spec.mts'\n\nimport type { SocketBranchParseResult } from './git.mts'\nimport type {\n  ArboristInstance,\n  NodeClass,\n} from '../../shadow/npm/arborist/types.mts'\nimport type { CResult } from '../../types.mts'\nimport type { PURL_Type } from '../../utils/alert/artifact.mts'\nimport type { EnvDetails } from '../../utils/package-environment.mts'\nimport type { RangeStyle } from '../../utils/semver.mts'\nimport type { PackageJson } from '@socketsecurity/registry/lib/packages'\n\ntype InstallOptions = {\n  cwd?: string | undefined\n}\n\nasync function install(\n  arb: ArboristInstance,\n  options: InstallOptions,\n): Promise<NodeClass | null> {\n  const { cwd = process.cwd() } = {\n    __proto__: null,\n    ...options,\n  } as InstallOptions\n  try {\n    const newArb = new Arborist({ path: cwd })\n    newArb.idealTree = await arb.buildIdealTree()\n    const actualTree = await newArb.reify()\n    arb.actualTree = actualTree\n    return actualTree\n  } catch {}\n  return null\n}\n\nexport async function npmFix(\n  pkgEnvDetails: EnvDetails,\n  {\n    autoMerge,\n    cwd,\n    limit,\n    purls,\n    rangeStyle,\n    test,\n    testScript,\n  }: {\n    autoMerge: boolean\n    cwd: string\n    limit: number\n    purls: string[]\n    rangeStyle: RangeStyle\n    test: boolean\n    testScript: string\n  },\n): Promise<CResult<{ fixed: boolean }>> {\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n  const { pkgPath: rootPath } = pkgEnvDetails\n\n  // Lazily access constants.ENV properties.\n  const gitEmail = constants.ENV.SOCKET_CLI_GIT_USER_EMAIL\n  const gitUser = constants.ENV.SOCKET_CLI_GIT_USER_NAME\n  const githubToken = constants.ENV.SOCKET_CLI_GITHUB_TOKEN\n\n  const isCi = !!(\n    constants.ENV.CI &&\n    constants.ENV.GITHUB_ACTIONS &&\n    constants.ENV.GITHUB_REPOSITORY &&\n    gitEmail &&\n    gitUser &&\n    githubToken\n  )\n\n  const repoInfo = isCi ? getGithubEnvRepoInfo()! : null\n\n  spinner?.start()\n\n  const openPrs =\n    // Check repoInfo to make TypeScript happy.\n    isCi && repoInfo\n      ? await getOpenSocketPrs(repoInfo.owner, repoInfo.repo, {\n          author: gitUser,\n        })\n      : []\n\n  let count = 0\n\n  const arb = new Arborist({\n    path: rootPath,\n    ...SAFE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n  })\n  // Calling arb.reify() creates the arb.diff object, nulls-out arb.idealTree,\n  // and populates arb.actualTree.\n  let actualTree = await arb.reify()\n\n  let alertsMap\n  try {\n    alertsMap = purls.length\n      ? await getAlertsMapFromPurls(\n          purls,\n          getAlertsMapOptions({ limit: Math.max(limit, openPrs.length) }),\n        )\n      : await getAlertsMapFromArborist(\n          arb,\n          getAlertsMapOptions({ limit: Math.max(limit, openPrs.length) }),\n        )\n  } catch (e) {\n    spinner?.stop()\n    debugFn('catch: PURL API\\n', e)\n    return {\n      ok: false,\n      message: 'API Error',\n      cause: (e as Error)?.message || 'Unknown Socket batch PURL API error.',\n    }\n  }\n\n  const infoByPartialPurl = getCveInfoFromAlertsMap(alertsMap, {\n    limit: Math.max(limit, openPrs.length),\n  })\n  if (!infoByPartialPurl) {\n    spinner?.stop()\n    logger.info('No fixable vulns found.')\n    return { ok: true, data: { fixed: false } }\n  }\n\n  const baseBranch = isCi ? getBaseGitBranch() : ''\n  const branchParser = isCi ? createSocketBranchParser() : null\n  const workspacePkgJsonPaths = await globWorkspace(\n    pkgEnvDetails.agent,\n    rootPath,\n  )\n  const pkgJsonPaths = [\n    ...workspacePkgJsonPaths,\n    // Process the workspace root last since it will add an override to package.json.\n    pkgEnvDetails.editablePkgJson.filename!,\n  ]\n  const sortedInfoEntries = [...infoByPartialPurl.entries()].sort((a, b) =>\n    naturalCompare(a[0], b[0]),\n  )\n\n  const handleInstallFail = (): CResult<{ fixed: boolean }> => {\n    debugFn(`fail: ${pkgEnvDetails.agent} install\\n`)\n    logger.dedent()\n    spinner?.dedent()\n\n    return {\n      ok: false,\n      message: 'Installation failure',\n      cause: `Unexpected condition: ${pkgEnvDetails.agent} install failed.`,\n    }\n  }\n\n  spinner?.stop()\n\n  infoEntriesLoop: for (\n    let i = 0, { length } = sortedInfoEntries;\n    i < length;\n    i += 1\n  ) {\n    const isLastInfoEntry = i === length - 1\n    const infoEntry = sortedInfoEntries[i]!\n    const partialPurlObj = getPurlObject(infoEntry[0])\n    const name = resolvePackageName(partialPurlObj)\n\n    const infos = [...infoEntry[1].values()]\n    if (!infos.length) {\n      continue infoEntriesLoop\n    }\n\n    const activeBranches: SocketBranchParseResult[] = []\n    if (isCi) {\n      const branchFullName = getSocketBranchFullNameComponent(partialPurlObj)\n      const branchPurlType = getSocketBranchPurlTypeComponent(partialPurlObj)\n      for (const pr of openPrs) {\n        const parsedBranch = branchParser!(pr.headRefName)\n        if (\n          branchPurlType === parsedBranch?.type &&\n          branchFullName === parsedBranch?.fullName\n        ) {\n          activeBranches.push(parsedBranch)\n        }\n      }\n      if (activeBranches.length) {\n        debugFn(\n          `found: ${activeBranches.length} active branches\\n`,\n          activeBranches,\n        )\n      } else if (openPrs.length) {\n        debugFn('miss: 0 active branches found')\n      }\n    }\n\n    logger.log(`Processing vulns for ${name}:`)\n    logger.indent()\n    spinner?.indent()\n\n    if (getManifestData(partialPurlObj.type as PURL_Type, name)) {\n      debugFn(`found: Socket Optimize variant for ${name}`)\n    }\n    // eslint-disable-next-line no-await-in-loop\n    const packument = await fetchPackagePackument(name)\n    if (!packument) {\n      logger.warn(`Unexpected condition: No packument found for ${name}.\\n`)\n      logger.dedent()\n      spinner?.dedent()\n      continue infoEntriesLoop\n    }\n\n    const availableVersions = Object.keys(packument.versions)\n    const warningsForAfter = new Set<string>()\n\n    // eslint-disable-next-line no-unused-labels\n    pkgJsonPathsLoop: for (\n      let j = 0, { length: length_j } = pkgJsonPaths;\n      j < length_j;\n      j += 1\n    ) {\n      const isLastPkgJsonPath = j === length_j - 1\n      const pkgJsonPath = pkgJsonPaths[j]!\n      const pkgPath = path.dirname(pkgJsonPath)\n      const isWorkspaceRoot =\n        pkgJsonPath === pkgEnvDetails.editablePkgJson.filename\n      const workspace = isWorkspaceRoot\n        ? 'root'\n        : path.relative(rootPath, pkgPath)\n      const branchWorkspace = isCi\n        ? getSocketBranchWorkspaceComponent(workspace)\n        : ''\n\n      const oldVersions = arrayUnique(\n        findPackageNodes(actualTree, name)\n          .map(n => n.target?.version ?? n.version)\n          .filter(Boolean),\n      )\n\n      if (!oldVersions.length) {\n        debugFn(`skip: ${name} not found\\n`)\n        // Skip to next package.\n        logger.dedent()\n        spinner?.dedent()\n        continue infoEntriesLoop\n      }\n\n      // Always re-read the editable package.json to avoid stale mutations\n      // across iterations.\n      // eslint-disable-next-line no-await-in-loop\n      const editablePkgJson = await readPackageJson(pkgJsonPath, {\n        editable: true,\n      })\n\n      let hasAnnouncedWorkspace = false\n      let workspaceLogCallCount = logger.logCallCount\n      if (isDebug()) {\n        debugFn(`check: workspace ${workspace}`)\n        hasAnnouncedWorkspace = true\n        workspaceLogCallCount = logger.logCallCount\n      }\n\n      oldVersionsLoop: for (const oldVersion of oldVersions) {\n        const oldId = `${name}@${oldVersion}`\n        const oldPurl = idToPurl(oldId, partialPurlObj.type)\n\n        const node = findPackageNode(actualTree, name, oldVersion)\n        if (!node) {\n          debugFn(`skip: ${oldId} not found`)\n          continue oldVersionsLoop\n        }\n\n        infosLoop: for (const {\n          firstPatchedVersionIdentifier,\n          vulnerableVersionRange,\n        } of infos.values()) {\n          if (semver.gte(oldVersion, firstPatchedVersionIdentifier)) {\n            debugFn(`skip: ${oldId} is >= ${firstPatchedVersionIdentifier}`)\n            continue infosLoop\n          }\n          const newVersion = findBestPatchVersion(\n            node,\n            availableVersions,\n            vulnerableVersionRange,\n            firstPatchedVersionIdentifier,\n          )\n\n          if (\n            activeBranches.find(\n              b =>\n                b.workspace === branchWorkspace && b.newVersion === newVersion,\n            )\n          ) {\n            debugFn(`skip: open PR found for ${name}@${newVersion}`)\n            if (++count >= limit) {\n              logger.dedent()\n              spinner?.dedent()\n              break infoEntriesLoop\n            }\n            continue infosLoop\n          }\n\n          const newVersionPackument = newVersion\n            ? packument.versions[newVersion]\n            : undefined\n\n          if (!(newVersion && newVersionPackument)) {\n            warningsForAfter.add(\n              `${oldId} not updated: requires >=${firstPatchedVersionIdentifier}`,\n            )\n            continue infosLoop\n          }\n\n          const newVersionRange = applyRange(oldVersion, newVersion, rangeStyle)\n          const newId = `${name}@${newVersionRange}`\n\n          const revertData = {\n            ...(editablePkgJson.content.dependencies && {\n              dependencies: { ...editablePkgJson.content.dependencies },\n            }),\n            ...(editablePkgJson.content.optionalDependencies && {\n              optionalDependencies: {\n                ...editablePkgJson.content.optionalDependencies,\n              },\n            }),\n            ...(editablePkgJson.content.peerDependencies && {\n              peerDependencies: { ...editablePkgJson.content.peerDependencies },\n            }),\n          } as PackageJson\n\n          updateNode(node, newVersion, newVersionPackument)\n          updatePackageJsonFromNode(\n            editablePkgJson,\n            // eslint-disable-next-line no-await-in-loop\n            await arb.buildIdealTree(),\n            node,\n            newVersion,\n            rangeStyle,\n          )\n          // eslint-disable-next-line no-await-in-loop\n          if (!(await editablePkgJson.save({ ignoreWhitespace: true }))) {\n            debugFn(`skip: ${workspace}/package.json unchanged`)\n            // Reset things just in case.\n            if (isCi) {\n              // eslint-disable-next-line no-await-in-loop\n              await gitResetAndClean(baseBranch, cwd)\n            }\n            continue infosLoop\n          }\n\n          if (!hasAnnouncedWorkspace) {\n            hasAnnouncedWorkspace = true\n            workspaceLogCallCount = logger.logCallCount\n          }\n\n          spinner?.start()\n          spinner?.info(`Installing ${newId} in ${workspace}.`)\n\n          let error\n          let errored = false\n          try {\n            // eslint-disable-next-line no-await-in-loop\n            const maybeActualTree = await install(arb, { cwd })\n            if (maybeActualTree) {\n              actualTree = maybeActualTree\n              if (test) {\n                spinner?.info(`Testing ${newId} in ${workspace}.`)\n                // eslint-disable-next-line no-await-in-loop\n                await runScript(testScript, [], { spinner, stdio: 'ignore' })\n              }\n              spinner?.success(`Fixed ${name} in ${workspace}.`)\n            } else {\n              errored = true\n            }\n          } catch (e) {\n            errored = true\n            error = e\n          }\n\n          spinner?.stop()\n\n          // Check repoInfo to make TypeScript happy.\n          if (!errored && isCi && repoInfo) {\n            try {\n              // eslint-disable-next-line no-await-in-loop\n              const result = await gitUnstagedModifiedFiles(cwd)\n              if (!result.ok) {\n                // Do we fail if this fails? If this git command\n                // fails then probably other git commands do too?\n                logger.warn(\n                  'Unexpected condition: Nothing to commit, skipping PR creation.',\n                )\n                continue infosLoop\n              }\n              const moddedFilepaths = result.data.filter(p => {\n                const basename = path.basename(p)\n                return (\n                  basename === 'package.json' ||\n                  basename === 'package-lock.json'\n                )\n              })\n\n              if (!moddedFilepaths.length) {\n                logger.warn(\n                  'Unexpected condition: Nothing to commit, skipping PR creation.',\n                )\n                continue infosLoop\n              }\n\n              const branch = getSocketBranchName(oldPurl, newVersion, workspace)\n\n              let skipPr = false\n              if (\n                // eslint-disable-next-line no-await-in-loop\n                await prExistForBranch(repoInfo.owner, repoInfo.repo, branch)\n              ) {\n                skipPr = true\n                debugFn(`skip: branch \"${branch}\" exists`)\n              }\n              // eslint-disable-next-line no-await-in-loop\n              else if (await gitRemoteBranchExists(branch, cwd)) {\n                skipPr = true\n                debugFn(`skip: remote branch \"${branch}\" exists`)\n              } else if (\n                // eslint-disable-next-line no-await-in-loop\n                !(await gitCreateAndPushBranch(\n                  branch,\n                  getSocketCommitMessage(oldPurl, newVersion, workspace),\n                  moddedFilepaths,\n                  {\n                    cwd,\n                    email: gitEmail,\n                    user: gitUser,\n                  },\n                ))\n              ) {\n                skipPr = true\n                logger.warn(\n                  'Unexpected condition: Push failed, skipping PR creation.',\n                )\n              }\n              if (skipPr) {\n                // eslint-disable-next-line no-await-in-loop\n                await gitResetAndClean(baseBranch, cwd)\n                // eslint-disable-next-line no-await-in-loop\n                const maybeActualTree = await install(arb, { cwd })\n                if (!maybeActualTree) {\n                  // Exit early if install fails.\n                  return handleInstallFail()\n                }\n                actualTree = maybeActualTree\n                continue infosLoop\n              }\n\n              // eslint-disable-next-line no-await-in-loop\n              await Promise.allSettled([\n                setGitRemoteGithubRepoUrl(\n                  repoInfo.owner,\n                  repoInfo.repo,\n                  githubToken,\n                  cwd,\n                ),\n                cleanupOpenPrs(repoInfo.owner, repoInfo.repo, {\n                  newVersion,\n                  purl: oldPurl,\n                  workspace,\n                }),\n              ])\n              // eslint-disable-next-line no-await-in-loop\n              const prResponse = await openPr(\n                repoInfo.owner,\n                repoInfo.repo,\n                branch,\n                oldPurl,\n                newVersion,\n                {\n                  baseBranch,\n                  cwd,\n                  workspace,\n                },\n              )\n              if (prResponse) {\n                const { data } = prResponse\n                const prRef = `PR #${data.number}`\n                logger.success(`Opened ${prRef}.`)\n                if (autoMerge) {\n                  logger.indent()\n                  spinner?.indent()\n                  // eslint-disable-next-line no-await-in-loop\n                  const { details, enabled } = await enablePrAutoMerge(data)\n                  if (enabled) {\n                    logger.info(`Auto-merge enabled for ${prRef}.`)\n                  } else {\n                    const message = `Failed to enable auto-merge for ${prRef}${\n                      details\n                        ? `:\\n${details.map(d => ` - ${d}`).join('\\n')}`\n                        : '.'\n                    }`\n                    logger.error(message)\n                  }\n                  logger.dedent()\n                  spinner?.dedent()\n                }\n              }\n            } catch (e) {\n              error = e\n              errored = true\n            }\n          }\n\n          if (isCi) {\n            spinner?.start()\n            // eslint-disable-next-line no-await-in-loop\n            await gitResetAndClean(baseBranch, cwd)\n            // eslint-disable-next-line no-await-in-loop\n            const maybeActualTree = await install(arb, { cwd })\n            spinner?.stop()\n            if (maybeActualTree) {\n              actualTree = maybeActualTree\n            } else {\n              errored = true\n            }\n          }\n          if (errored) {\n            if (!isCi) {\n              spinner?.start()\n              editablePkgJson.update(revertData)\n              // eslint-disable-next-line no-await-in-loop\n              await Promise.all([\n                removeNodeModules(cwd),\n                editablePkgJson.save({ ignoreWhitespace: true }),\n              ])\n              // eslint-disable-next-line no-await-in-loop\n              const maybeActualTree = await install(arb, { cwd })\n              spinner?.stop()\n              if (!maybeActualTree) {\n                // Exit early if install fails.\n                return handleInstallFail()\n              }\n              actualTree = maybeActualTree\n            }\n            logger.fail(`Update failed for ${oldId} in ${workspace}.`, error)\n          }\n          if (++count >= limit) {\n            logger.dedent()\n            spinner?.dedent()\n            break infoEntriesLoop\n          }\n        }\n      }\n      if (!isLastPkgJsonPath && logger.logCallCount > workspaceLogCallCount) {\n        logger.logNewline()\n      }\n    }\n\n    for (const warningText of warningsForAfter) {\n      logger.warn(warningText)\n    }\n    if (!isLastInfoEntry) {\n      logger.logNewline()\n    }\n    logger.dedent()\n    spinner?.dedent()\n  }\n\n  spinner?.stop()\n\n  return { ok: true, data: { fixed: true } } // true? did we actually change anything?\n}\n","import { existsSync, promises as fs } from 'node:fs'\nimport path from 'node:path'\n\nimport semver from 'semver'\n\nimport { getManifestData } from '@socketsecurity/registry'\nimport { arrayUnique } from '@socketsecurity/registry/lib/arrays'\nimport { debugFn, isDebug } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { runScript } from '@socketsecurity/registry/lib/npm'\nimport {\n  fetchPackagePackument,\n  readPackageJson,\n  resolvePackageName,\n} from '@socketsecurity/registry/lib/packages'\nimport { naturalCompare } from '@socketsecurity/registry/lib/sorts'\n\nimport {\n  createSocketBranchParser,\n  getBaseGitBranch,\n  getSocketBranchFullNameComponent,\n  getSocketBranchName,\n  getSocketBranchPurlTypeComponent,\n  getSocketBranchWorkspaceComponent,\n  getSocketCommitMessage,\n  gitCreateAndPushBranch,\n  gitRemoteBranchExists,\n  gitResetAndClean,\n  gitUnstagedModifiedFiles,\n} from './git.mts'\nimport {\n  cleanupOpenPrs,\n  enablePrAutoMerge,\n  getGithubEnvRepoInfo,\n  getOpenSocketPrs,\n  openPr,\n  prExistForBranch,\n  setGitRemoteGithubRepoUrl,\n} from './open-pr.mts'\nimport { getAlertsMapOptions } from './shared.mts'\nimport constants from '../../constants.mts'\nimport {\n  Arborist,\n  SAFE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n} from '../../shadow/npm/arborist/index.mts'\nimport {\n  findBestPatchVersion,\n  findPackageNode,\n  findPackageNodes,\n  updatePackageJsonFromNode,\n} from '../../shadow/npm/arborist-helpers.mts'\nimport { runAgentInstall } from '../../utils/agent.mts'\nimport {\n  getAlertsMapFromPnpmLockfile,\n  getAlertsMapFromPurls,\n} from '../../utils/alerts-map.mts'\nimport { removeNodeModules } from '../../utils/fs.mts'\nimport { globWorkspace } from '../../utils/glob.mts'\nimport {\n  extractOverridesFromPnpmLockfileContent,\n  parsePnpmLockfile,\n  parsePnpmLockfileVersion,\n  readPnpmLockfile,\n} from '../../utils/pnpm.mts'\nimport { getPurlObject } from '../../utils/purl.mts'\nimport { applyRange } from '../../utils/semver.mts'\nimport { getCveInfoFromAlertsMap } from '../../utils/socket-package-alert.mts'\nimport { idToPurl } from '../../utils/spec.mts'\n\nimport type { SocketBranchParseResult } from './git.mts'\nimport type { NodeClass } from '../../shadow/npm/arborist/types.mts'\nimport type { CResult, StringKeyValueObject } from '../../types.mts'\nimport type { PURL_Type } from '../../utils/alert/artifact.mts'\nimport type { EnvDetails } from '../../utils/package-environment.mts'\nimport type { RangeStyle } from '../../utils/semver.mts'\nimport type { PackageJson } from '@socketsecurity/registry/lib/packages'\nimport type { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nconst { OVERRIDES, PNPM } = constants\n\ntype InstallOptions = {\n  args?: string[] | undefined\n  cwd?: string | undefined\n  spinner?: Spinner | undefined\n}\n\nasync function getActualTree(cwd: string = process.cwd()): Promise<NodeClass> {\n  // @npmcli/arborist DOES have partial support for pnpm structured node_modules\n  // folders. However, support is iffy resulting in unhappy path errors and hangs.\n  // So, to avoid the unhappy path, we restrict our usage to --dry-run loading\n  // of the node_modules folder.\n  const arb = new Arborist({\n    path: cwd,\n    ...SAFE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n  })\n  return await arb.loadActual()\n}\n\nasync function install(\n  pkgEnvDetails: EnvDetails,\n  options: InstallOptions,\n): Promise<NodeClass | null> {\n  const { args, cwd, spinner } = {\n    __proto__: null,\n    ...options,\n  } as InstallOptions\n  try {\n    await runAgentInstall(pkgEnvDetails, {\n      args: [\n        ...(args ?? []),\n        // Enable pnpm updates to pnpm-lock.yaml in CI environments.\n        // https://pnpm.io/cli/install#--frozen-lockfile\n        '--no-frozen-lockfile',\n        // Enable a non-interactive pnpm install\n        // https://github.com/pnpm/pnpm/issues/6778\n        '--config.confirmModulesPurge=false',\n      ],\n      spinner,\n      stdio: isDebug() ? 'inherit' : 'ignore',\n    })\n    return await getActualTree(cwd)\n  } catch {}\n  return null\n}\n\nexport async function pnpmFix(\n  pkgEnvDetails: EnvDetails,\n  {\n    autoMerge,\n    cwd,\n    limit,\n    purls,\n    rangeStyle,\n    test,\n    testScript,\n  }: {\n    autoMerge: boolean\n    cwd: string\n    limit: number\n    purls: string[]\n    rangeStyle: RangeStyle\n    test: boolean\n    testScript: string\n  },\n): Promise<CResult<{ fixed: boolean }>> {\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n  const { pkgPath: rootPath } = pkgEnvDetails\n\n  // Lazily access constants.ENV properties.\n  const gitEmail = constants.ENV.SOCKET_CLI_GIT_USER_EMAIL\n  const gitUser = constants.ENV.SOCKET_CLI_GIT_USER_NAME\n  const githubToken = constants.ENV.SOCKET_CLI_GITHUB_TOKEN\n\n  const isCi = !!(\n    constants.ENV.CI &&\n    constants.ENV.GITHUB_ACTIONS &&\n    constants.ENV.GITHUB_REPOSITORY &&\n    gitEmail &&\n    gitUser &&\n    githubToken\n  )\n\n  const repoInfo = isCi ? getGithubEnvRepoInfo()! : null\n\n  spinner?.start()\n\n  const openPrs =\n    // Check repoInfo to make TypeScript happy.\n    isCi && repoInfo\n      ? await getOpenSocketPrs(repoInfo.owner, repoInfo.repo, {\n          author: gitUser,\n        })\n      : []\n\n  let count = 0\n\n  let actualTree: NodeClass | undefined\n  const lockfilePath = path.join(rootPath, 'pnpm-lock.yaml')\n  let lockfileContent = await readPnpmLockfile(lockfilePath)\n\n  // If pnpm-lock.yaml does NOT exist then install with pnpm to create it.\n  if (!lockfileContent) {\n    const maybeActualTree = await install(pkgEnvDetails, { cwd, spinner })\n    const maybeLockfileContent = maybeActualTree\n      ? await readPnpmLockfile(lockfilePath)\n      : null\n    if (maybeActualTree) {\n      actualTree = maybeActualTree\n      lockfileContent = maybeLockfileContent\n    }\n  }\n\n  let lockfile = parsePnpmLockfile(lockfileContent)\n  // Update pnpm-lock.yaml if its version is older than what the installed pnpm\n  // produces.\n  if (\n    lockfileContent &&\n    pkgEnvDetails.agentVersion.major >= 10 &&\n    (parsePnpmLockfileVersion(lockfile?.lockfileVersion)?.major ?? 0) <= 6\n  ) {\n    const maybeActualTree = await install(pkgEnvDetails, {\n      args: ['--lockfile-only'],\n      cwd,\n      spinner,\n    })\n    const maybeLockfileContent = maybeActualTree\n      ? await readPnpmLockfile(lockfilePath)\n      : null\n    if (maybeActualTree && maybeLockfileContent) {\n      actualTree = maybeActualTree\n      lockfileContent = maybeLockfileContent\n      lockfile = parsePnpmLockfile(lockfileContent)\n    } else {\n      lockfile = null\n    }\n  }\n\n  // Exit early if pnpm-lock.yaml is not found or usable.\n  // Check !lockfileContent to make TypeScript happy.\n  if (!lockfile || !lockfileContent) {\n    spinner?.stop()\n    return {\n      ok: false,\n      message: 'Missing lockfile',\n      cause: 'Required pnpm-lock.yaml not found or usable',\n    }\n  }\n\n  let alertsMap\n  try {\n    alertsMap = purls.length\n      ? await getAlertsMapFromPurls(\n          purls,\n          getAlertsMapOptions({ limit: Math.max(limit, openPrs.length) }),\n        )\n      : await getAlertsMapFromPnpmLockfile(\n          lockfile,\n          getAlertsMapOptions({ limit: Math.max(limit, openPrs.length) }),\n        )\n  } catch (e) {\n    spinner?.stop()\n    debugFn('catch: PURL API\\n', e)\n    return {\n      ok: false,\n      message: 'API Error',\n      cause: (e as Error)?.message || 'Unknown Socket batch PURL API error.',\n    }\n  }\n\n  const infoByPartialPurl = getCveInfoFromAlertsMap(alertsMap, {\n    limit: Math.max(limit, openPrs.length),\n  })\n  if (!infoByPartialPurl) {\n    spinner?.stop()\n    logger.info('No fixable vulns found.')\n    return { ok: true, data: { fixed: false } }\n  }\n\n  const baseBranch = isCi ? getBaseGitBranch() : ''\n  const branchParser = isCi ? createSocketBranchParser() : null\n  const workspacePkgJsonPaths = await globWorkspace(\n    pkgEnvDetails.agent,\n    rootPath,\n  )\n  const pkgJsonPaths = [\n    ...workspacePkgJsonPaths,\n    // Process the workspace root last since it will add an override to package.json.\n    pkgEnvDetails.editablePkgJson.filename!,\n  ]\n  const sortedInfoEntries = [...infoByPartialPurl.entries()].sort((a, b) =>\n    naturalCompare(a[0], b[0]),\n  )\n\n  const handleInstallFail = (): CResult<{ fixed: boolean }> => {\n    logger.dedent()\n    spinner?.dedent()\n\n    return {\n      ok: false,\n      message: 'Install failed',\n      cause: `Unexpected condition: ${pkgEnvDetails.agent} install failed`,\n    }\n  }\n\n  spinner?.stop()\n\n  infoEntriesLoop: for (\n    let i = 0, { length } = sortedInfoEntries;\n    i < length;\n    i += 1\n  ) {\n    const isLastInfoEntry = i === length - 1\n    const infoEntry = sortedInfoEntries[i]!\n    const partialPurlObj = getPurlObject(infoEntry[0])\n    const name = resolvePackageName(partialPurlObj)\n\n    const infos = [...infoEntry[1].values()]\n    if (!infos.length) {\n      continue infoEntriesLoop\n    }\n\n    const activeBranches: SocketBranchParseResult[] = []\n    if (isCi) {\n      const branchFullName = getSocketBranchFullNameComponent(partialPurlObj)\n      const branchPurlType = getSocketBranchPurlTypeComponent(partialPurlObj)\n      for (const pr of openPrs) {\n        const parsedBranch = branchParser!(pr.headRefName)\n        if (\n          branchPurlType === parsedBranch?.type &&\n          branchFullName === parsedBranch?.fullName\n        ) {\n          activeBranches.push(parsedBranch)\n        }\n      }\n      if (activeBranches.length) {\n        debugFn(\n          `found: ${activeBranches.length} active branches\\n`,\n          activeBranches,\n        )\n      } else if (openPrs.length) {\n        debugFn('miss: 0 active branches found')\n      }\n    }\n\n    logger.log(`Processing vulns for ${name}:`)\n    logger.indent()\n    spinner?.indent()\n\n    if (getManifestData(partialPurlObj.type as PURL_Type, name)) {\n      debugFn(`found: Socket Optimize variant for ${name}`)\n    }\n    // eslint-disable-next-line no-await-in-loop\n    const packument = await fetchPackagePackument(name)\n    if (!packument) {\n      logger.warn(`Unexpected condition: No packument found for ${name}.\\n`)\n      logger.dedent()\n      spinner?.dedent()\n      continue infoEntriesLoop\n    }\n\n    const availableVersions = Object.keys(packument.versions)\n    const warningsForAfter = new Set<string>()\n\n    // eslint-disable-next-line no-unused-labels\n    pkgJsonPathsLoop: for (\n      let j = 0, { length: length_j } = pkgJsonPaths;\n      j < length_j;\n      j += 1\n    ) {\n      const isLastPkgJsonPath = j === length_j - 1\n      const pkgJsonPath = pkgJsonPaths[j]!\n      const pkgPath = path.dirname(pkgJsonPath)\n      const isWorkspaceRoot =\n        pkgJsonPath === pkgEnvDetails.editablePkgJson.filename\n      const workspace = isWorkspaceRoot\n        ? 'root'\n        : path.relative(rootPath, pkgPath)\n      const branchWorkspace = isCi\n        ? getSocketBranchWorkspaceComponent(workspace)\n        : ''\n\n      // actualTree may not be defined on the first iteration of pkgJsonPathsLoop.\n      if (!actualTree) {\n        if (!isCi) {\n          // eslint-disable-next-line no-await-in-loop\n          await removeNodeModules(cwd)\n        }\n        const maybeActualTree =\n          isCi && existsSync(path.join(rootPath, 'node_modules'))\n            ? // eslint-disable-next-line no-await-in-loop\n              await getActualTree(cwd)\n            : // eslint-disable-next-line no-await-in-loop\n              await install(pkgEnvDetails, { cwd, spinner })\n        const maybeLockfileContent = maybeActualTree\n          ? // eslint-disable-next-line no-await-in-loop\n            await readPnpmLockfile(lockfilePath)\n          : null\n        if (maybeActualTree && maybeLockfileContent) {\n          actualTree = maybeActualTree\n          lockfileContent = maybeLockfileContent\n        }\n      }\n      if (!actualTree) {\n        // Exit early if install fails.\n        return handleInstallFail()\n      }\n\n      const oldVersions = arrayUnique(\n        findPackageNodes(actualTree, name)\n          .map(n => n.version)\n          .filter(Boolean),\n      )\n\n      if (!oldVersions.length) {\n        debugFn(`skip: ${name} not found\\n`)\n        // Skip to next package.\n        logger.dedent()\n        spinner?.dedent()\n        continue infoEntriesLoop\n      }\n\n      // Always re-read the editable package.json to avoid stale mutations\n      // across iterations.\n      // eslint-disable-next-line no-await-in-loop\n      const editablePkgJson = await readPackageJson(pkgJsonPath, {\n        editable: true,\n      })\n      // Get current overrides for revert logic.\n      const oldPnpmSection = editablePkgJson.content[PNPM] as\n        | StringKeyValueObject\n        | undefined\n\n      const oldOverrides = oldPnpmSection?.[OVERRIDES] as\n        | Record<string, string>\n        | undefined\n\n      let hasAnnouncedWorkspace = false\n      let workspaceLogCallCount = logger.logCallCount\n      if (isDebug()) {\n        debugFn(`check: workspace ${workspace}`)\n        hasAnnouncedWorkspace = true\n        workspaceLogCallCount = logger.logCallCount\n      }\n\n      oldVersionsLoop: for (const oldVersion of oldVersions) {\n        const oldId = `${name}@${oldVersion}`\n        const oldPurl = idToPurl(oldId, partialPurlObj.type)\n\n        const node = findPackageNode(actualTree, name, oldVersion)\n        if (!node) {\n          debugFn(`skip: ${oldId} not found`)\n          continue oldVersionsLoop\n        }\n        infosLoop: for (const {\n          firstPatchedVersionIdentifier,\n          vulnerableVersionRange,\n        } of infos) {\n          if (semver.gte(oldVersion, firstPatchedVersionIdentifier)) {\n            debugFn(`skip: ${oldId} is >= ${firstPatchedVersionIdentifier}`)\n            continue infosLoop\n          }\n\n          const newVersion = findBestPatchVersion(\n            node,\n            availableVersions,\n            vulnerableVersionRange,\n            firstPatchedVersionIdentifier,\n          )\n\n          if (\n            activeBranches.find(\n              b =>\n                b.workspace === branchWorkspace && b.newVersion === newVersion,\n            )\n          ) {\n            debugFn(`skip: open PR found for ${name}@${newVersion}`)\n            if (++count >= limit) {\n              logger.dedent()\n              spinner?.dedent()\n              break infoEntriesLoop\n            }\n            continue infosLoop\n          }\n\n          const newVersionPackument = newVersion\n            ? packument.versions[newVersion]\n            : undefined\n\n          if (!(newVersion && newVersionPackument)) {\n            warningsForAfter.add(\n              `${oldId} not updated: requires >=${firstPatchedVersionIdentifier}`,\n            )\n            continue infosLoop\n          }\n\n          const overrideKey = `${name}@${vulnerableVersionRange}`\n          const newVersionRange = applyRange(\n            oldOverrides?.[overrideKey] ?? oldVersion,\n            newVersion,\n            rangeStyle,\n          )\n          const newId = `${name}@${newVersionRange}`\n\n          const updateOverrides = isWorkspaceRoot\n            ? ({\n                [PNPM]: {\n                  ...oldPnpmSection,\n                  [OVERRIDES]: {\n                    ...oldOverrides,\n                    [overrideKey]: newVersionRange,\n                  },\n                },\n              } as PackageJson)\n            : undefined\n\n          const revertOverrides = (\n            isWorkspaceRoot\n              ? {\n                  [PNPM]: oldPnpmSection\n                    ? {\n                        ...oldPnpmSection,\n                        [OVERRIDES]:\n                          oldOverrides && Object.keys(oldOverrides).length > 1\n                            ? {\n                                ...oldOverrides,\n                                [overrideKey]: undefined,\n                              }\n                            : undefined,\n                      }\n                    : undefined,\n                }\n              : {}\n          ) as PackageJson\n\n          const revertData = {\n            ...revertOverrides,\n            ...(editablePkgJson.content.dependencies && {\n              dependencies: { ...editablePkgJson.content.dependencies },\n            }),\n            ...(editablePkgJson.content.optionalDependencies && {\n              optionalDependencies: {\n                ...editablePkgJson.content.optionalDependencies,\n              },\n            }),\n            ...(editablePkgJson.content.peerDependencies && {\n              peerDependencies: { ...editablePkgJson.content.peerDependencies },\n            }),\n          } as PackageJson\n\n          if (updateOverrides) {\n            // Update overrides in the root package.json so that when `pnpm install`\n            // generates pnpm-lock.yaml it updates transitive dependencies too.\n            editablePkgJson.update(updateOverrides)\n          }\n          updatePackageJsonFromNode(\n            editablePkgJson,\n            actualTree,\n            node,\n            newVersion,\n            rangeStyle,\n          )\n          // eslint-disable-next-line no-await-in-loop\n          if (!(await editablePkgJson.save({ ignoreWhitespace: true }))) {\n            debugFn(`skip: ${workspace}/package.json unchanged`)\n            // Reset things just in case.\n            if (isCi) {\n              // eslint-disable-next-line no-await-in-loop\n              await gitResetAndClean(baseBranch, cwd)\n            }\n            continue infosLoop\n          }\n\n          if (!hasAnnouncedWorkspace) {\n            hasAnnouncedWorkspace = true\n            workspaceLogCallCount = logger.logCallCount\n          }\n\n          spinner?.start()\n          spinner?.info(`Installing ${newId} in ${workspace}.`)\n\n          let error\n          let errored = false\n          try {\n            const revertOverridesContent =\n              extractOverridesFromPnpmLockfileContent(lockfileContent)\n            // eslint-disable-next-line no-await-in-loop\n            const maybeActualTree = await install(pkgEnvDetails, {\n              cwd,\n              spinner,\n            })\n            const maybeLockfileContent = maybeActualTree\n              ? // eslint-disable-next-line no-await-in-loop\n                await readPnpmLockfile(lockfilePath)\n              : null\n            if (maybeActualTree && maybeLockfileContent) {\n              actualTree = maybeActualTree\n              lockfileContent = maybeLockfileContent\n              // Revert overrides metadata in package.json now that pnpm-lock.yaml\n              // has been updated.\n              editablePkgJson.update(revertOverrides)\n              // eslint-disable-next-line no-await-in-loop\n              await editablePkgJson.save({ ignoreWhitespace: true })\n              const updatedOverridesContent =\n                extractOverridesFromPnpmLockfileContent(lockfileContent)\n              if (updatedOverridesContent) {\n                lockfileContent = lockfileContent!.replace(\n                  updatedOverridesContent,\n                  revertOverridesContent,\n                )\n                // eslint-disable-next-line no-await-in-loop\n                await fs.writeFile(lockfilePath, lockfileContent, 'utf8')\n              }\n              if (test) {\n                spinner?.info(`Testing ${newId} in ${workspace}.`)\n                // eslint-disable-next-line no-await-in-loop\n                await runScript(testScript, [], { spinner, stdio: 'ignore' })\n              }\n              spinner?.success(`Fixed ${name} in ${workspace}.`)\n            } else {\n              errored = true\n            }\n          } catch (e) {\n            error = e\n            errored = true\n          }\n\n          spinner?.stop()\n\n          // Check repoInfo to make TypeScript happy.\n          if (!errored && isCi && repoInfo) {\n            try {\n              // eslint-disable-next-line no-await-in-loop\n              const result = await gitUnstagedModifiedFiles(cwd)\n              if (!result.ok) {\n                logger.warn(\n                  'Unexpected condition: Nothing to commit, skipping PR creation.',\n                )\n                continue\n              }\n              const moddedFilepaths = result.data.filter(p => {\n                const basename = path.basename(p)\n                return (\n                  basename === 'package.json' || basename === 'pnpm-lock.yaml'\n                )\n              })\n              if (!moddedFilepaths.length) {\n                logger.warn(\n                  'Unexpected condition: Nothing to commit, skipping PR creation.',\n                )\n                continue infosLoop\n              }\n\n              const branch = getSocketBranchName(oldPurl, newVersion, workspace)\n              let skipPr = false\n              if (\n                // eslint-disable-next-line no-await-in-loop\n                await prExistForBranch(repoInfo.owner, repoInfo.repo, branch)\n              ) {\n                skipPr = true\n                debugFn(`skip: branch \"${branch}\" exists`)\n              }\n              // eslint-disable-next-line no-await-in-loop\n              else if (await gitRemoteBranchExists(branch, cwd)) {\n                skipPr = true\n                debugFn(`skip: remote branch \"${branch}\" exists`)\n              } else if (\n                // eslint-disable-next-line no-await-in-loop\n                !(await gitCreateAndPushBranch(\n                  branch,\n                  getSocketCommitMessage(oldPurl, newVersion, workspace),\n                  moddedFilepaths,\n                  {\n                    cwd,\n                    email: gitEmail,\n                    user: gitUser,\n                  },\n                ))\n              ) {\n                skipPr = true\n                logger.warn(\n                  'Unexpected condition: Push failed, skipping PR creation.',\n                )\n              }\n              if (skipPr) {\n                // eslint-disable-next-line no-await-in-loop\n                await gitResetAndClean(baseBranch, cwd)\n                // eslint-disable-next-line no-await-in-loop\n                const maybeActualTree = await install(pkgEnvDetails, {\n                  cwd,\n                  spinner,\n                })\n                const maybeLockfileContent = maybeActualTree\n                  ? // eslint-disable-next-line no-await-in-loop\n                    await readPnpmLockfile(lockfilePath)\n                  : null\n                if (maybeActualTree && maybeLockfileContent) {\n                  actualTree = maybeActualTree\n                  lockfileContent = maybeLockfileContent\n                  continue infosLoop\n                }\n                // Exit early if install fails.\n                return handleInstallFail()\n              }\n\n              // eslint-disable-next-line no-await-in-loop\n              await Promise.allSettled([\n                setGitRemoteGithubRepoUrl(\n                  repoInfo.owner,\n                  repoInfo.repo,\n                  githubToken,\n                  cwd,\n                ),\n                cleanupOpenPrs(repoInfo.owner, repoInfo.repo, {\n                  newVersion,\n                  purl: oldPurl,\n                  workspace,\n                }),\n              ])\n              // eslint-disable-next-line no-await-in-loop\n              const prResponse = await openPr(\n                repoInfo.owner,\n                repoInfo.repo,\n                branch,\n                oldPurl,\n                newVersion,\n                {\n                  baseBranch,\n                  cwd,\n                  workspace,\n                },\n              )\n              if (prResponse) {\n                const { data } = prResponse\n                const prRef = `PR #${data.number}`\n                logger.success(`Opened ${prRef}.`)\n                if (autoMerge) {\n                  logger.indent()\n                  spinner?.indent()\n                  // eslint-disable-next-line no-await-in-loop\n                  const { details, enabled } = await enablePrAutoMerge(data)\n                  if (enabled) {\n                    logger.info(`Auto-merge enabled for ${prRef}.`)\n                  } else {\n                    const message = `Failed to enable auto-merge for ${prRef}${\n                      details\n                        ? `:\\n${details.map(d => ` - ${d}`).join('\\n')}`\n                        : '.'\n                    }`\n                    logger.error(message)\n                  }\n                  logger.dedent()\n                  spinner?.dedent()\n                }\n              }\n            } catch (e) {\n              error = e\n              errored = true\n            }\n          }\n\n          if (isCi) {\n            spinner?.start()\n            // eslint-disable-next-line no-await-in-loop\n            await gitResetAndClean(baseBranch, cwd)\n            // eslint-disable-next-line no-await-in-loop\n            const maybeActualTree = await install(pkgEnvDetails, {\n              cwd,\n              spinner,\n            })\n            const maybeLockfileContent = maybeActualTree\n              ? // eslint-disable-next-line no-await-in-loop\n                await readPnpmLockfile(lockfilePath)\n              : null\n            spinner?.stop()\n            if (maybeActualTree) {\n              actualTree = maybeActualTree\n              lockfileContent = maybeLockfileContent\n            } else {\n              errored = true\n            }\n          }\n          if (errored) {\n            if (!isCi) {\n              spinner?.start()\n              editablePkgJson.update(revertData)\n              // eslint-disable-next-line no-await-in-loop\n              await Promise.all([\n                removeNodeModules(cwd),\n                editablePkgJson.save({ ignoreWhitespace: true }),\n              ])\n              // eslint-disable-next-line no-await-in-loop\n              const maybeActualTree = await install(pkgEnvDetails, {\n                cwd,\n                spinner,\n              })\n              const maybeLockfileContent = maybeActualTree\n                ? // eslint-disable-next-line no-await-in-loop\n                  await readPnpmLockfile(lockfilePath)\n                : null\n              spinner?.stop()\n              if (maybeActualTree) {\n                actualTree = maybeActualTree\n                lockfileContent = maybeLockfileContent\n              } else {\n                // Exit early if install fails.\n                return handleInstallFail()\n              }\n            }\n            return {\n              ok: false,\n              message: 'Update failed',\n              cause: `Update failed for ${oldId} in ${workspace}${error ? '; ' + error : ''}`,\n            }\n          }\n          debugFn('name:', name)\n          debugFn('increment: count', count + 1)\n          if (++count >= limit) {\n            logger.dedent()\n            spinner?.dedent()\n            break infoEntriesLoop\n          }\n        }\n      }\n      if (!isLastPkgJsonPath && logger.logCallCount > workspaceLogCallCount) {\n        logger.logNewline()\n      }\n    }\n\n    for (const warningText of warningsForAfter) {\n      logger.warn(warningText)\n    }\n    if (!isLastInfoEntry) {\n      logger.logNewline()\n    }\n    logger.dedent()\n    spinner?.dedent()\n  }\n\n  spinner?.stop()\n\n  // Or, did we change anything?\n  return { ok: true, data: { fixed: true } }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { npmFix } from './npm-fix.mts'\nimport { pnpmFix } from './pnpm-fix.mts'\nimport { CMD_NAME } from './shared.mts'\nimport constants from '../../constants.mts'\nimport { detectAndValidatePackageEnvironment } from '../../utils/package-environment.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { RangeStyle } from '../../utils/semver.mts'\n\nconst { NPM, PNPM } = constants\n\nexport async function runFix({\n  autoMerge,\n  cwd,\n  limit,\n  purls,\n  rangeStyle,\n  test,\n  testScript,\n}: {\n  autoMerge: boolean\n  cwd: string\n  limit: number\n  purls: string[]\n  rangeStyle: RangeStyle\n  test: boolean\n  testScript: string\n}): Promise<CResult<unknown>> {\n  const result = await detectAndValidatePackageEnvironment(cwd, {\n    cmdName: CMD_NAME,\n    logger,\n  })\n\n  if (!result.ok) {\n    return result\n  }\n  const pkgEnvDetails = result.data\n  if (!pkgEnvDetails) {\n    return {\n      ok: false,\n      message: 'No package found',\n      cause: `No valid package environment was found in given cwd (${cwd})`,\n    }\n  }\n\n  logger.info(`Fixing packages for ${pkgEnvDetails.agent}.\\n`)\n\n  const { agent } = pkgEnvDetails\n\n  if (agent === NPM) {\n    return await npmFix(pkgEnvDetails, {\n      autoMerge,\n      cwd,\n      limit,\n      purls,\n      rangeStyle,\n      test,\n      testScript,\n    })\n  } else if (agent === PNPM) {\n    return await pnpmFix(pkgEnvDetails, {\n      autoMerge,\n      cwd,\n      limit,\n      purls,\n      rangeStyle,\n      test,\n      testScript,\n    })\n  } else {\n    return {\n      ok: false,\n      message: 'Not supported',\n      cause: `${agent} is not supported by this command at the moment.`,\n    }\n  }\n}\n","import { outputFixResult } from './output-fix-result.mts'\nimport { runFix } from './run-fix.mts'\n\nimport type { OutputKind } from '../../types.mts'\nimport type { RangeStyle } from '../../utils/semver.mts'\n\nexport async function handleFix({\n  autoMerge,\n  cwd,\n  limit,\n  outputKind,\n  purls,\n  rangeStyle,\n  test,\n  testScript,\n}: {\n  autoMerge: boolean\n  cwd: string\n  limit: number\n  outputKind: OutputKind\n  purls: string[]\n  rangeStyle: RangeStyle\n  test: boolean\n  testScript: string\n}) {\n  const result = await runFix({\n    autoMerge,\n    cwd,\n    limit,\n    purls,\n    rangeStyle,\n    test,\n    testScript,\n  })\n\n  await outputFixResult(result, outputKind)\n}\n","import path from 'node:path'\n\nimport terminalLink from 'terminal-link'\n\nimport { joinOr } from '@socketsecurity/registry/lib/arrays'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleFix } from './handle-fix.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { RangeStyles } from '../../utils/semver.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\nimport type { RangeStyle } from '../../utils/semver.mts'\n\nconst { DRY_RUN_NOT_SAVING } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'fix',\n  description: 'Update dependencies with \"fixable\" Socket alerts',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    autoMerge: {\n      type: 'boolean',\n      default: false,\n      description: `Enable auto-merge for pull requests that Socket opens.\\n                        See ${terminalLink(\n        'GitHub documentation',\n        'https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-auto-merge-for-pull-requests-in-your-repository',\n      )} for managing auto-merge for pull requests in your repository.`,\n    },\n    autopilot: {\n      type: 'boolean',\n      default: false,\n      description: `Shorthand for --autoMerge --test`,\n    },\n    limit: {\n      type: 'number',\n      default: Infinity,\n      description: 'The number of fixes to attempt at a time',\n    },\n    purl: {\n      type: 'string',\n      default: [],\n      description: `Provide a list of ${terminalLink(\n        'package URLs',\n        'https://github.com/package-url/purl-spec?tab=readme-ov-file#purl',\n      )} (PURLs) to fix, as either a comma separated value or as multiple flags,\\n                        instead of querying the Socket API`,\n      isMultiple: true,\n      shortFlag: 'p',\n    },\n    rangeStyle: {\n      type: 'string',\n      default: 'preserve',\n      description: `\n                        Define how updated dependency versions should be written in package.json.\n                        Available styles:\n                          * caret - Use ^ range for compatible updates (e.g. ^1.2.3)\n                          * gt - Use > to allow any newer version (e.g. >1.2.3)\n                          * gte - Use >= to allow any newer version (e.g. >=1.2.3)\n                          * lt - Use < to allow only lower versions (e.g. <1.2.3)\n                          * lte - Use <= to allow only lower versions (e.g. <=1.2.3)\n                          * pin - Use the exact version (e.g. 1.2.3)\n                          * preserve - Retain the existing version range style as-is\n                          * tilde - Use ~ range for patch/minor updates (e.g. ~1.2.3)\n      `.trim(),\n    },\n    test: {\n      type: 'boolean',\n      default: false,\n      description: 'Verify the fix by running unit tests',\n    },\n    testScript: {\n      type: 'string',\n      default: 'test',\n      description: 'The test script to run for each fix attempt',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [options] [CWD=.]\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}\n      $ ${command} ./proj/tree --autoMerge\n  `,\n}\n\nexport const cmdFix = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { autopilot, json, markdown } = cli.flags\n  let { autoMerge, rangeStyle, test } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  if (autopilot) {\n    autoMerge = true\n    test = true\n  }\n\n  const wasValidInput = checkCommandInput(outputKind, {\n    test: RangeStyles.includes(cli.flags['rangeStyle'] as string),\n    message: `Expecting range style of ${joinOr(RangeStyles)}`,\n    pass: 'ok',\n    fail: 'missing',\n  })\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_NOT_SAVING)\n    return\n  }\n\n  let purls: string[] = Array.isArray(cli.flags['purl'])\n    ? cli.flags['purl']\n    : []\n  purls = purls.flatMap(p => p.split(/, */))\n\n  if (\n    !['caret', 'gt', 'gte', 'lt', 'lte', 'pin', 'preserve', 'tilde'].includes(\n      rangeStyle as string,\n    )\n  ) {\n    rangeStyle = 'preserve'\n  }\n\n  await handleFix({\n    autoMerge: Boolean(autoMerge),\n    cwd,\n    limit:\n      (cli.flags['limit']\n        ? parseInt(String(cli.flags['limit'] || ''), 10)\n        : Infinity) || Infinity,\n    outputKind,\n    purls,\n    rangeStyle: rangeStyle as RangeStyle,\n    test: Boolean(test),\n    testScript: String(cli.flags['testScript'] || 'test'),\n  })\n}\n","import { getSeverityCount } from '../../utils/alert/severity.mts'\nimport {\n  handleApiCall,\n  handleUnsuccessfulApiResponse,\n} from '../../utils/api.mts'\nimport { getPublicToken, setupSdk } from '../../utils/sdk.mts'\n\nimport type { PackageData } from './handle-package-info.mts'\n\nexport async function fetchPackageInfo(\n  pkgName: string,\n  pkgVersion: string,\n  includeAllIssues: boolean,\n): Promise<void | PackageData> {\n  const sockSdkResult = await setupSdk(getPublicToken())\n  if (!sockSdkResult.ok) {\n    throw new Error('Was unable to setup sdk. Run `socket login` first.')\n  }\n  const sockSdk = sockSdkResult.data\n\n  const result = await handleApiCall(\n    sockSdk.getIssuesByNPMPackage(pkgName, pkgVersion),\n    'package issues',\n  )\n  const scoreResult = await handleApiCall(\n    sockSdk.getScoreByNPMPackage(pkgName, pkgVersion),\n    'package score',\n  )\n\n  if (!result.ok) {\n    handleUnsuccessfulApiResponse(\n      'getIssuesByNPMPackage',\n      result.message,\n      result.cause ?? '',\n      (result.data as any)?.code ?? 0,\n    )\n  }\n\n  if (!scoreResult.ok) {\n    handleUnsuccessfulApiResponse(\n      'getScoreByNPMPackage',\n      scoreResult.message,\n      scoreResult.cause ?? '',\n      (scoreResult.data as any)?.code ?? 0,\n    )\n  }\n\n  const severityCount = getSeverityCount(\n    result.data,\n    includeAllIssues ? undefined : 'high',\n  )\n\n  return {\n    data: result.data,\n    severityCount,\n    score: scoreResult.data,\n  }\n}\n","import colors from 'yoctocolors-cjs'\n\nimport constants from '@socketsecurity/registry/lib/constants'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { hasKeys } from '@socketsecurity/registry/lib/objects'\n\nimport {\n  ALERT_SEVERITY,\n  formatSeverityCount,\n} from '../../utils/alert/severity.mts'\nimport { ColorOrMarkdown } from '../../utils/color-or-markdown.mts'\nimport {\n  getSocketDevAlertUrl,\n  getSocketDevPackageOverviewUrl,\n} from '../../utils/socket-url.mts'\n\nimport type { PackageData } from './handle-package-info.mts'\nimport type { OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nconst { NPM } = constants\n\nfunction formatScore(score: number): string {\n  if (score > 80) {\n    return colors.green(`${score}`)\n  } else if (score < 80 && score > 60) {\n    return colors.yellow(`${score}`)\n  }\n  return colors.red(`${score}`)\n}\n\nfunction outputPackageIssuesDetails(\n  packageData: SocketSdkReturnType<'getIssuesByNPMPackage'>['data'],\n  outputMarkdown: boolean,\n) {\n  const issueDetails = packageData.filter(\n    d =>\n      d.value?.severity === ALERT_SEVERITY.critical ||\n      d.value?.severity === ALERT_SEVERITY.high,\n  )\n  const uniqueIssueDetails = issueDetails.reduce((acc, issue) => {\n    const { type } = issue\n    if (type) {\n      const details = acc.get(type)\n      if (details) {\n        details.count += 1\n      } else {\n        acc.set(type, {\n          label: issue.value?.label ?? '',\n          count: 1,\n        })\n      }\n    }\n    return acc\n  }, new Map<string, { count: number; label: string }>())\n  const format = new ColorOrMarkdown(outputMarkdown)\n  for (const [type, details] of uniqueIssueDetails.entries()) {\n    const issueWithLink = format.hyperlink(\n      details.label,\n      getSocketDevAlertUrl(type),\n      { fallbackToUrl: true },\n    )\n    if (details.count === 1) {\n      logger.log(`- ${issueWithLink}`)\n    } else {\n      logger.log(`- ${issueWithLink}: ${details.count}`)\n    }\n  }\n}\n\nexport function outputPackageInfo(\n  { data, score, severityCount }: PackageData,\n  {\n    commandName,\n    outputKind,\n    pkgName,\n    pkgVersion,\n  }: {\n    commandName: string\n    outputKind: OutputKind\n    pkgName: string\n    pkgVersion: string\n    includeAllIssues?: boolean | undefined\n  },\n): void {\n  if (outputKind === 'json') {\n    logger.log(JSON.stringify(data, undefined, 2))\n    return\n  }\n  if (outputKind === 'markdown') {\n    logger.log(\n      `\n# Package report for ${pkgName}\n\nPackage report card:\n    `.trim(),\n    )\n  } else {\n    logger.log(`Package report card for ${pkgName}:`)\n  }\n  const scoreResult = {\n    'Supply Chain Risk': Math.floor(score.supplyChainRisk.score * 100),\n    Maintenance: Math.floor(score.maintenance.score * 100),\n    Quality: Math.floor(score.quality.score * 100),\n    Vulnerabilities: Math.floor(score.vulnerability.score * 100),\n    License: Math.floor(score.license.score * 100),\n  }\n  logger.log('\\n')\n  Object.entries(scoreResult).map(score =>\n    logger.log(`- ${score[0]}: ${formatScore(score[1])}`),\n  )\n  logger.log('\\n')\n  if (hasKeys(severityCount)) {\n    if (outputKind === 'markdown') {\n      logger.log('# Issues\\n')\n    }\n    logger.log(\n      `Package has these issues: ${formatSeverityCount(severityCount)}\\n`,\n    )\n    outputPackageIssuesDetails(data, outputKind === 'markdown')\n  } else {\n    logger.log('Package has no issues')\n  }\n\n  const format = new ColorOrMarkdown(outputKind === 'markdown')\n  const url = getSocketDevPackageOverviewUrl(NPM, pkgName, pkgVersion)\n\n  logger.log('\\n')\n  if (pkgVersion === 'latest') {\n    logger.log(\n      `Detailed info on socket.dev: ${format.hyperlink(`${pkgName}`, url, { fallbackToUrl: true })}`,\n    )\n  } else {\n    logger.log(\n      `Detailed info on socket.dev: ${format.hyperlink(`${pkgName} v${pkgVersion}`, url, { fallbackToUrl: true })}`,\n    )\n  }\n  if (outputKind !== 'markdown') {\n    logger.log(\n      colors.dim(\n        `\\nOr rerun ${colors.italic(commandName)} using the ${colors.italic('--json')} flag to get full JSON output`,\n      ),\n    )\n  } else {\n    logger.log('')\n  }\n}\n","import { hasKeys } from '@socketsecurity/registry/lib/objects'\n\nimport { fetchPackageInfo } from './fetch-package-info.mts'\nimport { outputPackageInfo } from './output-package-info.mts'\n\nimport type { OutputKind } from '../../types.mts'\nimport type { SocketSdkAlert } from '../../utils/alert/severity.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport interface PackageData {\n  data: SocketSdkReturnType<'getIssuesByNPMPackage'>['data']\n  severityCount: Record<SocketSdkAlert['severity'], number>\n  score: SocketSdkReturnType<'getScoreByNPMPackage'>['data']\n}\n\nexport async function handlePackageInfo({\n  commandName,\n  includeAllIssues,\n  outputKind,\n  pkgName,\n  pkgVersion,\n  strict,\n}: {\n  commandName: string\n  includeAllIssues: boolean\n  outputKind: OutputKind\n  pkgName: string\n  pkgVersion: string\n  strict: boolean\n}) {\n  const packageData = await fetchPackageInfo(\n    pkgName,\n    pkgVersion,\n    includeAllIssues,\n  )\n\n  if (packageData) {\n    outputPackageInfo(packageData, {\n      commandName,\n      includeAllIssues,\n      outputKind,\n      pkgName,\n      pkgVersion,\n    })\n\n    if (strict && hasKeys(packageData.severityCount)) {\n      // Let NodeJS exit gracefully but with exit(1)\n      process.exitCode = 1\n    }\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handlePackageInfo } from './handle-package-info.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags, validationFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'info',\n  description: 'Look up info regarding a package',\n  hidden: true, // Deprecated\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    ...validationFlags,\n  },\n  help: (command, config) =>\n    isTestingV1()\n      ? 'This command will be removed in v1'\n      : `\n    Usage\n      $ ${command} <name>\n\n    Note: this command will be deprecated in favor of \\`socket package score\\` soon\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} webtorrent\n      $ ${command} webtorrent@1.9.1\n  `,\n}\n\nexport const cmdInfo = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { all, json, markdown, strict } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [rawPkgName = ''] = cli.input\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!rawPkgName,\n      message: 'Expecting a package name',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: cli.input.length === 1,\n      message: 'Can only accept one package at a time',\n      pass: 'ok',\n      fail: 'got ' + cli.input.length,\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  const versionSeparator = rawPkgName.lastIndexOf('@')\n  const pkgName =\n    versionSeparator < 1 ? rawPkgName : rawPkgName.slice(0, versionSeparator)\n  const pkgVersion =\n    versionSeparator < 1 ? 'latest' : rawPkgName.slice(versionSeparator + 1)\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handlePackageInfo({\n    commandName: `${parentName} ${config.commandName}`,\n    includeAllIssues: Boolean(all),\n    outputKind,\n    pkgName,\n    pkgVersion,\n    strict: Boolean(strict),\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\n\nimport type { CResult } from '../../types.mts'\n\nexport async function outputInstallCompletion(\n  result: CResult<{\n    actions: string[]\n    bashrcPath: string\n    completionCommand: string\n    bashrcUpdated: boolean\n    foundBashrc: boolean\n    sourcingCommand: string\n    targetName: string\n    targetPath: string\n  }>,\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.log('')\n  logger.log(\n    `Installation of tab completion for \"${result.data.targetName}\" finished!`,\n  )\n  logger.log('')\n\n  result.data.actions.forEach(action => {\n    logger.log(`  - ${action}`)\n  })\n  logger.log('')\n  logger.log('Socket tab completion works automatically in new terminals.')\n  logger.log('')\n  logger.log(\n    'Due to a bash limitation, tab completion cannot be enabled in the',\n  )\n  logger.log('current shell (bash instance) through NodeJS. You must either:')\n  logger.log('')\n  logger.log('1. Reload your .bashrc script (best):')\n  logger.log('')\n  logger.log(`   source ~/.bashrc`)\n  logger.log('')\n  logger.log('2. Run these commands to load the completion script:')\n  logger.log('')\n  logger.log(`   source ${result.data.targetPath}`)\n  logger.log(`   ${result.data.completionCommand}`)\n  logger.log('')\n  logger.log('3. Or restart bash somehow (restart terminal or run `bash`)')\n  logger.log('')\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\n\nimport { debugFn } from '@socketsecurity/registry/lib/debug'\n\nimport constants from '../../constants.mts'\nimport { getBashrcDetails } from '../../utils/completion.mts'\n\nimport type { CResult } from '../../types.mts'\n\nexport async function setupTabCompletion(targetName: string): Promise<\n  CResult<{\n    actions: string[]\n    bashrcPath: string\n    bashrcUpdated: boolean\n    completionCommand: string\n    foundBashrc: boolean\n    sourcingCommand: string\n    targetName: string\n    targetPath: string\n  }>\n> {\n  const result = getBashrcDetails(targetName)\n  if (!result.ok) {\n    return result\n  }\n\n  const { completionCommand, sourcingCommand, targetPath, toAddToBashrc } =\n    result.data\n\n  // Target dir is something like ~/.local/share/socket/settings/completion (linux)\n  const targetDir = path.dirname(targetPath)\n  debugFn('target: path + dir', targetPath, targetDir)\n\n  if (!fs.existsSync(targetDir)) {\n    debugFn('create: target dir')\n    fs.mkdirSync(targetDir, { recursive: true })\n  }\n\n  updateInstalledTabCompletionScript(targetPath)\n\n  let bashrcUpdated = false\n\n  // Add to ~/.bashrc if not already there\n  // Lazily access constants.homePath\n  const bashrcPath = constants.homePath\n    ? path.join(constants.homePath, '.bashrc')\n    : ''\n\n  const foundBashrc = Boolean(bashrcPath && fs.existsSync(bashrcPath))\n\n  if (foundBashrc) {\n    const content = fs.readFileSync(bashrcPath, 'utf8')\n    if (!content.includes(sourcingCommand)) {\n      fs.appendFileSync(bashrcPath, toAddToBashrc)\n      bashrcUpdated = true\n    }\n  }\n\n  return {\n    ok: true,\n    data: {\n      actions: [\n        `Installed the tab completion script in ${targetPath}`,\n        bashrcUpdated\n          ? 'Added tab completion loader to ~/.bashrc'\n          : foundBashrc\n            ? 'Tab completion already found in ~/.bashrc'\n            : 'No ~/.bashrc found so tab completion was not completely installed',\n      ],\n      bashrcPath,\n      bashrcUpdated,\n      completionCommand,\n      foundBashrc,\n      sourcingCommand,\n      targetName,\n      targetPath,\n    },\n  }\n}\n\nfunction getTabCompletionScriptRaw(): CResult<string> {\n  const sourceDir = path.dirname(fileURLToPath(import.meta.url))\n  const sourcePath = path.join(sourceDir, 'socket-completion.bash')\n\n  if (!fs.existsSync(sourcePath)) {\n    return {\n      ok: false,\n      message: 'Source not found',\n      cause: `Unable to find the source tab completion bash script that Socket should ship. Expected to find it in \\`${sourcePath}\\` but it was not there.`,\n    }\n  }\n\n  return { ok: true, data: fs.readFileSync(sourcePath, 'utf8') }\n}\n\nexport function updateInstalledTabCompletionScript(\n  targetPath: string,\n): CResult<undefined> {\n  const content = getTabCompletionScriptRaw()\n  if (!content.ok) {\n    return content\n  }\n\n  // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION_HASH.\n  const CLI_VERSION = constants.ENV.INLINED_SOCKET_CLI_VERSION_HASH\n\n  // When installing set the current package.json version.\n  // Later, we can call _socket_completion_version to get the installed version.\n  fs.writeFileSync(\n    targetPath,\n    content.data.replaceAll('SOCKET_VERSION_TOKEN', CLI_VERSION),\n    'utf8',\n  )\n\n  return { ok: true, data: undefined }\n}\n","import { outputInstallCompletion } from './output-install-completion.mts'\nimport { setupTabCompletion } from './setup-tab-completion.mts'\n\nexport async function handleInstallCompletion(targetName: string) {\n  const result = await setupTabCompletion(targetName)\n  await outputInstallCompletion(result)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleInstallCompletion } from './handle-install-completion.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'completion',\n  description: 'Install bash completion for Socket CLI',\n  hidden: true, // beta; isTestingV1\n  flags: {\n    ...commonFlags,\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [name=socket]\n\n    Installs bash completion for the Socket CLI. This will:\n    1. Source the completion script in your current shell\n    2. Add the source command to your ~/.bashrc if it's not already there\n\n    This command will only setup tab completion, nothing else.\n\n    Afterwards you should be able to type \\`socket \\` and then press tab to\n    have bash auto-complete/suggest the sub/command or flags.\n\n    Currently only supports bash.\n\n    The optional name argument allows you to enable tab completion on a command\n    name other than \"socket\". Mostly for debugging but also useful if you use a\n    different alias for socket on your system.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n\n      $ ${command}\n      $ ${command} sd\n      $ ${command} ./sd\n  `,\n}\n\nexport const cmdInstallCompletion = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const targetName = cli.input[0] || 'socket'\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleInstallCompletion(String(targetName))\n}\n","import { cmdInstallCompletion } from './cmd-install-completion.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Setup the Socket CLI command in your environment'\n\nexport const cmdInstall: CliSubcommand = {\n  description,\n  hidden: true, // beta; isTestingV1\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        completion: cmdInstallCompletion,\n      },\n      {\n        argv,\n        description,\n        importMeta,\n        name: `${parentName} install`,\n      },\n    )\n  },\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { tildify } from '../../utils/tildify.mts'\n\nexport async function outputCmdJson(cwd: string) {\n  logger.info('Target cwd:', constants.ENV.VITEST ? '<redacted>' : tildify(cwd))\n\n  const sjpath = path.join(cwd, 'socket.json')\n  const tildeSjpath = constants.ENV.VITEST ? '<redacted>' : tildify(sjpath)\n\n  if (!fs.existsSync(sjpath)) {\n    logger.fail(`Not found: ${tildeSjpath}`)\n    process.exitCode = 1\n    return\n  }\n\n  if (!fs.lstatSync(sjpath).isFile()) {\n    logger.fail(\n      `This is not a regular file (maybe a directory?): ${tildeSjpath}`,\n    )\n    process.exitCode = 1\n    return\n  }\n\n  const data = fs.readFileSync(sjpath, 'utf8')\n\n  logger.success(`This is the contents of ${tildeSjpath}:`)\n  logger.error('')\n  logger.log(data)\n}\n","import { outputCmdJson } from './output-cmd-json.mts'\n\nexport async function handleCmdJson(cwd: string) {\n  await outputCmdJson(cwd)\n}\n","import path from 'node:path'\n\nimport { handleCmdJson } from './handle-cmd-json.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst config: CliCommandConfig = {\n  commandName: 'json',\n  description:\n    'Display the `socket.json` that would be applied for target folder',\n  hidden: true, // This is a power tool. No need to clutter the toplevel.\n  flags: {\n    ...commonFlags,\n  },\n  help: parentName => `\n    Usage\n      $ ${parentName} [CWD=.]\n\n    Display the \\`socket.json\\` file that would apply when running relevant commands\n    in the target directory.\n  `,\n}\n\nexport const cmdJson = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  await handleCmdJson(cwd)\n}\n","import { updateConfigValue } from '../../utils/config.mts'\n\nexport function applyLogin(\n  apiToken: string,\n  enforcedOrgs: string[],\n  apiBaseUrl: string | undefined,\n  apiProxy: string | undefined,\n) {\n  updateConfigValue('enforcedOrgs', enforcedOrgs)\n  updateConfigValue('apiToken', apiToken)\n  updateConfigValue('apiBaseUrl', apiBaseUrl)\n  updateConfigValue('apiProxy', apiProxy)\n}\n","import terminalLink from 'terminal-link'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { confirm, password, select } from '@socketsecurity/registry/lib/prompts'\n\nimport { applyLogin } from './apply-login.mts'\nimport constants from '../../constants.mts'\nimport { handleApiCall } from '../../utils/api.mts'\nimport {\n  getConfigValueOrUndef,\n  isReadOnlyConfig,\n  isTestingV1,\n} from '../../utils/config.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\nimport { setupTabCompletion } from '../install/setup-tab-completion.mts'\n\nimport type { Choice, Separator } from '@socketsecurity/registry/lib/prompts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\ntype OrgChoice = Choice<string>\ntype OrgChoices = Array<Separator | OrgChoice>\nconst { SOCKET_PUBLIC_API_TOKEN } = constants\n\nexport async function attemptLogin(\n  apiBaseUrl: string | undefined,\n  apiProxy: string | undefined,\n) {\n  apiBaseUrl ??= getConfigValueOrUndef('apiBaseUrl') ?? undefined\n  apiProxy ??= getConfigValueOrUndef('apiProxy') ?? undefined\n  const apiToken =\n    (await password({\n      message: `Enter your ${terminalLink(\n        'Socket.dev API key',\n        'https://docs.socket.dev/docs/api-keys',\n      )} (leave blank for a public key)`,\n    })) || SOCKET_PUBLIC_API_TOKEN\n\n  const sdk = await setupSdk(apiToken, apiBaseUrl, apiProxy)\n  if (!sdk.ok) {\n    process.exitCode = 1\n    logger.fail(failMsgWithBadge(sdk.message, sdk.cause))\n    return\n  }\n\n  const result = await handleApiCall(\n    sdk.data.getOrganizations(),\n    'token verification',\n  )\n\n  if (!result.ok) {\n    process.exitCode = 1\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.success('API key verified')\n\n  const orgs: SocketSdkReturnType<'getOrganizations'>['data'] = result.data\n\n  const enforcedChoices: OrgChoices = Object.values(orgs.organizations)\n    .filter(org => org?.plan === 'enterprise')\n    .map(org => ({\n      name: org.name ?? 'undefined',\n      value: org.id,\n    }))\n\n  let enforcedOrgs: string[] = []\n  if (enforcedChoices.length > 1) {\n    const id = (await select({\n      message:\n        \"Which organization's policies should Socket enforce system-wide?\",\n      choices: enforcedChoices.concat({\n        name: 'None',\n        value: '',\n        description: 'Pick \"None\" if this is a personal device',\n      }),\n    })) as string | null\n    if (id) {\n      enforcedOrgs = [id]\n    }\n  } else if (enforcedChoices.length) {\n    if (\n      await confirm({\n        message: `Should Socket enforce ${(enforcedChoices[0] as OrgChoice)?.name}'s security policies system-wide?`,\n        default: true,\n      })\n    ) {\n      const existing = enforcedChoices[0] as OrgChoice\n      if (existing) {\n        enforcedOrgs = [existing.value]\n      }\n    }\n  }\n\n  if (\n    isTestingV1() &&\n    (await select({\n      message: 'Would you like to install bash tab completion?',\n      choices: [\n        {\n          name: 'Yes',\n          value: true,\n          description:\n            'Sets up tab completion for \"socket\" in your bash env. If you\\'re unsure, this is probably what you want.',\n        },\n        {\n          name: 'No',\n          value: false,\n          description:\n            'Will skip tab completion setup. Does not change how Socket works.',\n        },\n      ],\n    }))\n  ) {\n    logger.log('Setting up tab completion...')\n    const result = await setupTabCompletion('socket')\n    if (result.ok) {\n      logger.success(\n        'Tab completion will be enabled after restarting your terminal',\n      )\n    } else {\n      logger.fail(\n        'Failed to install tab completion script. Try `socket install completion` later.',\n      )\n    }\n  }\n\n  const previousPersistedToken = getConfigValueOrUndef('apiToken')\n  try {\n    applyLogin(apiToken, enforcedOrgs, apiBaseUrl, apiProxy)\n    logger.success(\n      `API credentials ${previousPersistedToken === apiToken ? 'refreshed' : previousPersistedToken ? 'updated' : 'set'}`,\n    )\n    if (isReadOnlyConfig()) {\n      logger.log('')\n      logger.warn(\n        'Note: config is in read-only mode, at least one key was overridden through flag/env, so the login was not persisted!',\n      )\n    }\n  } catch {\n    process.exitCode = 1\n    logger.fail(`API login failed`)\n  }\n}\n","import isInteractive from '@socketregistry/is-interactive/index.cjs'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { attemptLogin } from './attempt-login.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { InputError } from '../../utils/errors.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'login',\n  description: 'Socket API login',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    apiBaseUrl: {\n      type: 'string',\n      description: 'API server to connect to for login',\n    },\n    apiProxy: {\n      type: 'string',\n      description: 'Proxy to use when making connection to API server',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}\n\n    API Token Requirements\n      - Quota: 1 unit\n\n    Logs into the Socket API by prompting for an API key\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}\n      $ ${command} --api-proxy=http://localhost:1234\n  `,\n}\n\nexport const cmdLogin = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const apiBaseUrl = cli.flags['apiBaseUrl'] as string | undefined\n  const apiProxy = cli.flags['apiProxy'] as string | undefined\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  if (!isInteractive()) {\n    throw new InputError(\n      'Cannot prompt for credentials in a non-interactive shell',\n    )\n  }\n\n  await attemptLogin(apiBaseUrl, apiProxy)\n}\n","import { updateConfigValue } from '../../utils/config.mts'\n\nexport function applyLogout() {\n  updateConfigValue('apiToken', null)\n  updateConfigValue('apiBaseUrl', null)\n  updateConfigValue('apiProxy', null)\n  updateConfigValue('enforcedOrgs', null)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { applyLogout } from './apply-logout.mts'\nimport { isReadOnlyConfig } from '../../utils/config.mts'\n\nexport function attemptLogout() {\n  try {\n    applyLogout()\n    logger.success('Successfully logged out')\n    if (isReadOnlyConfig()) {\n      logger.log('')\n      logger.warn(\n        'Note: config is in read-only mode, at least one key was overridden through flag/env, so the logout was not persisted!',\n      )\n    }\n  } catch {\n    logger.fail('Failed to complete logout steps')\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { attemptLogout } from './attempt-logout.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'logout',\n  description: 'Socket API logout',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}\n\n    Logs out of the Socket API and clears all Socket credentials from disk\n  `,\n}\n\nexport const cmdLogout = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  attemptLogout()\n}\n","import path from 'node:path'\n\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { detectManifestActions } from './detect-manifest-actions.mts'\nimport { generateAutoManifest } from './generate_auto_manifest.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { readOrDefaultSocketJson } from '../../utils/socketjson.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'auto',\n  description: 'Auto-detect build and attempt to generate manifest file',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    verbose: {\n      type: 'boolean',\n      default: false,\n      description:\n        'Enable debug output (only for auto itself; sub-steps need to have it pre-configured), may help when running into errors',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [CWD=.]\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Tries to figure out what language your target repo uses. If it finds a\n    supported case then it will try to generate the manifest file for that\n    language with the default or detected settings.\n\n    Note: you can exclude languages from being auto-generated if you don't want\n          them to. Run \\`socket manifest setup\\` in the same dir to disable it.\n\n    Examples\n\n      $ ${command}\n      $ ${command} ./project/foo\n  `,\n}\n\nexport const cmdManifestAuto = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n  const { json, markdown, verbose: verboseFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n  const verbose = !!verboseFlag\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  if (verbose) {\n    logger.group('- ', parentName, config.commandName, ':')\n    logger.group('- flags:', cli.flags)\n    logger.groupEnd()\n    logger.log('- input:', cli.input)\n    logger.log('- cwd:', cwd)\n    logger.groupEnd()\n  }\n\n  const socketJson = await readOrDefaultSocketJson(cwd)\n\n  const detected = await detectManifestActions(socketJson, cwd)\n  debugLog('[DEBUG]', detected)\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  if (!detected.count) {\n    logger.fail(\n      'Was unable to discover any targets for which we can generate manifest files...',\n    )\n    logger.log('')\n    logger.log(\n      '- Make sure this script would work with your target build (see `socket manifest --help` for your target).',\n    )\n    logger.log(\n      '- Make sure to run it from the correct dir (use --cwd to target another dir)',\n    )\n    logger.log('- Make sure the necessary build tools are available (`PATH`)')\n    process.exitCode = 1\n    return\n  }\n\n  await generateAutoManifest({\n    detected,\n    cwd,\n    outputKind,\n    verbose,\n  })\n\n  logger.success(\n    `Finished. Should have attempted to generate manifest files for ${detected.count} targets.`,\n  )\n}\n","import path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleManifestConda } from './handle-manifest-conda.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { readOrDefaultSocketJson } from '../../utils/socketjson.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'conda',\n  description:\n    '[beta] Convert a Conda environment.yml file to a python requirements.txt',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    file: {\n      type: 'string',\n      description:\n        'Input file name (by default for Conda this is \"environment.yml\"), relative to cwd',\n    },\n    stdin: {\n      type: 'boolean',\n      description: 'Read the input from stdin (supersedes --file)',\n    },\n    out: {\n      type: 'string',\n      description: 'Output path (relative to cwd)',\n    },\n    stdout: {\n      type: 'boolean',\n      description:\n        'Print resulting requirements.txt to stdout (supersedes --out)',\n    },\n    verbose: {\n      type: 'boolean',\n      description: 'Print debug messages',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [options] [CWD=.]\n\n    Warning: While we don't support Conda necessarily, this tool extracts the pip\n             block from an environment.yml and outputs it as a requirements.txt\n             which you can scan as if it were a pypi package.\n\n    USE AT YOUR OWN RISK\n\n    Note: FILE can be a dash (-) to indicate stdin. This way you can pipe the\n          contents of a file to have it processed.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n\n      $ ${command}\n      $ ${command} ./project/foo --file environment.yaml\n  `,\n}\n\nexport const cmdManifestConda = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json = false, markdown = false } = cli.flags\n  let { file: filename, out, stdin, stdout, verbose } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  const socketJson = await readOrDefaultSocketJson(cwd)\n\n  // Set defaults for any flag/arg that is not given. Check socket.json first.\n  if (\n    stdin === undefined &&\n    socketJson.defaults?.manifest?.conda?.stdin !== undefined\n  ) {\n    stdin = socketJson.defaults?.manifest?.conda?.stdin\n    logger.info('Using default --stdin from socket.json:', stdin)\n  }\n  if (stdin) {\n    filename = '-'\n  } else if (!filename) {\n    if (socketJson.defaults?.manifest?.conda?.infile) {\n      filename = socketJson.defaults?.manifest?.conda?.infile\n      logger.info('Using default --file from socket.json:', filename)\n    } else {\n      filename = 'environment.yml'\n    }\n  }\n  if (\n    stdout === undefined &&\n    socketJson.defaults?.manifest?.conda?.stdout !== undefined\n  ) {\n    stdout = socketJson.defaults?.manifest?.conda?.stdout\n    logger.info('Using default --stdout from socket.json:', stdout)\n  }\n  if (stdout) {\n    out = '-'\n  } else if (!out) {\n    if (socketJson.defaults?.manifest?.conda?.outfile) {\n      out = socketJson.defaults?.manifest?.conda?.outfile\n      logger.info('Using default --out from socket.json:', out)\n    } else {\n      out = 'requirements.txt'\n    }\n  }\n  if (\n    verbose === undefined &&\n    socketJson.defaults?.manifest?.conda?.verbose !== undefined\n  ) {\n    verbose = socketJson.defaults?.manifest?.conda?.verbose\n    logger.info('Using default --verbose from socket.json:', verbose)\n  } else if (verbose === undefined) {\n    verbose = false\n  }\n\n  if (verbose) {\n    logger.group('- ', parentName, config.commandName, ':')\n    logger.group('- flags:', cli.flags)\n    logger.groupEnd()\n    logger.log('- target:', cwd)\n    logger.log('- output:', out)\n    logger.groupEnd()\n  }\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: cli.input.length <= 1,\n      message: 'Can only accept one DIR (make sure to escape spaces!)',\n      pass: 'ok',\n      fail: 'received ' + cli.input.length,\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  logger.warn(\n    'Warning: This will approximate your Conda dependencies using PyPI. We do not yet officially support Conda. Use at your own risk.',\n  )\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleManifestConda({\n    cwd,\n    filename: String(filename),\n    out: String(out || ''),\n    outputKind,\n    verbose: Boolean(verbose),\n  })\n}\n","import path from 'node:path'\n\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { convertGradleToMaven } from './convert_gradle_to_maven.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { readOrDefaultSocketJson } from '../../utils/socketjson.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'gradle',\n  description:\n    '[beta] Use Gradle to generate a manifest file (`pom.xml`) for a Gradle/Java/Kotlin/etc project',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    bin: {\n      type: 'string',\n      description: 'Location of gradlew binary to use, default: CWD/gradlew',\n    },\n    gradleOpts: {\n      type: 'string',\n      description:\n        'Additional options to pass on to ./gradlew, see `./gradlew --help`',\n    },\n    verbose: {\n      type: 'boolean',\n      description: 'Print debug messages',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [options] [CWD=.]\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Uses gradle, preferably through your local project \\`gradlew\\`, to generate a\n    \\`pom.xml\\` file for each task. If you have no \\`gradlew\\` you can try the\n    global \\`gradle\\` binary but that may not work (hard to predict).\n\n    The \\`pom.xml\\` is a manifest file similar to \\`package.json\\` for npm or\n    or requirements.txt for PyPi), but specifically for Maven, which is Java's\n    dependency repository. Languages like Kotlin and Scala piggy back on it too.\n\n    There are some caveats with the gradle to \\`pom.xml\\` conversion:\n\n    - each task will generate its own xml file and by default it generates one xml\n      for every task. (This may be a good thing!)\n\n    - it's possible certain features don't translate well into the xml. If you\n      think something is missing that could be supported please reach out.\n\n    - it works with your \\`gradlew\\` from your repo and local settings and config\n\n    Support is beta. Please report issues or give us feedback on what's missing.\n\n    Examples\n\n      $ ${command} .\n      $ ${command} --bin=../gradlew .\n  `,\n}\n\nexport const cmdManifestGradle = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json = false, markdown = false } = cli.flags\n  let { bin, gradleOpts, verbose } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  const socketJson = await readOrDefaultSocketJson(cwd)\n\n  debugLog(\n    '[DEBUG] socket.json gradle override:',\n    socketJson?.defaults?.manifest?.gradle,\n  )\n\n  // Set defaults for any flag/arg that is not given. Check socket.json first.\n  if (!bin) {\n    if (socketJson.defaults?.manifest?.gradle?.bin) {\n      bin = socketJson.defaults?.manifest?.gradle?.bin\n      logger.info('Using default --bin from socket.json:', bin)\n    } else {\n      bin = path.join(cwd, 'gradlew')\n    }\n  }\n  if (!gradleOpts) {\n    if (socketJson.defaults?.manifest?.gradle?.gradleOpts) {\n      gradleOpts = socketJson.defaults?.manifest?.gradle?.gradleOpts\n      logger.info('Using default --gradleOpts from socket.json:', gradleOpts)\n    } else {\n      gradleOpts = ''\n    }\n  }\n  if (verbose === undefined) {\n    if (socketJson.defaults?.manifest?.gradle?.verbose !== undefined) {\n      verbose = socketJson.defaults?.manifest?.gradle?.verbose\n      logger.info('Using default --verbose from socket.json:', verbose)\n    } else {\n      verbose = false\n    }\n  }\n\n  if (verbose) {\n    logger.group('- ', parentName, config.commandName, ':')\n    logger.group('- flags:', cli.flags)\n    logger.groupEnd()\n    logger.log('- input:', cli.input)\n    logger.groupEnd()\n  }\n\n  // TODO: I'm not sure it's feasible to parse source file from stdin. We could\n  //       try, store contents in a file in some folder, target that folder... what\n  //       would the file name be?\n\n  const wasValidInput = checkCommandInput(outputKind, {\n    nook: true,\n    test: cli.input.length <= 1,\n    message: 'Can only accept one DIR (make sure to escape spaces!)',\n    pass: 'ok',\n    fail: 'received ' + cli.input.length,\n  })\n  if (!wasValidInput) {\n    return\n  }\n\n  if (verbose) {\n    logger.group()\n    logger.info('- cwd:', cwd)\n    logger.info('- gradle bin:', bin)\n    logger.groupEnd()\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await convertGradleToMaven({\n    bin: String(bin),\n    cwd,\n    gradleOpts: String(gradleOpts || '')\n      .split(' ')\n      .map(s => s.trim())\n      .filter(Boolean),\n    verbose: Boolean(verbose),\n  })\n}\n","import path from 'node:path'\n\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { convertGradleToMaven } from './convert_gradle_to_maven.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { readOrDefaultSocketJson } from '../../utils/socketjson.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\n// TODO: we may want to dedupe some pieces for all gradle languages. I think it\n//       makes sense to have separate commands for them and I think it makes\n//       sense for the help panels to note the requested language, rather than\n//       `socket manifest kotlin` to print help screens with `gradle` as the\n//       command. Room for improvement.\nconst config: CliCommandConfig = {\n  commandName: 'kotlin',\n  description:\n    '[beta] Use Gradle to generate a manifest file (`pom.xml`) for a Kotlin project',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    bin: {\n      type: 'string',\n      description: 'Location of gradlew binary to use, default: CWD/gradlew',\n    },\n    gradleOpts: {\n      type: 'string',\n      description:\n        'Additional options to pass on to ./gradlew, see `./gradlew --help`',\n    },\n    verbose: {\n      type: 'boolean',\n      description: 'Print debug messages',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [options] [CWD=.]\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Uses gradle, preferably through your local project \\`gradlew\\`, to generate a\n    \\`pom.xml\\` file for each task. If you have no \\`gradlew\\` you can try the\n    global \\`gradle\\` binary but that may not work (hard to predict).\n\n    The \\`pom.xml\\` is a manifest file similar to \\`package.json\\` for npm or\n    or requirements.txt for PyPi), but specifically for Maven, which is Java's\n    dependency repository. Languages like Kotlin and Scala piggy back on it too.\n\n    There are some caveats with the gradle to \\`pom.xml\\` conversion:\n\n    - each task will generate its own xml file and by default it generates one xml\n      for every task. (This may be a good thing!)\n\n    - it's possible certain features don't translate well into the xml. If you\n      think something is missing that could be supported please reach out.\n\n    - it works with your \\`gradlew\\` from your repo and local settings and config\n\n    Support is beta. Please report issues or give us feedback on what's missing.\n\n    Examples\n\n      $ ${command} .\n      $ ${command} --bin=../gradlew .\n  `,\n}\n\nexport const cmdManifestKotlin = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json = false, markdown = false } = cli.flags\n  let { bin, gradleOpts, verbose } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  const socketJson = await readOrDefaultSocketJson(cwd)\n\n  debugLog(\n    '[DEBUG] socket.json gradle override:',\n    socketJson?.defaults?.manifest?.gradle,\n  )\n\n  // Set defaults for any flag/arg that is not given. Check socket.json first.\n  if (!bin) {\n    if (socketJson.defaults?.manifest?.gradle?.bin) {\n      bin = socketJson.defaults?.manifest?.gradle?.bin\n      logger.info('Using default --bin from socket.json:', bin)\n    } else {\n      bin = path.join(cwd, 'gradlew')\n    }\n  }\n  if (!gradleOpts) {\n    if (socketJson.defaults?.manifest?.gradle?.gradleOpts) {\n      gradleOpts = socketJson.defaults?.manifest?.gradle?.gradleOpts\n      logger.info('Using default --gradleOpts from socket.json:', gradleOpts)\n    } else {\n      gradleOpts = ''\n    }\n  }\n  if (verbose === undefined) {\n    if (socketJson.defaults?.manifest?.gradle?.verbose !== undefined) {\n      verbose = socketJson.defaults?.manifest?.gradle?.verbose\n      logger.info('Using default --verbose from socket.json:', verbose)\n    } else {\n      verbose = false\n    }\n  }\n\n  if (verbose) {\n    logger.group('- ', parentName, config.commandName, ':')\n    logger.group('- flags:', cli.flags)\n    logger.groupEnd()\n    logger.log('- input:', cli.input)\n    logger.groupEnd()\n  }\n\n  // TODO: I'm not sure it's feasible to parse source file from stdin. We could\n  //       try, store contents in a file in some folder, target that folder... what\n  //       would the file name be?\n\n  const wasValidInput = checkCommandInput(outputKind, {\n    nook: true,\n    test: cli.input.length <= 1,\n    message: 'Can only accept one DIR (make sure to escape spaces!)',\n    pass: 'ok',\n    fail: 'received ' + cli.input.length,\n  })\n  if (!wasValidInput) {\n    return\n  }\n\n  if (verbose) {\n    logger.group()\n    logger.info('- cwd:', cwd)\n    logger.info('- gradle bin:', bin)\n    logger.groupEnd()\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await convertGradleToMaven({\n    bin: String(bin),\n    cwd,\n    gradleOpts: String(gradleOpts || '')\n      .split(' ')\n      .map(s => s.trim())\n      .filter(Boolean),\n    verbose: Boolean(verbose),\n  })\n}\n","import path from 'node:path'\n\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { convertSbtToMaven } from './convert_sbt_to_maven.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { readOrDefaultSocketJson } from '../../utils/socketjson.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'scala',\n  description:\n    \"[beta] Generate a manifest file (`pom.xml`) from Scala's `build.sbt` file\",\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    bin: {\n      type: 'string',\n      description: 'Location of sbt binary to use',\n    },\n    out: {\n      type: 'string',\n      description:\n        'Path of output file; where to store the resulting manifest, see also --stdout',\n    },\n    stdout: {\n      type: 'boolean',\n      description: 'Print resulting pom.xml to stdout (supersedes --out)',\n    },\n    sbtOpts: {\n      type: 'string',\n      description: 'Additional options to pass on to sbt, as per `sbt --help`',\n    },\n    verbose: {\n      type: 'boolean',\n      description: 'Print debug messages',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [options] [CWD=.]\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Uses \\`sbt makePom\\` to generate a \\`pom.xml\\` from your \\`build.sbt\\` file.\n    This xml file is the dependency manifest (like a package.json\n    for Node.js or requirements.txt for PyPi), but specifically for Scala.\n\n    There are some caveats with \\`build.sbt\\` to \\`pom.xml\\` conversion:\n\n    - the xml is exported as socket.pom.xml as to not confuse existing build tools\n      but it will first hit your /target/sbt<version> folder (as a different name)\n\n    - the pom.xml format (standard by Scala) does not support certain sbt features\n      - \\`excludeAll()\\`, \\`dependencyOverrides\\`, \\`force()\\`, \\`relativePath\\`\n      - For details: https://www.scala-sbt.org/1.x/docs/Library-Management.html\n\n    - it uses your sbt settings and local configuration verbatim\n\n    - it can only export one target per run, so if you have multiple targets like\n      development and production, you must run them separately.\n\n    You can specify --bin to override the path to the \\`sbt\\` binary to invoke.\n\n    Support is beta. Please report issues or give us feedback on what's missing.\n\n    This is only for SBT. If your Scala setup uses gradle, please see the help\n    sections for \\`socket manifest gradle\\` or \\`socket cdxgen\\`.\n\n    Examples\n\n      $ ${command}\n      $ ${command} ./proj --bin=/usr/bin/sbt --file=boot.sbt\n  `,\n}\n\nexport const cmdManifestScala = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json = false, markdown = false } = cli.flags\n  let { bin, out, sbtOpts, stdout, verbose } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  const socketJson = await readOrDefaultSocketJson(cwd)\n\n  debugLog(\n    '[DEBUG] socket.json sbt override:',\n    socketJson?.defaults?.manifest?.sbt,\n  )\n\n  // Set defaults for any flag/arg that is not given. Check socket.json first.\n  if (!bin) {\n    if (socketJson.defaults?.manifest?.sbt?.bin) {\n      bin = socketJson.defaults?.manifest?.sbt?.bin\n      logger.info('Using default --bin from socket.json:', bin)\n    } else {\n      bin = 'sbt'\n    }\n  }\n  if (\n    stdout === undefined &&\n    socketJson.defaults?.manifest?.sbt?.stdout !== undefined\n  ) {\n    stdout = socketJson.defaults?.manifest?.sbt?.stdout\n    logger.info('Using default --stdout from socket.json:', stdout)\n  }\n  if (stdout) {\n    out = '-'\n  } else if (!out) {\n    if (socketJson.defaults?.manifest?.sbt?.outfile) {\n      out = socketJson.defaults?.manifest?.sbt?.outfile\n      logger.info('Using default --out from socket.json:', out)\n    } else {\n      out = './socket.pom.xml'\n    }\n  }\n  if (!sbtOpts) {\n    if (socketJson.defaults?.manifest?.sbt?.sbtOpts) {\n      sbtOpts = socketJson.defaults?.manifest?.sbt?.sbtOpts\n      logger.info('Using default --sbtOpts from socket.json:', sbtOpts)\n    } else {\n      sbtOpts = ''\n    }\n  }\n  if (\n    verbose === undefined &&\n    socketJson.defaults?.manifest?.sbt?.verbose !== undefined\n  ) {\n    verbose = socketJson.defaults?.manifest?.sbt?.verbose\n    logger.info('Using default --verbose from socket.json:', verbose)\n  } else if (verbose === undefined) {\n    verbose = false\n  }\n\n  if (verbose) {\n    logger.group('- ', parentName, config.commandName, ':')\n    logger.group('- flags:', cli.flags)\n    logger.groupEnd()\n    logger.log('- input:', cli.input)\n    logger.groupEnd()\n  }\n\n  // TODO: I'm not sure it's feasible to parse source file from stdin. We could\n  //       try, store contents in a file in some folder, target that folder... what\n  //       would the file name be?\n\n  const wasValidInput = checkCommandInput(outputKind, {\n    nook: true,\n    test: cli.input.length <= 1,\n    message: 'Can only accept one DIR (make sure to escape spaces!)',\n    pass: 'ok',\n    fail: 'received ' + cli.input.length,\n  })\n  if (!wasValidInput) {\n    return\n  }\n\n  if (verbose) {\n    logger.group()\n    logger.log('- target:', cwd)\n    logger.log('- sbt bin:', bin)\n    logger.log('- out:', out)\n    logger.groupEnd()\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await convertSbtToMaven({\n    bin: String(bin),\n    cwd: cwd,\n    out: String(out),\n    sbtOpts: String(sbtOpts)\n      .split(' ')\n      .map(s => s.trim())\n      .filter(Boolean),\n    verbose: Boolean(verbose),\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\n\nimport type { CResult } from '../../types.mts'\n\nexport async function outputManifestSetup(result: CResult<unknown>) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.success('Setup complete')\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { input, select } from '@socketsecurity/registry/lib/prompts'\n\nimport { detectManifestActions } from './detect-manifest-actions.mts'\nimport { readSocketJson, writeSocketJson } from '../../utils/socketjson.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketJson } from '../../utils/socketjson.mts'\n\nexport async function setupManifestConfig(\n  cwd: string,\n  defaultOnReadError = false,\n): Promise<CResult<unknown>> {\n  const detected = await detectManifestActions(null, cwd)\n  debugLog('[DEBUG]', detected)\n\n  // - repeat\n  //   - give the user an option to configure one of the supported targets\n  //   - run through an interactive prompt for selected target\n  //   - each target will have its own specific options\n  //   - record them to the socket.yml (or socket-cli.yml ? or just socket.json ?)\n\n  const jsonPath = path.join(cwd, `socket.json`)\n  if (fs.existsSync(jsonPath)) {\n    logger.info(`Found socket.json at ${jsonPath}`)\n  } else {\n    logger.info(`No socket.json found at ${cwd}, will generate a new one`)\n  }\n\n  logger.log('')\n  logger.log(\n    'Note: This tool will set up flag and argument defaults for certain',\n  )\n  logger.log('      CLI commands. You can still override them by explicitly')\n  logger.log('      setting the flag. It is meant to be a convenience tool.')\n  logger.log('')\n  logger.log(\n    'This command will generate a `socket.json` file in the target cwd.',\n  )\n  logger.log('You can choose to add this file to your repo (handy for collab)')\n  logger.log('or to add it to the ignored files, or neither. This file is only')\n  logger.log('used in CLI workflows.')\n  logger.log('')\n\n  const choices = [\n    {\n      name: 'Conda'.padEnd(30, ' '),\n      value: 'conda',\n      description: 'Generate requirements.txt from a Conda environment.yml',\n    },\n    {\n      name: 'Gradle'.padEnd(30, ' '),\n      value: 'gradle',\n      description: 'Generate pom.xml files through gradle',\n    },\n    {\n      name: 'Kotlin (gradle)'.padEnd(30, ' '),\n      value: 'gradle',\n      description: 'Generate pom.xml files (for Kotlin) through gradle',\n    },\n    {\n      name: 'Scala (gradle)'.padEnd(30, ' '),\n      value: 'gradle',\n      description: 'Generate pom.xml files (for Scala) through gradle',\n    },\n    {\n      name: 'Scala (sbt)'.padEnd(30, ' '),\n      value: 'sbt',\n      description: 'Generate pom.xml files through sbt',\n    },\n  ]\n\n  choices.forEach(obj => {\n    if (detected[obj.value as keyof typeof detected]) {\n      obj.name += ' [detected]'\n    }\n  })\n\n  // Surface detected language first, then by alphabet\n  choices.sort((a, b) => {\n    if (\n      detected[a.value as keyof typeof detected] &&\n      !detected[b.value as keyof typeof detected]\n    ) {\n      return -1\n    }\n    if (\n      !detected[a.value as keyof typeof detected] &&\n      detected[b.value as keyof typeof detected]\n    ) {\n      return 1\n    }\n    return a.value < b.value ? -1 : a.value > b.value ? 1 : 0\n  })\n\n  // Make exit the last entry...\n  choices.push({\n    name: 'None, exit configurator',\n    value: '',\n    description: 'Exit setup',\n  })\n\n  // TODO: use detected to list those first\n  const targetEco = (await select({\n    message: 'Select eco system manifest generator to configure',\n    choices,\n  })) as string | null\n\n  const socketJsonResult = await readSocketJson(cwd, defaultOnReadError)\n  if (!socketJsonResult.ok) {\n    return socketJsonResult\n  }\n  const socketJson = socketJsonResult.data\n\n  if (!socketJson.defaults) {\n    socketJson.defaults = {}\n  }\n  if (!socketJson.defaults.manifest) {\n    socketJson.defaults.manifest = {}\n  }\n\n  let result: CResult<{ canceled: boolean }>\n  switch (targetEco) {\n    case 'conda': {\n      if (!socketJson.defaults.manifest.conda) {\n        socketJson.defaults.manifest.conda = {}\n      }\n      result = await setupConda(socketJson.defaults.manifest.conda)\n      break\n    }\n    case 'gradle': {\n      if (!socketJson.defaults.manifest.gradle) {\n        socketJson.defaults.manifest.gradle = {}\n      }\n      result = await setupGradle(socketJson.defaults.manifest.gradle)\n      break\n    }\n    case 'sbt': {\n      if (!socketJson.defaults.manifest.sbt) {\n        socketJson.defaults.manifest.sbt = {}\n      }\n      result = await setupSbt(socketJson.defaults.manifest.sbt)\n      break\n    }\n    default: {\n      result = canceledByUser()\n    }\n  }\n\n  if (!result.ok || result.data.canceled) {\n    return result\n  }\n\n  logger.log('')\n  logger.log('Setup complete. Writing socket.json')\n  logger.log('')\n\n  if (\n    await select({\n      message: `Do you want to write the new config to ${jsonPath} ?`,\n      choices: [\n        {\n          name: 'yes',\n          value: true,\n          description: 'Update config',\n        },\n        {\n          name: 'no',\n          value: false,\n          description: 'Do not update the config',\n        },\n      ],\n    })\n  ) {\n    return await writeSocketJson(cwd, socketJson)\n  }\n\n  return canceledByUser()\n}\n\nasync function setupConda(\n  config: NonNullable<\n    NonNullable<NonNullable<SocketJson['defaults']>['manifest']>['conda']\n  >,\n): Promise<CResult<{ canceled: boolean }>> {\n  const on = await askForEnabled(!config.disabled)\n  if (on === undefined) {\n    return canceledByUser()\n  } else if (on) {\n    delete config.disabled\n  } else {\n    config.disabled = true\n  }\n\n  const inf = await askForInputFile(config.infile || 'environment.yml')\n  if (inf === undefined) {\n    return canceledByUser()\n  } else if (inf.trim() === '-') {\n    config.stdin = true\n  } else {\n    delete config.stdin\n    if (inf.trim()) {\n      config.infile = inf.trim()\n    } else {\n      delete config.infile\n    }\n  }\n\n  const stdout = await askForStdout(config.stdout)\n  if (stdout === undefined) {\n    return canceledByUser()\n  } else if (stdout === 'yes') {\n    config.stdout = true\n  } else if (stdout === 'no') {\n    config.stdout = false\n  } else {\n    delete config.stdout\n  }\n\n  if (!config.stdout) {\n    const out = await askForOutputFile(config.outfile || 'requirements.txt')\n    if (out === undefined) {\n      return canceledByUser()\n    } else if (out === '-') {\n      config.stdout = true\n    } else {\n      delete config.stdout\n      if (out?.trim()) {\n        config.outfile = out.trim()\n      } else {\n        delete config.outfile\n      }\n    }\n  }\n\n  const verbose = await askForVerboseFlag(config.verbose)\n  if (verbose === undefined) {\n    return canceledByUser()\n  } else if (verbose === 'yes' || verbose === 'no') {\n    config.verbose = verbose === 'yes'\n  } else {\n    delete config.verbose\n  }\n\n  return notCanceled()\n}\n\nasync function setupGradle(\n  config: NonNullable<\n    NonNullable<NonNullable<SocketJson['defaults']>['manifest']>['gradle']\n  >,\n): Promise<CResult<{ canceled: boolean }>> {\n  const bin = await askForBin(config.bin || './gradlew')\n  if (bin === undefined) {\n    return canceledByUser()\n  } else if (bin.trim()) {\n    config.bin = bin.trim()\n  } else {\n    delete config.bin\n  }\n\n  const opts = await input({\n    message: '(--gradleOpts) Enter gradle options to pass through',\n    default: config.gradleOpts || '',\n    required: false,\n    // validate: async string => bool\n  })\n  if (opts === undefined) {\n    return canceledByUser()\n  } else if (opts.trim()) {\n    config.gradleOpts = opts.trim()\n  } else {\n    delete config.gradleOpts\n  }\n\n  const verbose = await askForVerboseFlag(config.verbose)\n  if (verbose === undefined) {\n    return canceledByUser()\n  } else if (verbose === 'yes' || verbose === 'no') {\n    config.verbose = verbose === 'yes'\n  } else {\n    delete config.verbose\n  }\n\n  return notCanceled()\n}\n\nasync function setupSbt(\n  config: NonNullable<\n    NonNullable<NonNullable<SocketJson['defaults']>['manifest']>['sbt']\n  >,\n): Promise<CResult<{ canceled: boolean }>> {\n  const bin = await askForBin(config.bin || 'sbt')\n  if (bin === undefined) {\n    return canceledByUser()\n  } else if (bin.trim()) {\n    config.bin = bin.trim()\n  } else {\n    delete config.bin\n  }\n\n  const opts = await input({\n    message: '(--sbtOpts) Enter sbt options to pass through',\n    default: config.sbtOpts || '',\n    required: false,\n    // validate: async string => bool\n  })\n  if (opts === undefined) {\n    return canceledByUser()\n  } else if (opts.trim()) {\n    config.sbtOpts = opts.trim()\n  } else {\n    delete config.sbtOpts\n  }\n\n  const stdout = await askForStdout(config.stdout)\n  if (stdout === undefined) {\n    return canceledByUser()\n  } else if (stdout === 'yes') {\n    config.stdout = true\n  } else if (stdout === 'no') {\n    config.stdout = false\n  } else {\n    delete config.stdout\n  }\n\n  if (config.stdout !== true) {\n    const out = await askForOutputFile(config.outfile || 'sbt.pom.xml')\n    if (out === undefined) {\n      return canceledByUser()\n    } else if (out === '-') {\n      config.stdout = true\n    } else {\n      delete config.stdout\n      if (out?.trim()) {\n        config.outfile = out.trim()\n      } else {\n        delete config.outfile\n      }\n    }\n  }\n\n  const verbose = await askForVerboseFlag(config.verbose)\n  if (verbose === undefined) {\n    return canceledByUser()\n  } else if (verbose === 'yes' || verbose === 'no') {\n    config.verbose = verbose === 'yes'\n  } else {\n    delete config.verbose\n  }\n\n  return notCanceled()\n}\n\nasync function askForStdout(\n  defaultValue: boolean | undefined,\n): Promise<string | undefined> {\n  return await select({\n    message: '(--stdout) Print the resulting pom.xml to stdout?',\n    choices: [\n      {\n        name: 'no',\n        value: 'no',\n        description: 'Write output to a file, not stdout',\n      },\n      {\n        name: 'yes',\n        value: 'yes',\n        description: 'Print in stdout (this will supersede --out)',\n      },\n      {\n        name: '(leave default)',\n        value: '',\n        description: 'Do not store a setting for this',\n      },\n    ],\n    default: defaultValue === true ? 'yes' : defaultValue === false ? 'no' : '',\n  })\n}\n\nasync function askForEnabled(\n  defaultValue: boolean | undefined,\n): Promise<boolean | undefined> {\n  return await select({\n    message:\n      'Do you want to enable or disable auto generating manifest files for this language in this dir?',\n    choices: [\n      {\n        name: 'Enable',\n        value: true,\n        description: 'Generate manifest files for this language when detected',\n      },\n      {\n        name: 'Disable',\n        value: false,\n        description:\n          'Do not generate manifest files for this language when detected, unless explicitly asking for it',\n      },\n      {\n        name: 'Cancel',\n        value: undefined,\n        description: 'Exit configurator',\n      },\n    ],\n    default:\n      defaultValue === true\n        ? 'enable'\n        : defaultValue === false\n          ? 'disable'\n          : '',\n  })\n}\n\nasync function askForInputFile(defaultName = ''): Promise<string | undefined> {\n  return await input({\n    message:\n      '(--file) What should be the default file name to read? Should be an absolute path or relative to the cwd. Use `-` to read from stdin instead.' +\n      (defaultName ? ' (Backspace to leave default)' : ''),\n    default: defaultName,\n    required: false,\n    // validate: async string => bool\n  })\n}\n\nasync function askForOutputFile(defaultName = ''): Promise<string | undefined> {\n  return await input({\n    message:\n      '(--out) What should be the default output file? Should be absolute path or relative to cwd.' +\n      (defaultName ? ' (Backspace to leave default)' : ''),\n    default: defaultName,\n    required: false,\n    // validate: async string => bool\n  })\n}\n\nasync function askForBin(defaultName = ''): Promise<string | undefined> {\n  return await input({\n    message:\n      '(--bin) What should be the command to execute? Usually your build binary.' +\n      (defaultName ? ' (Backspace to leave default)' : ''),\n    default: defaultName,\n    required: false,\n    // validate: async string => bool\n  })\n}\n\nasync function askForVerboseFlag(\n  current: boolean | undefined,\n): Promise<string | undefined> {\n  return await select({\n    message: '(--verbose) Should this run in verbose mode by default?',\n    choices: [\n      {\n        name: 'no',\n        value: 'no',\n        description: 'Do not run this manifest in verbose mode',\n      },\n      {\n        name: 'yes',\n        value: 'yes',\n        description: 'Run this manifest in verbose mode',\n      },\n      {\n        name: '(leave default)',\n        value: '',\n        description: 'Do not store a setting for this',\n      },\n    ],\n    default: current === true ? 'yes' : current === false ? 'no' : '',\n  })\n}\n\nfunction canceledByUser(): CResult<{ canceled: boolean }> {\n  logger.log('')\n  logger.info('User canceled')\n  logger.log('')\n  return { ok: true, data: { canceled: true } }\n}\n\nfunction notCanceled(): CResult<{ canceled: boolean }> {\n  return { ok: true, data: { canceled: false } }\n}\n","import { outputManifestSetup } from './output-manifest-setup.mts'\nimport { setupManifestConfig } from './setup-manifest-config.mts'\n\nexport async function handleManifestSetup(\n  cwd: string,\n  defaultOnReadError: boolean,\n): Promise<void> {\n  const result = await setupManifestConfig(cwd, defaultOnReadError)\n\n  await outputManifestSetup(result)\n}\n","import path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleManifestSetup } from './handle-manifest-setup.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'setup',\n  description:\n    'Start interactive configurator to customize default flag values for `socket manifest` in this dir',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    defaultOnReadError: {\n      type: 'boolean',\n      description:\n        'If reading the socket.json fails, just use a default config? Warning: This might override the existing json file!',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [CWD=.]\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    This command will try to detect all supported ecosystems in given CWD. Then\n    it starts a configurator where you can setup default values for certain flags\n    when creating manifest files in that dir. These configuration details are\n    then stored in a local \\`socket.json\\` file (which you may or may not commit\n    to the repo). Next time you run \\`socket manifest ...\\` it will load this\n    json file and any flags which are not explicitly set in the command but which\n    have been registered in the json file will get the default value set to that\n    value you stored rather than the hardcoded defaults.\n\n    This helps with for example when your build binary is in a particular path\n    or when your build tool needs specific opts and you don't want to specify\n    them when running the command every time.\n\n    You can also disable manifest generation for certain ecosystems.\n\n    This generated configuration file will only be used locally by the CLI. You\n    can commit it to the repo (useful for collaboration) or choose to add it to\n    your .gitignore all the same. Only this CLI will use it.\n\n    Examples\n\n      $ ${command}\n      $ ${command} ./proj\n  `,\n}\n\nexport const cmdManifestSetup = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n  const { defaultOnReadError = false } = cli.flags\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleManifestSetup(cwd, Boolean(defaultOnReadError))\n}\n","import { cmdManifestAuto } from './cmd-manifest-auto.mts'\nimport { cmdManifestCdxgen } from './cmd-manifest-cdxgen.mts'\nimport { cmdManifestConda } from './cmd-manifest-conda.mts'\nimport { cmdManifestGradle } from './cmd-manifest-gradle.mts'\nimport { cmdManifestKotlin } from './cmd-manifest-kotlin.mts'\nimport { cmdManifestScala } from './cmd-manifest-scala.mts'\nimport { cmdManifestSetup } from './cmd-manifest-setup.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst config: CliCommandConfig = {\n  commandName: 'manifest',\n  description: 'Generate a dependency manifest for given file or dir',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <language> <target>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Generates a declarative dependency manifest (like a package.json for Node.JS\n    or requirements.txt for PyPi), but for certain supported ecosystems\n    where it's common to use a dynamic manifest, like Scala's sbt.\n\n    Only certain languages are supported and there may be language specific\n    configurations available. See \\`manifest <language> --help\\` for usage details\n    per language.\n\n    Currently supported language: scala [beta], gradle [beta], kotlin (through\n    gradle) [beta].\n\n    Examples\n\n      $ ${command} scala .\n\n    To have it auto-detect and attempt to run:\n\n      $ ${command} yolo\n  `,\n}\n\nexport const cmdManifest = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  await meowWithSubcommands(\n    {\n      auto: cmdManifestAuto,\n      cdxgen: cmdManifestCdxgen,\n      conda: cmdManifestConda,\n      gradle: cmdManifestGradle,\n      kotlin: cmdManifestKotlin,\n      scala: cmdManifestScala,\n      setup: cmdManifestSetup,\n    },\n    {\n      argv,\n      aliases: {\n        yolo: {\n          description: config.description,\n          hidden: true,\n          argv: ['auto'],\n        },\n      },\n      description: config.description,\n      importMeta,\n      flags: config.flags,\n      name: `${parentName} ${config.commandName}`,\n    },\n  )\n}\n","import { createRequire } from 'node:module'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst require = createRequire(import.meta.url)\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'npm',\n  description: `npm wrapper functionality`,\n  hidden: false,\n  flags: {\n    ...commonFlags,\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}\n  `,\n}\n\nexport const cmdNpm = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    allowUnknownFlags: true,\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  // Lazily access constants.shadowNpmBinPath.\n  const shadowBin = require(constants.shadowNpmBinPath)\n  await shadowBin('npm', argv)\n}\n","import { createRequire } from 'node:module'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst require = createRequire(import.meta.url)\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'npx',\n  description: `npx wrapper functionality`,\n  hidden: false,\n  flags: {\n    ...commonFlags,\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}\n  `,\n}\n\nexport const cmdNpx = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    allowUnknownFlags: true,\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  // Lazily access constants.shadowNpmBinPath.\n  const shadowBin = require(constants.shadowNpmBinPath)\n  await shadowBin('npx', argv)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'oops',\n  description: 'Trigger an intentional error (for development)',\n  hidden: true,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    throw: {\n      type: 'boolean',\n      default: false,\n      description:\n        'Throw an explicit error even if --json or --markdown are set',\n    },\n  },\n  help: (parentName, config) => `\n    Usage\n      $ ${parentName} ${config.commandName}\n\n    Don't run me.\n  `,\n}\n\nexport const cmdOops = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json, markdown, throw: justThrow } = cli.flags\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  if (json && !justThrow) {\n    process.exitCode = 1\n    logger.log(\n      serializeResultJson({\n        ok: false,\n        message: 'Oops',\n        cause: 'This error was intentionally left blank',\n      }),\n    )\n  }\n\n  if (markdown && !justThrow) {\n    process.exitCode = 1\n    logger.fail(\n      failMsgWithBadge('Oops', 'This error was intentionally left blank'),\n    )\n    return\n  }\n\n  throw new Error('This error was intentionally left blank')\n}\n","import constants from '../../constants.mts'\n\nimport type { Agent } from '../../utils/package-environment.mts'\n\ntype AgentDepsIncludesFn = (stdout: string, name: string) => boolean\n\nconst { BUN, NPM, PNPM, VLT, YARN_BERRY, YARN_CLASSIC } = constants\n\nfunction matchLsCmdViewHumanStdout(stdout: string, name: string) {\n  return stdout.includes(` ${name}@`)\n}\n\nfunction matchQueryCmdStdout(stdout: string, name: string) {\n  return stdout.includes(`\"${name}\"`)\n}\n\nexport const depsIncludesByAgent = new Map<Agent, AgentDepsIncludesFn>([\n  [BUN, matchLsCmdViewHumanStdout],\n  [NPM, matchQueryCmdStdout],\n  [PNPM, matchQueryCmdStdout],\n  [VLT, matchQueryCmdStdout],\n  [YARN_BERRY, matchLsCmdViewHumanStdout],\n  [YARN_CLASSIC, matchLsCmdViewHumanStdout],\n])\n","import type { EnvDetails } from '../../utils/package-environment.mts'\n\nexport function getDependencyEntries(pkgEnvDetails: EnvDetails) {\n  const {\n    dependencies,\n    devDependencies,\n    optionalDependencies,\n    peerDependencies,\n  } = pkgEnvDetails.editablePkgJson.content\n  return [\n    [\n      'dependencies',\n      dependencies ? { __proto__: null, ...dependencies } : undefined,\n    ],\n    [\n      'devDependencies',\n      devDependencies ? { __proto__: null, ...devDependencies } : undefined,\n    ],\n    [\n      'peerDependencies',\n      peerDependencies ? { __proto__: null, ...peerDependencies } : undefined,\n    ],\n    [\n      'optionalDependencies',\n      optionalDependencies\n        ? { __proto__: null, ...optionalDependencies }\n        : undefined,\n    ],\n  ].filter(({ 1: o }) => o) as Array<[string, NonNullable<typeof dependencies>]>\n}\n","import constants from '../../constants.mts'\n\nimport type { NpmOverrides, Overrides, PnpmOrYarnOverrides } from './types.mts'\nimport type { Agent, EnvDetails } from '../../utils/package-environment.mts'\n\nconst {\n  BUN,\n  NPM,\n  OVERRIDES,\n  PNPM,\n  RESOLUTIONS,\n  VLT,\n  YARN_BERRY,\n  YARN_CLASSIC,\n} = constants\n\nfunction getOverridesDataBun(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    pkgEnvDetails.editablePkgJson.content?.[RESOLUTIONS] ??\n    ({} as PnpmOrYarnOverrides)\n  return { type: YARN_BERRY, overrides }\n}\n\n// npm overrides documentation:\n// https://docs.npmjs.com/cli/v10/configuring-npm/package-json#overrides\nfunction getOverridesDataNpm(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    pkgEnvDetails.editablePkgJson.content?.[OVERRIDES] ?? ({} as NpmOverrides)\n  return { type: NPM, overrides }\n}\n\n// pnpm overrides documentation:\n// https://pnpm.io/package_json#pnpmoverrides\nfunction getOverridesDataPnpm(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    (pkgEnvDetails.editablePkgJson.content as any)?.[PNPM]?.[OVERRIDES] ??\n    ({} as PnpmOrYarnOverrides)\n  return { type: PNPM, overrides }\n}\n\nfunction getOverridesDataVlt(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    pkgEnvDetails.editablePkgJson.content?.[OVERRIDES] ?? ({} as NpmOverrides)\n  return { type: VLT, overrides }\n}\n\n// Yarn resolutions documentation:\n// https://yarnpkg.com/configuration/manifest#resolutions\nfunction getOverridesDataYarn(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    pkgEnvDetails.editablePkgJson.content?.[RESOLUTIONS] ??\n    ({} as PnpmOrYarnOverrides)\n  return { type: YARN_BERRY, overrides }\n}\n\n// Yarn resolutions documentation:\n// https://classic.yarnpkg.com/en/docs/selective-version-resolutions\nfunction getOverridesDataYarnClassic(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    pkgEnvDetails.editablePkgJson.content?.[RESOLUTIONS] ??\n    ({} as PnpmOrYarnOverrides)\n  return { type: YARN_CLASSIC, overrides }\n}\n\nexport type GetOverrides = (pkgEnvDetails: EnvDetails) => GetOverridesResult\n\nexport type GetOverridesResult = { type: Agent; overrides: Overrides }\n\nexport const overridesDataByAgent = new Map<Agent, GetOverrides>([\n  [BUN, getOverridesDataBun],\n  [NPM, getOverridesDataNpm],\n  [PNPM, getOverridesDataPnpm],\n  [VLT, getOverridesDataVlt],\n  [YARN_BERRY, getOverridesDataYarn],\n  [YARN_CLASSIC, getOverridesDataYarnClassic],\n] as ReadonlyArray<[Agent, GetOverrides]>)\n","import { escapeRegExp } from '@socketsecurity/registry/lib/regexps'\n\nimport constants from '../../constants.mts'\n\nimport type { Agent } from '../../utils/package-environment.mts'\n\nexport type AgentLockIncludesFn = (\n  lockSrc: string,\n  name: string,\n  ext?: string | undefined,\n) => boolean\n\nconst { BUN, LOCK_EXT, NPM, PNPM, VLT, YARN_BERRY, YARN_CLASSIC } = constants\n\nfunction includesNpm(lockSrc: string, name: string) {\n  // Detects the package name in the following cases:\n  //   \"name\":\n  return lockSrc.includes(`\"${name}\":`)\n}\n\nfunction includesBun(lockSrc: string, name: string, lockName?: string) {\n  // This is a bit counterintuitive. When lockName ends with a .lockb\n  // we treat it as a yarn.lock. When lockName ends with a .lock we\n  // treat it as a package-lock.json. The bun.lock format is not identical\n  // package-lock.json, however it close enough for npmLockIncludes to work.\n  const lockfileScanner = lockName?.endsWith(LOCK_EXT)\n    ? includesNpm\n    : includesYarn\n  return lockfileScanner(lockSrc, name)\n}\n\nfunction includesPnpm(lockSrc: string, name: string) {\n  const escapedName = escapeRegExp(name)\n  return new RegExp(\n    // Detects the package name.\n    // v9.0 and v6.0 lockfile patterns:\n    //   'name'\n    //   name:\n    //   name@\n    // v6.0 lockfile patterns:\n    //   /name@\n    `(?<=^\\\\s*)(?:'${escapedName}'|/?${escapedName}(?=[:@]))`,\n    'm',\n  ).test(lockSrc)\n}\n\nfunction includesVlt(lockSrc: string, name: string) {\n  // Detects the package name in the following cases:\n  //   \"name\"\n  return lockSrc.includes(`\"${name}\"`)\n}\n\nfunction includesYarn(lockSrc: string, name: string) {\n  const escapedName = escapeRegExp(name)\n  return new RegExp(\n    // Detects the package name in the following cases:\n    //   \"name@\n    //   , \"name@\n    //   name@\n    //   , name@\n    `(?<=(?:^\\\\s*|,\\\\s*)\"?)${escapedName}(?=@)`,\n    'm',\n  ).test(lockSrc)\n}\n\nexport const lockfileIncludesByAgent = new Map<Agent, AgentLockIncludesFn>([\n  [BUN, includesBun],\n  [NPM, includesNpm],\n  [PNPM, includesPnpm],\n  [VLT, includesVlt],\n  [YARN_BERRY, includesYarn],\n  [YARN_CLASSIC, includesYarn],\n])\n","import { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\n\nimport type { Agent, EnvDetails } from '../../utils/package-environment.mts'\n\nconst { BUN, NPM, PNPM, VLT, YARN_BERRY, YARN_CLASSIC } = constants\n\nfunction cleanupQueryStdout(stdout: string): string {\n  if (stdout === '') {\n    return ''\n  }\n  let pkgs\n  try {\n    pkgs = JSON.parse(stdout)\n  } catch {}\n  if (!Array.isArray(pkgs) || !pkgs.length) {\n    return ''\n  }\n  const names = new Set<string>()\n  for (const { _id, name, pkgid } of pkgs) {\n    // `npm query` results may not have a \"name\" property, in which case we\n    // fallback to \"_id\" and then \"pkgid\".\n    // `vlt ls --view json` results always have a \"name\" property.\n    const fallback = _id ?? pkgid ?? ''\n    const resolvedName = name ?? fallback.slice(0, fallback.indexOf('@', 1))\n    // Add package names, except for those under the `@types` scope as those\n    // are known to only be dev dependencies.\n    if (resolvedName && !resolvedName.startsWith('@types/')) {\n      names.add(resolvedName)\n    }\n  }\n  return JSON.stringify([...names], null, 2)\n}\n\nfunction parsableToQueryStdout(stdout: string) {\n  if (stdout === '') {\n    return ''\n  }\n  // Convert the parsable stdout into a json array of unique names.\n  // The matchAll regexp looks for a forward (posix) or backward (win32) slash\n  // and matches one or more non-slashes until the newline.\n  const names = new Set(stdout.matchAll(/(?<=[/\\\\])[^/\\\\]+(?=\\n)/g))\n  return JSON.stringify([...names], null, 2)\n}\n\nasync function npmQuery(npmExecPath: string, cwd: string): Promise<string> {\n  let stdout = ''\n  try {\n    stdout = (\n      await spawn(npmExecPath, ['query', ':not(.dev)'], {\n        cwd,\n        // Lazily access constants.WIN32.\n        shell: constants.WIN32,\n      })\n    ).stdout.trim()\n  } catch {}\n  return cleanupQueryStdout(stdout)\n}\n\nasync function lsBun(pkgEnvDetails: EnvDetails, cwd: string): Promise<string> {\n  try {\n    // Bun does not support filtering by production packages yet.\n    // https://github.com/oven-sh/bun/issues/8283\n    return (\n      await spawn(pkgEnvDetails.agentExecPath, ['pm', 'ls', '--all'], {\n        cwd,\n        // Lazily access constants.WIN32.\n        shell: constants.WIN32,\n      })\n    ).stdout.trim()\n  } catch {}\n  return ''\n}\n\nasync function lsNpm(pkgEnvDetails: EnvDetails, cwd: string): Promise<string> {\n  return await npmQuery(pkgEnvDetails.agentExecPath, cwd)\n}\n\nasync function lsPnpm(\n  pkgEnvDetails: EnvDetails,\n  cwd: string,\n  options?: AgentListDepsOptions | undefined,\n): Promise<string> {\n  const npmExecPath = options?.npmExecPath\n  if (npmExecPath && npmExecPath !== NPM) {\n    const result = await npmQuery(npmExecPath, cwd)\n    if (result) {\n      return result\n    }\n  }\n  let stdout = ''\n  try {\n    stdout = (\n      await spawn(\n        pkgEnvDetails.agentExecPath,\n        // Pnpm uses the alternative spelling of parsable.\n        // https://en.wiktionary.org/wiki/parsable\n        ['ls', '--parseable', '--prod', '--depth', 'Infinity'],\n        {\n          cwd,\n          // Lazily access constants.WIN32.\n          shell: constants.WIN32,\n        },\n      )\n    ).stdout.trim()\n  } catch {}\n  return parsableToQueryStdout(stdout)\n}\n\nasync function lsVlt(pkgEnvDetails: EnvDetails, cwd: string): Promise<string> {\n  let stdout = ''\n  try {\n    // See https://docs.vlt.sh/cli/commands/list#options.\n    stdout = (\n      await spawn(\n        pkgEnvDetails.agentExecPath,\n        ['ls', '--view', 'human', ':not(.dev)'],\n        {\n          cwd,\n          // Lazily access constants.WIN32.\n          shell: constants.WIN32,\n        },\n      )\n    ).stdout.trim()\n  } catch {}\n  return cleanupQueryStdout(stdout)\n}\n\nasync function lsYarnBerry(\n  pkgEnvDetails: EnvDetails,\n  cwd: string,\n): Promise<string> {\n  try {\n    return (\n      // Yarn Berry does not support filtering by production packages yet.\n      // https://github.com/yarnpkg/berry/issues/5117\n      (\n        await spawn(\n          pkgEnvDetails.agentExecPath,\n          ['info', '--recursive', '--name-only'],\n          {\n            cwd,\n            // Lazily access constants.WIN32.\n            shell: constants.WIN32,\n          },\n        )\n      ).stdout.trim()\n    )\n  } catch {}\n  return ''\n}\n\nasync function lsYarnClassic(\n  pkgEnvDetails: EnvDetails,\n  cwd: string,\n): Promise<string> {\n  try {\n    // However, Yarn Classic does support it.\n    // https://github.com/yarnpkg/yarn/releases/tag/v1.0.0\n    // > Fix: Excludes dev dependencies from the yarn list output when the\n    //   environment is production\n    return (\n      await spawn(pkgEnvDetails.agentExecPath, ['list', '--prod'], {\n        cwd,\n        // Lazily access constants.WIN32.\n        shell: constants.WIN32,\n      })\n    ).stdout.trim()\n  } catch {}\n  return ''\n}\n\nexport type AgentListDepsOptions = { npmExecPath?: string }\n\nexport type AgentListDepsFn = (\n  pkgEnvDetails: EnvDetails,\n  cwd: string,\n  options?: AgentListDepsOptions | undefined,\n) => Promise<string>\n\nexport const lsByAgent = new Map<Agent, AgentListDepsFn>([\n  [BUN, lsBun],\n  [NPM, lsNpm],\n  [PNPM, lsPnpm],\n  [VLT, lsVlt],\n  [YARN_BERRY, lsYarnBerry],\n  [YARN_CLASSIC, lsYarnClassic],\n])\n","export const CMD_NAME = 'socket optimize'\n","import { hasKeys, isObject } from '@socketsecurity/registry/lib/objects'\n\nimport constants from '../../constants.mts'\n\nimport type { Overrides } from './types.mts'\nimport type { Agent, EnvDetails } from '../../utils/package-environment.mts'\nimport type { EditablePackageJson } from '@socketsecurity/registry/lib/packages'\n\nconst {\n  BUN,\n  NPM,\n  OVERRIDES,\n  PNPM,\n  RESOLUTIONS,\n  VLT,\n  YARN_BERRY,\n  YARN_CLASSIC,\n} = constants\n\nconst depFields = [\n  'dependencies',\n  'devDependencies',\n  'peerDependencies',\n  'peerDependenciesMeta',\n  'optionalDependencies',\n  'bundleDependencies',\n]\n\nfunction getEntryIndexes(\n  entries: Array<[string | symbol, any]>,\n  keys: Array<string | symbol>,\n): number[] {\n  return keys\n    .map(n => entries.findIndex(p => p[0] === n))\n    .filter(n => n !== -1)\n    .sort((a, b) => a - b)\n}\n\nfunction getLowestEntryIndex(\n  entries: Array<[string | symbol, any]>,\n  keys: Array<string | symbol>,\n) {\n  return getEntryIndexes(entries, keys)?.[0] ?? -1\n}\n\nfunction getHighestEntryIndex(\n  entries: Array<[string | symbol, any]>,\n  keys: Array<string | symbol>,\n) {\n  return getEntryIndexes(entries, keys).at(-1) ?? -1\n}\n\nfunction updatePkgJsonField(\n  editablePkgJson: EditablePackageJson,\n  field: string,\n  value: any,\n) {\n  const oldValue = editablePkgJson.content[field]\n  if (oldValue) {\n    // The field already exists so we simply update the field value.\n    if (field === PNPM) {\n      const isPnpmObj = isObject(oldValue)\n      if (hasKeys(value)) {\n        editablePkgJson.update({\n          [field]: {\n            ...(isPnpmObj ? oldValue : {}),\n            overrides: {\n              ...(isPnpmObj ? (oldValue as any)[OVERRIDES] : {}),\n              ...value,\n            },\n          },\n        })\n      } else {\n        // Properties with undefined values are omitted when saved as JSON.\n        editablePkgJson.update(\n          (hasKeys(oldValue)\n            ? {\n                [field]: {\n                  ...(isPnpmObj ? oldValue : {}),\n                  overrides: undefined,\n                },\n              }\n            : { [field]: undefined }) as typeof editablePkgJson.content,\n        )\n      }\n    } else if (field === OVERRIDES || field === RESOLUTIONS) {\n      // Properties with undefined values are omitted when saved as JSON.\n      editablePkgJson.update({\n        [field]: hasKeys(value) ? value : undefined,\n      } as typeof editablePkgJson.content)\n    } else {\n      editablePkgJson.update({ [field]: value })\n    }\n    return\n  }\n  if (\n    (field === OVERRIDES || field === PNPM || field === RESOLUTIONS) &&\n    !hasKeys(value)\n  ) {\n    return\n  }\n  // Since the field doesn't exist we want to insert it into the package.json\n  // in a place that makes sense, e.g. close to the \"dependencies\" field. If\n  // we can't find a place to insert the field we'll add it to the bottom.\n  const entries = Object.entries(editablePkgJson.content)\n  let insertIndex = -1\n  let isPlacingHigher = false\n  if (field === OVERRIDES) {\n    insertIndex = getLowestEntryIndex(entries, [RESOLUTIONS])\n    if (insertIndex === -1) {\n      isPlacingHigher = true\n      insertIndex = getHighestEntryIndex(entries, [...depFields, PNPM])\n    }\n  } else if (field === RESOLUTIONS) {\n    isPlacingHigher = true\n    insertIndex = getHighestEntryIndex(entries, [...depFields, OVERRIDES, PNPM])\n  } else if (field === PNPM) {\n    insertIndex = getLowestEntryIndex(entries, [OVERRIDES, RESOLUTIONS])\n    if (insertIndex === -1) {\n      isPlacingHigher = true\n      insertIndex = getHighestEntryIndex(entries, depFields)\n    }\n  }\n  if (insertIndex === -1) {\n    insertIndex = getLowestEntryIndex(entries, ['engines', 'files'])\n  }\n  if (insertIndex === -1) {\n    isPlacingHigher = true\n    insertIndex = getHighestEntryIndex(entries, ['exports', 'imports', 'main'])\n  }\n  if (insertIndex === -1) {\n    insertIndex = entries.length\n  } else if (isPlacingHigher) {\n    insertIndex += 1\n  }\n  entries.splice(insertIndex, 0, [\n    field,\n    field === PNPM ? { [OVERRIDES]: value } : value,\n  ])\n  editablePkgJson.fromJSON(\n    `${JSON.stringify(Object.fromEntries(entries), null, 2)}\\n`,\n  )\n}\n\nfunction updateOverridesField(pkgEnvDetails: EnvDetails, overrides: Overrides) {\n  updatePkgJsonField(pkgEnvDetails.editablePkgJson, OVERRIDES, overrides)\n}\n\nfunction updateResolutionsField(\n  pkgEnvDetails: EnvDetails,\n  overrides: Overrides,\n) {\n  updatePkgJsonField(pkgEnvDetails.editablePkgJson, RESOLUTIONS, overrides)\n}\n\nfunction updatePnpmField(pkgEnvDetails: EnvDetails, overrides: Overrides) {\n  updatePkgJsonField(pkgEnvDetails.editablePkgJson, PNPM, overrides)\n}\n\nexport type AgentModifyManifestFn = (\n  pkgEnvDetails: EnvDetails,\n  overrides: Overrides,\n) => void\n\nexport const updateManifestByAgent = new Map<Agent, AgentModifyManifestFn>([\n  [BUN, updateResolutionsField],\n  [NPM, updateOverridesField],\n  [PNPM, updatePnpmField],\n  [VLT, updateOverridesField],\n  [YARN_BERRY, updateResolutionsField],\n  [YARN_CLASSIC, updateResolutionsField],\n])\n","import path from 'node:path'\n\nimport semver from 'semver'\n\nimport { getManifestData } from '@socketsecurity/registry'\nimport { hasOwn, toSortedObject } from '@socketsecurity/registry/lib/objects'\nimport { fetchPackageManifest } from '@socketsecurity/registry/lib/packages'\nimport { pEach } from '@socketsecurity/registry/lib/promises'\nimport { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nimport { depsIncludesByAgent } from './deps-includes-by-agent.mts'\nimport { getDependencyEntries } from './get-dependency-entries.mts'\nimport { overridesDataByAgent } from './get-overrides-by-agent.mts'\nimport { lockfileIncludesByAgent } from './lockfile-includes-by-agent.mts'\nimport { lsByAgent } from './ls-by-agent.mts'\nimport { CMD_NAME } from './shared.mts'\nimport { updateManifestByAgent } from './update-manifest-by-agent.mts'\nimport constants from '../../constants.mts'\nimport { cmdPrefixMessage } from '../../utils/cmd.mts'\nimport { globWorkspace } from '../../utils/glob.mts'\nimport { npa } from '../../utils/npm-package-arg.mts'\nimport { getMajor } from '../../utils/semver.mts'\n\nimport type { GetOverridesResult } from './get-overrides-by-agent.mts'\nimport type { AgentLockIncludesFn } from './lockfile-includes-by-agent.mts'\nimport type { AliasResult } from '../../utils/npm-package-arg.mts'\nimport type { EnvDetails } from '../../utils/package-environment.mts'\nimport type { Logger } from '@socketsecurity/registry/lib/logger'\nimport type { PackageJson } from '@socketsecurity/registry/lib/packages'\n\ntype AddOverridesOptions = {\n  logger?: Logger | undefined\n  pin?: boolean | undefined\n  prod?: boolean | undefined\n  spinner?: Spinner | undefined\n  state?: AddOverridesState | undefined\n}\ntype AddOverridesState = {\n  added: Set<string>\n  addedInWorkspaces: Set<string>\n  updated: Set<string>\n  updatedInWorkspaces: Set<string>\n  warnedPnpmWorkspaceRequiresNpm: boolean\n}\n\nconst { NPM, PNPM, YARN_CLASSIC } = constants\n\nconst manifestNpmOverrides = getManifestData(NPM)\n\nexport async function addOverrides(\n  pkgEnvDetails: EnvDetails,\n  pkgPath: string,\n  options?: AddOverridesOptions | undefined,\n): Promise<AddOverridesState> {\n  const {\n    agent,\n    lockName,\n    lockSrc,\n    npmExecPath,\n    pkgPath: rootPath,\n  } = pkgEnvDetails\n  const {\n    logger,\n    pin,\n    prod,\n    spinner,\n    state = {\n      added: new Set(),\n      addedInWorkspaces: new Set(),\n      updated: new Set(),\n      updatedInWorkspaces: new Set(),\n      warnedPnpmWorkspaceRequiresNpm: false,\n    },\n  } = { __proto__: null, ...options } as AddOverridesOptions\n  const workspacePkgJsonPaths = await globWorkspace(agent, pkgPath)\n  const isWorkspace = workspacePkgJsonPaths.length > 0\n  const isWorkspaceRoot = pkgPath === rootPath\n  const isLockScanned = isWorkspaceRoot && !prod\n  const workspace = isWorkspaceRoot ? 'root' : path.relative(rootPath, pkgPath)\n  if (\n    isWorkspace &&\n    agent === PNPM &&\n    // npmExecPath will === the agent name IF it CANNOT be resolved.\n    npmExecPath === NPM &&\n    !state.warnedPnpmWorkspaceRequiresNpm\n  ) {\n    state.warnedPnpmWorkspaceRequiresNpm = true\n    logger?.warn(\n      cmdPrefixMessage(\n        CMD_NAME,\n        `${agent} workspace support requires \\`npm ls\\`, falling back to \\`${agent} list\\``,\n      ),\n    )\n  }\n\n  const overridesDataObjects = [] as GetOverridesResult[]\n  if (isWorkspace || pkgEnvDetails.editablePkgJson.content['private']) {\n    overridesDataObjects.push(overridesDataByAgent.get(agent)!(pkgEnvDetails))\n  } else {\n    overridesDataObjects.push(\n      overridesDataByAgent.get(NPM)!(pkgEnvDetails),\n      overridesDataByAgent.get(YARN_CLASSIC)!(pkgEnvDetails),\n    )\n  }\n\n  spinner?.setText(`Adding overrides to ${workspace}...`)\n\n  const depAliasMap = new Map<string, string>()\n  const depEntries = getDependencyEntries(pkgEnvDetails)\n\n  const manifestEntries = manifestNpmOverrides.filter(({ 1: data }) =>\n    semver.satisfies(\n      // Roughly check Node range as semver.coerce will strip leading\n      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).\n      semver.coerce(data.engines.node)!,\n      pkgEnvDetails.pkgRequirements.node,\n    ),\n  )\n\n  // Chunk package names to process them in parallel 3 at a time.\n  await pEach(manifestEntries, 3, async ({ 1: data }) => {\n    const { name: sockRegPkgName, package: origPkgName, version } = data\n    const major = getMajor(version)!\n    const sockOverridePrefix = `${NPM}:${sockRegPkgName}@`\n    const sockOverrideSpec = `${sockOverridePrefix}${pin ? version : `^${major}`}`\n    for (const { 1: depObj } of depEntries) {\n      const sockSpec = hasOwn(depObj, sockRegPkgName)\n        ? depObj[sockRegPkgName]\n        : undefined\n      if (sockSpec) {\n        depAliasMap.set(sockRegPkgName, sockSpec)\n      }\n      const origSpec = hasOwn(depObj, origPkgName)\n        ? depObj[origPkgName]\n        : undefined\n      if (origSpec) {\n        let thisSpec = origSpec\n        // Add package aliases for direct dependencies to avoid npm EOVERRIDE\n        // errors...\n        // https://docs.npmjs.com/cli/v8/using-npm/package-spec#aliases\n        if (\n          // ...if the spec doesn't start with a valid Socket override.\n          !(\n            thisSpec.startsWith(sockOverridePrefix) &&\n            // Check the validity of the spec by passing it through npa and\n            // seeing if it will coerce to a version.\n            semver.coerce((npa(thisSpec) as AliasResult).subSpec.rawSpec)\n              ?.version\n          )\n        ) {\n          thisSpec = sockOverrideSpec\n          depObj[origPkgName] = thisSpec\n          state.added.add(sockRegPkgName)\n          if (!isWorkspaceRoot) {\n            state.addedInWorkspaces.add(workspace)\n          }\n        }\n        depAliasMap.set(origPkgName, thisSpec)\n      }\n    }\n    if (isWorkspaceRoot) {\n      // The AgentDepsIncludesFn and AgentLockIncludesFn types overlap in their\n      // first two parameters. AgentLockIncludesFn accepts an optional third\n      // parameter which AgentDepsIncludesFn will ignore so we cast thingScanner\n      // as an AgentLockIncludesFn type.\n      const thingScanner = (\n        isLockScanned\n          ? lockfileIncludesByAgent.get(agent)\n          : depsIncludesByAgent.get(agent)\n      ) as AgentLockIncludesFn\n      const thingToScan = isLockScanned\n        ? lockSrc\n        : await lsByAgent.get(agent)!(pkgEnvDetails, pkgPath, { npmExecPath })\n      // Chunk package names to process them in parallel 3 at a time.\n      await pEach(overridesDataObjects, 3, async ({ overrides, type }) => {\n        const overrideExists = hasOwn(overrides, origPkgName)\n        if (\n          overrideExists ||\n          thingScanner(thingToScan, origPkgName, lockName)\n        ) {\n          const oldSpec = overrideExists ? overrides[origPkgName]! : undefined\n          const origDepAlias = depAliasMap.get(origPkgName)\n          const sockRegDepAlias = depAliasMap.get(sockRegPkgName)\n          const depAlias = sockRegDepAlias ?? origDepAlias\n          let newSpec = sockOverrideSpec\n          if (type === NPM && depAlias) {\n            // With npm one may not set an override for a package that one directly\n            // depends on unless both the dependency and the override itself share\n            // the exact same spec. To make this limitation easier to deal with,\n            // overrides may also be defined as a reference to a spec for a direct\n            // dependency by prefixing the name of the package to match the version\n            // of with a $.\n            // https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides\n            newSpec = `$${sockRegDepAlias ? sockRegPkgName : origPkgName}`\n          } else if (typeof oldSpec === 'string') {\n            const thisSpec = oldSpec.startsWith('$')\n              ? depAlias || newSpec\n              : oldSpec || newSpec\n            if (thisSpec.startsWith(sockOverridePrefix)) {\n              if (\n                pin &&\n                getMajor(\n                  // Check the validity of the spec by passing it through npa\n                  // and seeing if it will coerce to a version. semver.coerce\n                  // will strip leading v's, carets (^), comparators (<,<=,>,>=,=),\n                  // and tildes (~). If not coerced to a valid version then\n                  // default to the manifest entry version.\n                  semver.coerce((npa(thisSpec) as AliasResult).subSpec.rawSpec)\n                    ?.version ?? version,\n                ) !== major\n              ) {\n                const otherVersion = (await fetchPackageManifest(thisSpec))\n                  ?.version\n                if (otherVersion && otherVersion !== version) {\n                  newSpec = `${sockOverridePrefix}${pin ? otherVersion : `^${getMajor(otherVersion)!}`}`\n                }\n              }\n            } else {\n              newSpec = oldSpec\n            }\n          }\n          if (newSpec !== oldSpec) {\n            overrides[origPkgName] = newSpec\n            const addedOrUpdated = overrideExists ? 'updated' : 'added'\n            state[addedOrUpdated].add(sockRegPkgName)\n          }\n        }\n      })\n    }\n  })\n\n  if (isWorkspace) {\n    // Chunk package names to process them in parallel 3 at a time.\n    await pEach(workspacePkgJsonPaths, 3, async workspacePkgJsonPath => {\n      const otherState = await addOverrides(\n        pkgEnvDetails,\n        path.dirname(workspacePkgJsonPath),\n        {\n          logger,\n          pin,\n          prod,\n          spinner,\n        },\n      )\n      for (const key of [\n        'added',\n        'addedInWorkspaces',\n        'updated',\n        'updatedInWorkspaces',\n      ] satisfies\n        // Here we're just telling TS that we're looping over key names\n        // of the type and that they're all Set<string> props.\n        Array<\n          keyof Pick<\n            AddOverridesState,\n            'added' | 'addedInWorkspaces' | 'updated' | 'updatedInWorkspaces'\n          >\n        >) {\n        for (const value of otherState[key]) {\n          state[key].add(value)\n        }\n      }\n    })\n  }\n\n  if (state.added.size > 0 || state.updated.size > 0) {\n    pkgEnvDetails.editablePkgJson.update(\n      Object.fromEntries(depEntries) as PackageJson,\n    )\n    if (isWorkspaceRoot) {\n      for (const { overrides, type } of overridesDataObjects) {\n        updateManifestByAgent.get(type)!(\n          pkgEnvDetails,\n          toSortedObject(overrides),\n        )\n      }\n    }\n    await pkgEnvDetails.editablePkgJson.save()\n  }\n\n  return state\n}\n","import { debugFn } from '@socketsecurity/registry/lib/debug'\nimport { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nimport constants from '../../constants.mts'\nimport { runAgentInstall } from '../../utils/agent.mts'\nimport { cmdPrefixMessage } from '../../utils/cmd.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { EnvDetails } from '../../utils/package-environment.mts'\nimport type { Logger } from '@socketsecurity/registry/lib/logger'\n\nconst { NPM_BUGGY_OVERRIDES_PATCHED_VERSION } = constants\n\nexport type UpdateLockfileOptions = {\n  cmdName?: string | undefined\n  logger?: Logger | undefined\n  spinner?: Spinner | undefined\n}\n\nexport async function updateLockfile(\n  pkgEnvDetails: EnvDetails,\n  options: UpdateLockfileOptions,\n): Promise<CResult<unknown>> {\n  const {\n    cmdName = '',\n    logger,\n    spinner,\n  } = {\n    __proto__: null,\n    ...options,\n  } as UpdateLockfileOptions\n  const isSpinning = !!spinner?.['isSpinning']\n  if (!isSpinning) {\n    spinner?.start()\n  }\n  spinner?.setText(`Updating ${pkgEnvDetails.lockName}...`)\n  try {\n    await runAgentInstall(pkgEnvDetails, { spinner })\n    if (pkgEnvDetails.features.npmBuggyOverrides) {\n      spinner?.stop()\n      logger?.log(\n        `💡 Re-run ${cmdName ? `${cmdName} ` : ''}whenever ${pkgEnvDetails.lockName} changes.\\n   This can be skipped for ${pkgEnvDetails.agent} >=${NPM_BUGGY_OVERRIDES_PATCHED_VERSION}.`,\n      )\n    }\n  } catch (e) {\n    spinner?.stop()\n\n    debugFn('fail: update\\n', e)\n\n    return {\n      ok: false,\n      message: 'Update failed',\n      cause: cmdPrefixMessage(\n        cmdName,\n        `${pkgEnvDetails.agent} install failed to update ${pkgEnvDetails.lockName}`,\n      ),\n    }\n  }\n  if (isSpinning) {\n    spinner?.start()\n  } else {\n    spinner?.stop()\n  }\n\n  return { ok: true, data: undefined }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { addOverrides } from './add-overrides.mts'\nimport { CMD_NAME } from './shared.mts'\nimport { updateLockfile } from './update-lockfile.mts'\nimport constants from '../../constants.mts'\nimport { cmdPrefixMessage } from '../../utils/cmd.mts'\nimport { detectAndValidatePackageEnvironment } from '../../utils/package-environment.mts'\n\nimport type { CResult } from '../../types.mts'\n\nconst { VLT } = constants\n\nexport async function applyOptimization(\n  cwd: string,\n  pin: boolean,\n  prod: boolean,\n): Promise<\n  CResult<{\n    addedCount: number\n    updatedCount: number\n    pkgJsonChanged: boolean\n    updatedInWorkspaces: number\n    addedInWorkspaces: number\n  }>\n> {\n  const result = await detectAndValidatePackageEnvironment(cwd, {\n    cmdName: CMD_NAME,\n    logger,\n    prod,\n  })\n\n  if (!result.ok) {\n    return result\n  }\n  const pkgEnvDetails = result.data\n\n  if (pkgEnvDetails.agent === VLT) {\n    return {\n      ok: false,\n      message: 'Unsupported',\n      cause: cmdPrefixMessage(\n        CMD_NAME,\n        `${VLT} does not support overrides. Soon, though ⚡`,\n      ),\n    }\n  }\n\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n\n  spinner.start('Socket optimizing...')\n\n  const state = await addOverrides(pkgEnvDetails, pkgEnvDetails.pkgPath, {\n    logger,\n    pin,\n    prod,\n    spinner,\n  })\n\n  const addedCount = state.added.size\n  const updatedCount = state.updated.size\n  const pkgJsonChanged = addedCount > 0 || updatedCount > 0\n\n  if (pkgJsonChanged || pkgEnvDetails.features.npmBuggyOverrides) {\n    const result = await updateLockfile(pkgEnvDetails, {\n      cmdName: CMD_NAME,\n      logger,\n      spinner,\n    })\n    if (!result.ok) {\n      return result\n    }\n  }\n\n  spinner.stop()\n\n  return {\n    ok: true,\n    data: {\n      addedCount,\n      updatedCount,\n      pkgJsonChanged,\n      updatedInWorkspaces: state.updatedInWorkspaces.size,\n      addedInWorkspaces: state.addedInWorkspaces.size,\n    },\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\nimport { pluralize } from '@socketsecurity/registry/lib/words'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\n\nexport async function outputOptimizeResult(\n  result: CResult<{\n    addedCount: number\n    updatedCount: number\n    pkgJsonChanged: boolean\n    updatedInWorkspaces: number\n    addedInWorkspaces: number\n  }>,\n  outputKind: OutputKind,\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const data = result.data\n\n  if (data.updatedCount > 0) {\n    logger?.log(\n      `${createActionMessage('Updated', data.updatedCount, data.updatedInWorkspaces)}${data.addedCount ? '.' : '🚀'}`,\n    )\n  }\n  if (data.addedCount > 0) {\n    logger?.log(\n      `${createActionMessage('Added', data.addedCount, data.addedInWorkspaces)} 🚀`,\n    )\n  }\n  if (!data.pkgJsonChanged) {\n    logger?.log('Scan complete. No Socket.dev optimized overrides applied.')\n  }\n\n  logger.log('')\n  logger.success('Finished!')\n  logger.log('')\n}\n\nfunction createActionMessage(\n  verb: string,\n  overrideCount: number,\n  workspaceCount: number,\n): string {\n  return `${verb} ${overrideCount} Socket.dev optimized ${pluralize('override', overrideCount)}${workspaceCount ? ` in ${workspaceCount} ${pluralize('workspace', workspaceCount)}` : ''}`\n}\n","import { applyOptimization } from './apply-optimization.mts'\nimport { outputOptimizeResult } from './output-optimize-result.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleOptimize({\n  cwd,\n  outputKind,\n  pin,\n  prod,\n}: {\n  cwd: string\n  outputKind: OutputKind\n  pin: boolean\n  prod: boolean\n}) {\n  const result = await applyOptimization(cwd, pin, prod)\n\n  await outputOptimizeResult(result, outputKind)\n}\n","import path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleOptimize } from './handle-optimize.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'optimize',\n  description: 'Optimize dependencies with @socketregistry overrides',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    pin: {\n      type: 'boolean',\n      default: false,\n      description: 'Pin overrides to their latest version',\n    },\n    prod: {\n      type: 'boolean',\n      default: false,\n      description: 'Only add overrides for production dependencies',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [options] [CWD=.]\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}\n      $ ${command} ./proj/tree --pin\n  `,\n}\n\nexport const cmdOptimize = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json, markdown } = cli.flags\n  const { pin, prod } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleOptimize({\n    cwd,\n    pin: Boolean(pin),\n    outputKind,\n    prod: Boolean(prod),\n  })\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchLicensePolicy(\n  orgSlug: string,\n): Promise<CResult<SocketSdkReturnType<'getOrgLicensePolicy'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgLicensePolicy(orgSlug),\n    'organization license policy',\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTableOfPairs } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputLicensePolicy(\n  result: CResult<SocketSdkReturnType<'getOrgLicensePolicy'>['data']>,\n  outputKind: OutputKind,\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.info('Use --json to get the full result')\n  logger.log('# License policy')\n  logger.log('')\n  logger.log('This is the license policy for your organization:')\n  logger.log('')\n  const rules = result.data['license_policy']!\n  const entries = rules ? Object.entries(rules) : []\n  const mapped: Array<[string, string]> = entries.map(\n    ([key, value]) =>\n      [key, (value as any)?.['allowed'] ? ' yes' : ' no'] as const,\n  )\n  mapped.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))\n  logger.log(mdTableOfPairs(mapped, ['License Name', 'Allowed']))\n  logger.log('')\n}\n","import { fetchLicensePolicy } from './fetch-license-policy.mts'\nimport { outputLicensePolicy } from './output-license-policy.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleLicensePolicy(\n  orgSlug: string,\n  outputKind: OutputKind,\n): Promise<void> {\n  const data = await fetchLicensePolicy(orgSlug)\n\n  await outputLicensePolicy(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleLicensePolicy } from './handle-license-policy.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\n// TODO: secret toplevel alias `socket license policy`?\nconst config: CliCommandConfig = {\n  commandName: 'license',\n  description: 'Retrieve the license policy of an organization',\n  hidden: true,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: license-policy:read\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Your API token will need the \\`license-policy:read\\` permission otherwise\n    the request will fail with an authentication error.\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' mycorp'}\n      $ ${command}${isTestingV1() ? '' : ' mycorp'} --json\n  `,\n}\n\nexport const cmdOrganizationPolicyLicense = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleLicensePolicy(orgSlug, outputKind)\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchSecurityPolicy(\n  orgSlug: string,\n): Promise<CResult<SocketSdkReturnType<'getOrgSecurityPolicy'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgSecurityPolicy(orgSlug),\n    'organization security policy',\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTableOfPairs } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputSecurityPolicy(\n  result: CResult<SocketSdkReturnType<'getOrgSecurityPolicy'>['data']>,\n  outputKind: OutputKind,\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.log('# Security policy')\n  logger.log('')\n  logger.log(\n    `The default security policy setting is: \"${result.data.securityPolicyDefault}\"`,\n  )\n  logger.log('')\n  logger.log(\n    'These are the security policies per setting for your organization:',\n  )\n  logger.log('')\n  const rules = result.data.securityPolicyRules\n  const entries: Array<\n    [string, { action: 'defer' | 'error' | 'warn' | 'monitor' | 'ignore' }]\n  > = rules ? Object.entries(rules) : []\n  const mapped: Array<[string, string]> = entries.map(([key, value]) => [\n    key,\n    value.action,\n  ])\n  mapped.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))\n  logger.log(mdTableOfPairs(mapped, ['name', 'action']))\n  logger.log('')\n}\n","import { fetchSecurityPolicy } from './fetch-security-policy.mts'\nimport { outputSecurityPolicy } from './output-security-policy.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleSecurityPolicy(\n  orgSlug: string,\n  outputKind: OutputKind,\n): Promise<void> {\n  const data = await fetchSecurityPolicy(orgSlug)\n\n  await outputSecurityPolicy(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleSecurityPolicy } from './handle-security-policy.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\n// TODO: secret toplevel alias `socket security policy`?\nconst config: CliCommandConfig = {\n  commandName: 'security',\n  description: 'Retrieve the security policy of an organization',\n  hidden: true,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: security-policy:read\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Your API token will need the \\`security-policy:read\\` permission otherwise\n    the request will fail with an authentication error.\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' mycorp'}\n      $ ${command}${isTestingV1() ? '' : ' mycorp'} --json\n  `,\n}\n\nexport const cmdOrganizationPolicyPolicy = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: 'Org name as the first argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleSecurityPolicy(orgSlug, outputKind)\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchOrganization(): Promise<\n  CResult<SocketSdkReturnType<'getOrganizations'>['data']>\n> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(sockSdk.getOrganizations(), 'organization list')\n}\n","import colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { getVisibleTokenPrefix } from '../../utils/sdk.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputOrganizationList(\n  result: CResult<SocketSdkReturnType<'getOrganizations'>['data']>,\n  outputKind: OutputKind = 'text',\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const organizations = Object.values(result.data.organizations)\n  const visibleTokenPrefix = getVisibleTokenPrefix()\n\n  switch (outputKind) {\n    case 'markdown': {\n      // | Syntax      | Description |\n      // | ----------- | ----------- |\n      // | Header      | Title       |\n      // | Paragraph   | Text        |\n      let mw1 = 4\n      let mw2 = 2\n      let mw3 = 4\n      for (const o of organizations) {\n        mw1 = Math.max(mw1, o.name?.length ?? 0)\n        mw2 = Math.max(mw2, o.id.length)\n        mw3 = Math.max(mw3, o.plan.length)\n      }\n      logger.log('# Organizations\\n')\n      logger.log(\n        `List of organizations associated with your API key, starting with: ${colors.italic(visibleTokenPrefix)}\\n`,\n      )\n      logger.log(\n        `| Name${' '.repeat(mw1 - 4)} | ID${' '.repeat(mw2 - 2)} | Plan${' '.repeat(mw3 - 4)} |`,\n      )\n      logger.log(\n        `| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} | ${'-'.repeat(mw3)} |`,\n      )\n      for (const o of organizations) {\n        logger.log(\n          `| ${(o.name || '').padEnd(mw1, ' ')} | ${(o.id || '').padEnd(mw2, ' ')} | ${(o.plan || '').padEnd(mw3, ' ')} |`,\n        )\n      }\n      logger.log(\n        `| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} | ${'-'.repeat(mw3)} |`,\n      )\n      return\n    }\n    default: {\n      logger.log(\n        `List of organizations associated with your API key, starting with: ${colors.italic(visibleTokenPrefix)}\\n`,\n      )\n      // Just dump\n      for (const o of organizations) {\n        logger.log(\n          `- Name: ${colors.bold(o.name ?? 'undefined')}, ID: ${colors.bold(o.id)}, Plan: ${colors.bold(o.plan)}`,\n        )\n      }\n    }\n  }\n}\n","import { fetchOrganization } from './fetch-organization-list.mts'\nimport { outputOrganizationList } from './output-organization-list.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleOrganizationList(\n  outputKind: OutputKind = 'text',\n): Promise<void> {\n  const data = await fetchOrganization()\n\n  await outputOrganizationList(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleOrganizationList } from './handle-organization-list.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'list',\n  description: 'List organizations associated with the API key used',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: none (does need a token)\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n  `,\n}\n\nexport const cmdOrganizationList = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleOrganizationList(outputKind)\n}\n","import { cmdOrganizationPolicyLicense } from './cmd-organization-policy-license.mts'\nimport { cmdOrganizationPolicyPolicy } from './cmd-organization-policy-security.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Organization policy details'\n\nexport const cmdOrganizationPolicy: CliSubcommand = {\n  description,\n  // Hidden because it was broken all this time (nobody could be using it)\n  // and we're not sure if it's useful to anyone in its current state.\n  // Until we do, we'll hide this to keep the help tidier.\n  // And later, we may simply move this under `scan`, anyways.\n  hidden: true,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        security: cmdOrganizationPolicyPolicy,\n        license: cmdOrganizationPolicyLicense,\n      },\n      {\n        argv,\n        description,\n        defaultSub: 'list', // Backwards compat\n        importMeta,\n        name: parentName + ' policy',\n      },\n    )\n  },\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchQuota(): Promise<\n  CResult<SocketSdkReturnType<'getQuota'>['data']>\n> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(sockSdk.getQuota(), 'token quota')\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputQuota(\n  result: CResult<SocketSdkReturnType<'getQuota'>['data']>,\n  outputKind: OutputKind = 'text',\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log('# Quota')\n    logger.log('')\n    logger.log(`Quota left on the current API token: ${result.data.quota}`)\n    logger.log('')\n    return\n  }\n\n  logger.log(`Quota left on the current API token: ${result.data.quota}`)\n  logger.log('')\n}\n","import { fetchQuota } from './fetch-quota.mts'\nimport { outputQuota } from './output-quota.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleQuota(\n  outputKind: OutputKind = 'text',\n): Promise<void> {\n  const data = await fetchQuota()\n\n  await outputQuota(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleQuota } from './handle-quota.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'quota',\n  description: 'List organizations associated with the API key used',\n  hidden: true,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n  `,\n}\n\nexport const cmdOrganizationQuota = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const json = Boolean(cli.flags['json'])\n  const markdown = Boolean(cli.flags['markdown'])\n  const outputKind = getOutputKind(json, markdown)\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleQuota(outputKind)\n}\n","import { cmdOrganizationList } from './cmd-organization-list.mts'\nimport { cmdOrganizationPolicyLicense } from './cmd-organization-policy-license.mts'\nimport { cmdOrganizationPolicyPolicy } from './cmd-organization-policy-security.mts'\nimport { cmdOrganizationPolicy } from './cmd-organization-policy.mts'\nimport { cmdOrganizationQuota } from './cmd-organization-quota.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Account details'\n\nexport const cmdOrganization: CliSubcommand = {\n  description,\n  hidden: false,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        list: cmdOrganizationList,\n        quota: cmdOrganizationQuota,\n        policy: cmdOrganizationPolicy,\n      },\n      {\n        aliases: {\n          license: {\n            description: cmdOrganizationPolicyLicense.description,\n            hidden: true,\n            argv: ['policy', 'license'],\n          },\n          security: {\n            description: cmdOrganizationPolicyPolicy.description,\n            hidden: true,\n            argv: ['policy', 'security'],\n          },\n        },\n        argv,\n        description,\n        defaultSub: 'list', // Backwards compat\n        importMeta,\n        name: parentName + ' organization',\n      },\n    )\n  },\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { queryApiSafeJson } from '../../utils/api.mts'\n\nimport type { CResult } from '../../types.mts'\n\nexport interface PurlDataResponse {\n  purl: string\n  self: {\n    purl: string\n    score: {\n      license: number\n      maintenance: number\n      overall: number\n      quality: number\n      supplyChain: number\n      vulnerability: number\n    }\n    capabilities: string[]\n    alerts: Array<{\n      name: string\n      severity: string\n      category: string\n      example: string\n    }>\n  }\n  transitively: {\n    dependencyCount: number\n    func: string\n    score: {\n      license: number\n      maintenance: number\n      overall: number\n      quality: number\n      supplyChain: number\n      vulnerability: number\n    }\n    lowest: {\n      license: string\n      maintenance: string\n      overall: string\n      quality: string\n      supplyChain: string\n      vulnerability: string\n    }\n    capabilities: string[]\n    alerts: Array<{\n      name: string\n      severity: string\n      category: string\n      example: string\n    }>\n  }\n}\n\nexport async function fetchPurlDeepScore(\n  purl: string,\n): Promise<CResult<PurlDataResponse>> {\n  logger.info(`Requesting deep score data for this purl: ${purl}`)\n\n  return await queryApiSafeJson<PurlDataResponse>(\n    `purl/score/${encodeURIComponent(purl)}`,\n    'the deep package scores',\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTable } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { PurlDataResponse } from './fetch-purl-deep-score.mts'\nimport type { CResult, OutputKind } from '../../types.mts'\n\nexport async function outputPurlsDeepScore(\n  purl: string,\n  result: CResult<PurlDataResponse>,\n  outputKind: OutputKind,\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    const md = createMarkdownReport(result.data)\n    logger.success(`Score report for \"${result.data.purl}\" (\"${purl}\"):\\n`)\n    logger.log(md)\n    return\n  }\n\n  logger.log(\n    `Score report for \"${purl}\" (use --json for raw and --markdown for formatted reports):`,\n  )\n  logger.log(result.data)\n  logger.log('')\n}\n\nexport function createMarkdownReport(data: PurlDataResponse) {\n  const {\n    self: {\n      alerts: selfAlerts,\n      capabilities: selfCaps,\n      purl,\n      score: selfScore,\n    },\n    transitively: {\n      alerts,\n      capabilities,\n      dependencyCount,\n      func,\n      lowest,\n      score,\n    },\n  } = data\n\n  const arr: string[] = []\n\n  arr.push('# Complete Package Score')\n  arr.push('')\n  if (dependencyCount) {\n    arr.push(\n      `This is a Socket report for the package *\"${purl}\"* and its *${dependencyCount}* direct/transitive dependencies.`,\n    )\n  } else {\n    arr.push(\n      `This is a Socket report for the package *\"${purl}\"*. It has *no dependencies*.`,\n    )\n  }\n  arr.push('')\n  if (dependencyCount) {\n    arr.push(\n      `It will show you the shallow score for just the package itself and a deep score for all the transitives combined. Additionally you can see which capabilities were found and the top alerts as well as a package that was responsible for it.`,\n    )\n  } else {\n    arr.push(\n      `It will show you the shallow score for the package itself, which capabilities were found, and its top alerts.`,\n    )\n    arr.push('')\n    arr.push(\n      'Since it has no dependencies, the shallow score is also the deep score.',\n    )\n  }\n  arr.push('')\n  if (dependencyCount) {\n    // This doesn't make much sense if there are no dependencies. Better to omit it.\n    arr.push(\n      'The report should give you a good insight into the status of this package.',\n    )\n    arr.push('')\n    arr.push('## Package itself')\n    arr.push('')\n    arr.push(\n      'Here are results for the package itself (excluding data from dependencies).',\n    )\n  } else {\n    arr.push('## Report')\n    arr.push('')\n    arr.push(\n      'The report should give you a good insight into the status of this package.',\n    )\n  }\n  arr.push('')\n  arr.push('### Shallow Score')\n  arr.push('')\n  arr.push('This score is just for the package itself:')\n  arr.push('')\n  arr.push('- Overall: ' + selfScore.overall)\n  arr.push('- Maintenance: ' + selfScore.maintenance)\n  arr.push('- Quality: ' + selfScore.quality)\n  arr.push('- Supply Chain: ' + selfScore.supplyChain)\n  arr.push('- Vulnerability: ' + selfScore.vulnerability)\n  arr.push('- License: ' + selfScore.license)\n  arr.push('')\n  arr.push('### Capabilities')\n  arr.push('')\n  if (selfCaps.length) {\n    arr.push('These are the capabilities detected in the package itself:')\n    arr.push('')\n    selfCaps.forEach(cap => {\n      arr.push(`- ${cap}`)\n    })\n  } else {\n    arr.push('No capabilities were found in the package.')\n  }\n  arr.push('')\n  arr.push('### Alerts for this package')\n  arr.push('')\n  if (selfAlerts.length) {\n    if (dependencyCount) {\n      arr.push('These are the alerts found for the package itself:')\n    } else {\n      arr.push('These are the alerts found for this package:')\n    }\n    arr.push('')\n    arr.push(\n      mdTable(selfAlerts, ['severity', 'name'], ['Severity', 'Alert Name']),\n    )\n  } else {\n    arr.push('There are currently no alerts for this package.')\n  }\n  arr.push('')\n  if (dependencyCount) {\n    arr.push('## Transitive Package Results')\n    arr.push('')\n    arr.push(\n      'Here are results for the package and its direct/transitive dependencies.',\n    )\n    arr.push('')\n    arr.push('### Deep Score')\n    arr.push('')\n    arr.push(\n      'This score represents the package and and its direct/transitive dependencies:',\n    )\n    arr.push(\n      `The function used to calculate the values in aggregate is: *\"${func}\"*`,\n    )\n    arr.push('')\n    arr.push('- Overall: ' + score.overall)\n    arr.push('- Maintenance: ' + score.maintenance)\n    arr.push('- Quality: ' + score.quality)\n    arr.push('- Supply Chain: ' + score.supplyChain)\n    arr.push('- Vulnerability: ' + score.vulnerability)\n    arr.push('- License: ' + score.license)\n    arr.push('')\n    arr.push('### Capabilities')\n    arr.push('')\n    arr.push(\n      'These are the packages with the lowest recorded score. If there is more than one with the lowest score, just one is shown here. This may help you figure out the source of low scores.',\n    )\n    arr.push('')\n    arr.push('- Overall: ' + lowest.overall)\n    arr.push('- Maintenance: ' + lowest.maintenance)\n    arr.push('- Quality: ' + lowest.quality)\n    arr.push('- Supply Chain: ' + lowest.supplyChain)\n    arr.push('- Vulnerability: ' + lowest.vulnerability)\n    arr.push('- License: ' + lowest.license)\n    arr.push('')\n    arr.push('### Capabilities')\n    arr.push('')\n    if (capabilities.length) {\n      arr.push('These are the capabilities detected in at least one package:')\n      arr.push('')\n      capabilities.forEach(cap => {\n        arr.push(`- ${cap}`)\n      })\n    } else {\n      arr.push(\n        'This package had no capabilities and neither did any of its direct/transitive dependencies.',\n      )\n    }\n    arr.push('')\n    arr.push('### Alerts')\n    arr.push('')\n    if (alerts.length) {\n      arr.push('These are the alerts found:')\n      arr.push('')\n\n      arr.push(\n        mdTable(\n          alerts,\n          ['severity', 'name', 'example'],\n          ['Severity', 'Alert Name', 'Example package reporting it'],\n        ),\n      )\n    } else {\n      arr.push(\n        'This package had no alerts and neither did any of its direct/transitive dependencies',\n      )\n    }\n    arr.push('')\n\n    return arr.join('\\n')\n  }\n}\n","import { fetchPurlDeepScore } from './fetch-purl-deep-score.mts'\nimport { outputPurlsDeepScore } from './output-purls-deep-score.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handlePurlDeepScore(\n  purl: string,\n  outputKind: OutputKind,\n) {\n  const result = await fetchPurlDeepScore(purl)\n\n  await outputPurlsDeepScore(purl, result, outputKind)\n}\n","// Either an ecosystem was given or all args must be (namespaced) purls\n// The `pkg:` part is optional here. We'll scan for `eco/name@version`.\n// Not hardcoding the namespace since we don't know what the server accepts.\n// The ecosystem is considered as the first package if it is not an a-z string.\nexport function parsePackageSpecifiers(\n  ecosystem: string,\n  pkgs: string[],\n): { purls: string[]; valid: boolean } {\n  let valid = true\n  const purls = []\n  if (!ecosystem) {\n    valid = false\n  } else if (/^[a-zA-Z]+$/.test(ecosystem)) {\n    for (let i = 0; i < pkgs.length; ++i) {\n      const pkg = pkgs[i] ?? ''\n      if (!pkg) {\n        valid = false\n        break\n      } else if (pkg.startsWith('pkg:')) {\n        // keep\n        purls.push(pkg)\n      } else {\n        purls.push('pkg:' + ecosystem + '/' + pkg)\n      }\n    }\n    if (!purls.length) {\n      valid = false\n    }\n  } else {\n    // Assume ecosystem is a purl, too\n    pkgs.unshift(ecosystem)\n\n    for (let i = 0; i < pkgs.length; ++i) {\n      const pkg = pkgs[i] ?? ''\n      if (!/^(?:pkg:)?[a-zA-Z]+\\/./.test(pkg)) {\n        // At least one purl did not start with `pkg:eco/x` or `eco/x`\n        valid = false\n        break\n      } else if (pkg.startsWith('pkg:')) {\n        purls.push(pkg)\n      } else {\n        purls.push('pkg:' + pkg)\n      }\n    }\n\n    if (!purls.length) {\n      valid = false\n    }\n  }\n\n  return { purls, valid }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handlePurlDeepScore } from './handle-purl-deep-score.mts'\nimport { parsePackageSpecifiers } from './parse-package-specifiers.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'score',\n  description:\n    'Look up score for one package which reflects all of its transitive dependencies as well',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <<ecosystem> <name> | <purl>>\n\n    API Token Requirements\n      - Quota: 100 units\n      - Permissions: packages:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Show deep scoring details for one package. The score will reflect the package\n    itself, any of its dependencies, and any of its transitive dependencies.\n\n    When you want to know whether to trust a package, this is the command to run.\n\n    See also the \\`socket package shallow\\` command, which returns the shallow\n    score for any number of packages. That will not reflect the dependency scores.\n\n    Only a few ecosystems are supported like npm, golang, and maven.\n\n    A \"purl\" is a standard package name formatting: \\`pkg:eco/name@version\\`\n    This command will automatically prepend \"pkg:\" when not present.\n\n    The version is optional but when given should be a direct match.\n\n    Examples\n      $ ${command} npm babel-cli\n      $ ${command} npm babel-cli@1.9.1\n      $ ${command} npm/babel-cli@1.9.1\n      $ ${command} pkg:npm/babel-cli@1.9.1\n  `,\n}\n\nexport const cmdPackageScore = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [ecosystem = '', purl] = cli.input\n\n  const hasApiToken = hasDefaultToken()\n\n  const { purls, valid } = parsePackageSpecifiers(ecosystem, purl ? [purl] : [])\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: valid,\n      message: 'First parameter must be an ecosystem or the whole purl',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      test: purls.length === 1,\n      message: 'Expecting at least one package',\n      pass: 'ok',\n      fail: purls.length === 0 ? 'missing' : 'too many',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handlePurlDeepScore(purls[0] || '', outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchPurlsShallowScore(\n  purls: string[],\n): Promise<CResult<SocketSdkReturnType<'batchPackageFetch'>>> {\n  logger.info(\n    `Requesting shallow score data for ${purls.length} package urls (purl): ${purls.join(', ')}`,\n  )\n\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  const result = await handleApiCall(\n    sockSdk.batchPackageFetch(\n      {\n        alerts: 'true',\n      },\n      { components: purls.map(purl => ({ purl })) },\n    ),\n    'looking up package',\n  )\n\n  if (!result.ok) {\n    return result\n  }\n\n  // TODO: seems like there's a bug in the typing since we absolutely have to return the .data here\n  return {\n    ok: true,\n    data: result.data as SocketSdkReturnType<'batchPackageFetch'>,\n  }\n}\n","import colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketArtifact } from '../../utils/alert/artifact.mts'\n\n// This is a simplified view of an artifact. Potentially merged with other artifacts.\ninterface DedupedArtifact {\n  ecosystem: string // artifact.type\n  namespace: string\n  name: string\n  version: string\n  score: {\n    supplyChain: number\n    maintenance: number\n    quality: number\n    vulnerability: number\n    license: number\n  }\n  alerts: Map<\n    string,\n    {\n      type: string\n      severity: string\n    }\n  >\n}\n\nexport function outputPurlsShallowScore(\n  purls: string[],\n  result: CResult<SocketArtifact[]>,\n  outputKind: OutputKind,\n): void {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const { missing, rows } = preProcess(result.data, purls)\n\n  if (outputKind === 'markdown') {\n    const md = generateMarkdownReport(rows, missing)\n    logger.log(md)\n    return\n  }\n\n  const txt = generateTextReport(rows, missing)\n  logger.log(txt)\n}\n\nfunction formatReportCard(artifact: DedupedArtifact, color: boolean): string {\n  const scoreResult = {\n    'Supply Chain Risk': Math.floor((artifact.score?.supplyChain ?? 0) * 100),\n    Maintenance: Math.floor((artifact.score?.maintenance ?? 0) * 100),\n    Quality: Math.floor((artifact.score?.quality ?? 0) * 100),\n    Vulnerabilities: Math.floor((artifact.score?.vulnerability ?? 0) * 100),\n    License: Math.floor((artifact.score?.license ?? 0) * 100),\n  }\n  const alertString = getAlertString(artifact.alerts, !color)\n  if (!artifact.ecosystem) {\n    console.log('WTF?', artifact)\n  }\n  const purl = `pkg:${artifact.ecosystem}/${artifact.name}${artifact.version ? '@' + artifact.version : ''}`\n\n  return [\n    'Package: ' + (color ? colors.bold(purl) : purl),\n    '',\n    ...Object.entries(scoreResult).map(\n      score =>\n        `- ${score[0]}:`.padEnd(20, ' ') +\n        `  ${formatScore(score[1], !color, true)}`,\n    ),\n    alertString,\n  ].join('\\n')\n}\n\nfunction formatScore(score: number, noColor = false, pad = false): string {\n  const padded = String(score).padStart(pad ? 3 : 0, ' ')\n  if (noColor) {\n    return padded\n  }\n  if (score >= 80) {\n    return colors.green(padded)\n  }\n  if (score >= 60) {\n    return colors.yellow(padded)\n  }\n  return colors.red(padded)\n}\n\nfunction getAlertString(\n  alerts: DedupedArtifact['alerts'],\n  noColor = false,\n): string {\n  if (!alerts.size) {\n    return noColor ? `- Alerts: none!` : `- Alerts: ${colors.green('none')}!`\n  }\n\n  const arr = Array.from(alerts.values())\n  const bad = arr\n    .filter(alert => alert.severity !== 'low' && alert.severity !== 'middle')\n    .sort((a, b) => (a.type < b.type ? -1 : a.type > b.type ? 1 : 0))\n  const mid = arr\n    .filter(alert => alert.severity === 'middle')\n    .sort((a, b) => (a.type < b.type ? -1 : a.type > b.type ? 1 : 0))\n  const low = arr\n    .filter(alert => alert.severity === 'low')\n    .sort((a, b) => (a.type < b.type ? -1 : a.type > b.type ? 1 : 0))\n\n  // We need to create the no-color string regardless because the actual string\n  // contains a bunch of invisible ANSI chars which would screw up length checks.\n  const colorless = `- Alerts (${bad.length}/${mid.length.toString()}/${low.length}):`\n\n  if (noColor) {\n    return (\n      colorless +\n      ' '.repeat(Math.max(0, 20 - colorless.length)) +\n      '  ' +\n      [\n        bad.map(alert => `[${alert.severity}] ` + alert.type).join(', '),\n        mid.map(alert => `[${alert.severity}] ` + alert.type).join(', '),\n        low.map(alert => `[${alert.severity}] ` + alert.type).join(', '),\n      ]\n        .filter(Boolean)\n        .join(', ')\n    )\n  }\n  return (\n    `- Alerts (${colors.red(bad.length.toString())}/${colors.yellow(mid.length.toString())}/${low.length}):` +\n    ' '.repeat(Math.max(0, 20 - colorless.length)) +\n    '  ' +\n    [\n      bad\n        .map(alert =>\n          colors.red(colors.dim(`[${alert.severity}] `) + alert.type),\n        )\n        .join(', '),\n      mid\n        .map(alert =>\n          colors.yellow(colors.dim(`[${alert.severity}] `) + alert.type),\n        )\n        .join(', '),\n      low\n        .map(alert => colors.dim(`[${alert.severity}] `) + alert.type)\n        .join(', '),\n    ]\n      .filter(Boolean)\n      .join(', ')\n  )\n}\n\nexport function preProcess(\n  artifacts: SocketArtifact[],\n  requestedPurls: string[],\n): { rows: Map<string, DedupedArtifact>; missing: string[] } {\n  // Dedupe results (for example, pypi will emit one package for each system release (win/mac/cpu) even if it's\n  // the same package version with same results. The duplication is irrelevant and annoying to the user.\n\n  // Make some effort to match the requested data with the response\n  // Dedupe and merge results when only the .release value is different\n\n  // API does not tell us which purls were not found.\n  // Generate all purls to try so we can try to match search request.\n  const purls: Set<string> = new Set()\n  artifacts.forEach(data => {\n    purls.add(\n      `pkg:${data.type}/${data.namespace ? `${data.namespace}/` : ''}${data.name}@${data.version}`,\n    )\n    purls.add(`pkg:${data.type}/${data.name}@${data.version}`)\n    purls.add(`pkg:${data.type}/${data.name}`)\n    purls.add(\n      `pkg:${data.type}/${data.namespace ? `${data.namespace}/` : ''}${data.name}`,\n    )\n  })\n  // Try to match the searched purls against this list\n  const missing = requestedPurls.filter(purl => {\n    if (purls.has(purl)) {\n      return false\n    }\n    if (\n      purl.endsWith('@latest') &&\n      purls.has(purl.slice(0, -'@latest'.length))\n    ) {\n      return false\n    }\n    return true // not found\n  })\n\n  // Create a unique set of rows which represents each artifact that is returned\n  // while deduping when the artifact (main) meta data only differs due to the\n  // .release field (observed with python, at least).\n  // Merge the alerts for duped packages. Use lowest score between all of them.\n  const rows: Map<string, DedupedArtifact> = new Map()\n  artifacts.forEach(artifact => {\n    const purl = `pkg:${artifact.type}/${artifact.namespace ? `${artifact.namespace}/` : ''}${artifact.name}${artifact.version ? `@${artifact.version}` : ''}`\n    if (rows.has(purl)) {\n      const row = rows.get(purl)\n      if (!row) {\n        // unreachable; satisfy TS\n        return\n      }\n\n      if ((artifact.score?.supplyChain || 100) < row.score.supplyChain) {\n        row.score.supplyChain = artifact.score?.supplyChain || 100\n      }\n      if ((artifact.score?.maintenance || 100) < row.score.maintenance) {\n        row.score.maintenance = artifact.score?.maintenance || 100\n      }\n      if ((artifact.score?.quality || 100) < row.score.quality) {\n        row.score.quality = artifact.score?.quality || 100\n      }\n      if ((artifact.score?.vulnerability || 100) < row.score.vulnerability) {\n        row.score.vulnerability = artifact.score?.vulnerability || 100\n      }\n      if ((artifact.score?.license || 100) < row.score.license) {\n        row.score.license = artifact.score?.license || 100\n      }\n\n      artifact.alerts?.forEach(({ severity, type }) => {\n        row.alerts.set(`${type}:${severity}`, {\n          type: (type as string) ?? 'unknown',\n          severity: (severity as string) ?? 'none',\n        })\n      })\n    } else {\n      const alerts = new Map()\n      artifact.alerts?.forEach(({ severity, type }) => {\n        alerts.set(`${type}:${severity}`, {\n          type: (type as string) ?? 'unknown',\n          severity: (severity as string) ?? 'none',\n        })\n      })\n\n      rows.set(purl, {\n        ecosystem: artifact.type,\n        namespace: artifact.namespace || '',\n        name: artifact.name,\n        version: artifact.version || '',\n        score: {\n          supplyChain: artifact.score?.supplyChain || 100,\n          maintenance: artifact.score?.maintenance || 100,\n          quality: artifact.score?.quality || 100,\n          vulnerability: artifact.score?.vulnerability || 100,\n          license: artifact.score?.license || 100,\n        },\n        alerts,\n      })\n    }\n  })\n\n  return { rows, missing }\n}\n\nexport function generateMarkdownReport(\n  artifacts: Map<string, DedupedArtifact>,\n  missing: string[],\n): string {\n  const blocks: string[] = []\n  const dupes: Set<string> = new Set()\n  artifacts.forEach(artifact => {\n    const block = '## ' + formatReportCard(artifact, false)\n    if (dupes.has(block)) {\n      return\n    }\n    dupes.add(block)\n    blocks.push(block)\n  })\n\n  return `\n# Shallow Package Report\n\nThis report contains the response for requesting data on some package url(s).\n\nPlease note: The listed scores are ONLY for the package itself. It does NOT\n             reflect the scores of any dependencies, transitive or otherwise.\n\n${missing.length ? `\\n## Missing response\\n\\nAt least one package had no response or the purl was not canonical:\\n\\n${missing.map(purl => '- ' + purl + '\\n').join('')}` : ''}\n\n${blocks.join('\\n\\n\\n')}\n    `.trim()\n}\n\nexport function generateTextReport(\n  artifacts: Map<string, DedupedArtifact>,\n  missing: string[],\n): string {\n  const arr: string[] = []\n\n  arr.push('\\n' + colors.bold('Shallow Package Score') + '\\n')\n  arr.push(\n    'Please note: The listed scores are ONLY for the package itself. It does NOT\\n' +\n      '             reflect the scores of any dependencies, transitive or otherwise.',\n  )\n\n  if (missing.length) {\n    arr.push(\n      `\\nAt least one package had no response or the purl was not canonical:\\n${missing.map(purl => '\\n- ' + colors.bold(purl)).join('')}`,\n    )\n  }\n\n  const dupes: Set<string> = new Set() // Omit dupes when output is identical\n  artifacts.forEach(artifact => {\n    const block = formatReportCard(artifact, true)\n    if (dupes.has(block)) {\n      return\n    }\n    dupes.add(block)\n    arr.push('\\n')\n    arr.push(block)\n  })\n  arr.push('')\n\n  return arr.join('\\n')\n}\n","import { fetchPurlsShallowScore } from './fetch-purls-shallow-score.mts'\nimport { outputPurlsShallowScore } from './output-purls-shallow-score.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketArtifact } from '../../utils/alert/artifact.mts'\n\nexport async function handlePurlsShallowScore({\n  outputKind,\n  purls,\n}: {\n  outputKind: OutputKind\n  purls: string[]\n}) {\n  const packageData = await fetchPurlsShallowScore(purls)\n\n  outputPurlsShallowScore(\n    purls,\n    packageData as CResult<SocketArtifact[]>,\n    outputKind,\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handlePurlsShallowScore } from './handle-purls-shallow-score.mts'\nimport { parsePackageSpecifiers } from './parse-package-specifiers.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'shallow',\n  description:\n    'Look up info regarding one or more packages but not their transitives',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <<ecosystem> <name> [<name> ...] | <purl> [<purl> ...]>\n\n    API Token Requirements\n      - Quota: 100 units\n      - Permissions: packages:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Show scoring details for one or more packages purely based on their own package.\n    This means that any dependency scores are not reflected by the score. You can\n    use the \\`socket package score <pkg>\\` command to get its full transitive score.\n\n    Only a few ecosystems are supported like npm, golang, and maven.\n\n    A \"purl\" is a standard package name formatting: \\`pkg:eco/name@version\\`\n    This command will automatically prepend \"pkg:\" when not present.\n\n    If the first arg is an ecosystem, remaining args that are not a purl are\n    assumed to be scoped to that ecosystem.\n\n    Examples\n      $ ${command} npm webtorrent\n      $ ${command} npm webtorrent@1.9.1\n      $ ${command} npm/webtorrent@1.9.1\n      $ ${command} pkg:npm/webtorrent@1.9.1\n      $ ${command} maven webtorrent babel\n      $ ${command} npm/webtorrent golang/babel\n      $ ${command} npm npm/webtorrent@1.0.1 babel\n  `,\n}\n\nexport const cmdPackageShallow = {\n  description: config.description,\n  hidden: config.hidden,\n  alias: {\n    shallowScore: {\n      description: config.description,\n      hidden: true,\n      argv: [],\n    },\n  },\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [ecosystem = '', ...pkgs] = cli.input\n\n  const { purls, valid } = parsePackageSpecifiers(ecosystem, pkgs)\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: valid,\n      message:\n        'First parameter should be an ecosystem or all args must be purls',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      test: purls.length > 0,\n      message: 'Expecting at least one package',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handlePurlsShallowScore({\n    outputKind,\n    purls,\n  })\n}\n","import { cmdPackageScore } from './cmd-package-score.mts'\nimport { cmdPackageShallow } from './cmd-package-shallow.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Commands relating to looking up published packages'\n\nexport const cmdPackage: CliSubcommand = {\n  description,\n  hidden: false,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        score: cmdPackageScore,\n        shallow: cmdPackageShallow,\n      },\n      {\n        aliases: {\n          deep: {\n            description,\n            hidden: true,\n            argv: ['score'],\n          },\n        },\n        argv,\n        description,\n        importMeta,\n        name: parentName + ' package',\n      },\n    )\n  },\n}\n","import { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\nimport { getNpmBinPath } from '../../utils/npm-paths.mts'\n\nexport async function runRawNpm(\n  argv: string[] | readonly string[],\n): Promise<void> {\n  const spawnPromise = spawn(getNpmBinPath(), argv as string[], {\n    // Lazily access constants.WIN32.\n    shell: constants.WIN32,\n    stdio: 'inherit',\n  })\n  // See https://nodejs.org/api/child_process.html#event-exit.\n  spawnPromise.process.on('exit', (code, signalName) => {\n    if (signalName) {\n      process.kill(process.pid, signalName)\n    } else if (code !== null) {\n      // eslint-disable-next-line n/no-process-exit\n      process.exit(code)\n    }\n  })\n  await spawnPromise\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { runRawNpm } from './run-raw-npm.mts'\nimport constants from '../../constants.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW, NPM } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'raw-npm',\n  description: `Temporarily disable the Socket ${NPM} wrapper`,\n  hidden: false,\n  flags: {},\n  help: command => `\n    Usage\n      $ ${command} <command>\n\n    Examples\n      $ ${command} install\n  `,\n}\n\nexport const cmdRawNpm = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    allowUnknownFlags: true,\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await runRawNpm(argv)\n}\n","import { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\nimport { getNpxBinPath } from '../../utils/npm-paths.mts'\n\nexport async function runRawNpx(\n  argv: string[] | readonly string[],\n): Promise<void> {\n  const spawnPromise = spawn(getNpxBinPath(), argv as string[], {\n    // Lazily access constants.WIN32.\n    shell: constants.WIN32,\n    stdio: 'inherit',\n  })\n  // See https://nodejs.org/api/child_process.html#event-exit.\n  spawnPromise.process.on('exit', (code, signalName) => {\n    if (signalName) {\n      process.kill(process.pid, signalName)\n    } else if (code !== null) {\n      // eslint-disable-next-line n/no-process-exit\n      process.exit(code)\n    }\n  })\n  await spawnPromise\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { runRawNpx } from './run-raw-npx.mts'\nimport constants from '../../constants.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW, NPX } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'raw-npx',\n  description: `Temporarily disable the Socket ${NPX} wrapper`,\n  hidden: false,\n  flags: {},\n  help: command => `\n    Usage\n      $ ${command} <command>\n\n    Examples\n      $ ${command} install\n  `,\n}\n\nexport const cmdRawNpx = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    allowUnknownFlags: true,\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await runRawNpx(argv)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst config: CliCommandConfig = {\n  commandName: 'create',\n  description: '[Deprecated] Create a project report',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n  },\n  help: () => `\n    This command is deprecated in favor of \\`socket scan view\\`.\n    It will be removed in the next major release of the CLI.\n  `,\n}\n\nexport const cmdReportCreate = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  logger.fail(\n    'This command has been sunset. Instead, please look at `socket scan create` to create scans and `socket scan report` to view a report of your scans.',\n  )\n\n  process.exitCode = 1\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst config: CliCommandConfig = {\n  commandName: 'view',\n  description: '[Deprecated] View a project report',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n  },\n  help: () => `\n    This command is deprecated in favor of \\`socket scan view\\`.\n    It will be removed in the next major release of the CLI.\n  `,\n}\n\nexport const cmdReportView = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  logger.fail(\n    'This command has been sunset. Instead, please look at `socket scan create` to create scans and `socket scan report` to view a report of your scans.',\n  )\n\n  process.exitCode = 1\n}\n","import { cmdReportCreate } from './cmd-report-create.mts'\nimport { cmdReportView } from './cmd-report-view.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = '[Deprecated] Project report related commands'\n\nexport const cmdReport: CliSubcommand = {\n  description,\n  hidden: true, // Deprecated in favor of `scan`\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        create: cmdReportCreate,\n        view: cmdReportView,\n      },\n      {\n        argv,\n        description,\n        importMeta,\n        name: parentName + ' report',\n      },\n    )\n  },\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchCreateRepo({\n  default_branch,\n  description,\n  homepage,\n  orgSlug,\n  repoName,\n  visibility,\n}: {\n  orgSlug: string\n  repoName: string\n  description: string\n  homepage: string\n  default_branch: string\n  visibility: string\n}): Promise<CResult<SocketSdkReturnType<'createOrgRepo'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.createOrgRepo(orgSlug, {\n      name: repoName,\n      description,\n      homepage,\n      default_branch,\n      visibility,\n    }),\n    'to create a repository',\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport function outputCreateRepo(\n  result: CResult<SocketSdkReturnType<'createOrgRepo'>['data']>,\n  requestedName: string,\n  outputKind: OutputKind,\n): void {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n  const { slug } = result.data\n  logger.success(\n    `OK. Repository created successfully, slug: \\`${slug}\\`${slug !== requestedName ? ' (Warning: slug is not the same as name that was requested!)' : ''}`,\n  )\n}\n","import { fetchCreateRepo } from './fetch-create-repo.mts'\nimport { outputCreateRepo } from './output-create-repo.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleCreateRepo(\n  {\n    default_branch,\n    description,\n    homepage,\n    orgSlug,\n    repoName,\n    visibility,\n  }: {\n    orgSlug: string\n    repoName: string\n    description: string\n    homepage: string\n    default_branch: string\n    visibility: string\n  },\n  outputKind: OutputKind,\n): Promise<void> {\n  const data = await fetchCreateRepo({\n    default_branch,\n    description,\n    homepage,\n    orgSlug,\n    repoName,\n    visibility,\n  })\n  outputCreateRepo(data, repoName, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleCreateRepo } from './handle-create-repo.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'create',\n  description: 'Create a repository in an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    defaultBranch: {\n      type: 'string',\n      shortFlag: 'b',\n      default: 'main',\n      description: 'Repository default branch',\n    },\n    homepage: {\n      type: 'string',\n      shortFlag: 'h',\n      default: '',\n      description: 'Repository url',\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n    repoDescription: {\n      type: 'string',\n      shortFlag: 'd',\n      default: '',\n      description: 'Repository description',\n    },\n    repoName: {\n      type: 'string',\n      shortFlag: 'n',\n      default: '',\n      description: 'Repository name',\n    },\n    visibility: {\n      type: 'string',\n      shortFlag: 'v',\n      default: 'private',\n      description: 'Repository visibility (Default Private)',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: repo:create\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? 'test-repo' : 'FakeOrg --repoName=test-repo'}\n  `,\n}\n\nexport const cmdReposCreate = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const {\n    dryRun,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n    repoName: repoNameFlag,\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const repoName = (isTestingV1() ? cli.input[0] : repoNameFlag) || ''\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      test: !!repoName,\n      message: isTestingV1()\n        ? 'Repository name as first argument'\n        : 'Repository name using --repoName',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n    {\n      nook: true,\n      test: !isTestingV1() || !repoNameFlag,\n      message: 'In v1 the first arg should be the repo, not the flag',\n      pass: 'ok',\n      fail: 'received --repo-name flag',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (dryRun) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleCreateRepo(\n    {\n      orgSlug,\n      repoName: String(repoName),\n      description: String(cli.flags['repoDescription'] || ''),\n      homepage: String(cli.flags['homepage'] || ''),\n      default_branch: String(cli.flags['defaultBranch'] || ''),\n      visibility: String(cli.flags['visibility'] || 'private'),\n    },\n    outputKind,\n  )\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchDeleteRepo(\n  orgSlug: string,\n  repoName: string,\n): Promise<CResult<SocketSdkReturnType<'deleteOrgRepo'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.deleteOrgRepo(orgSlug, repoName),\n    'to delete a repository',\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputDeleteRepo(\n  result: CResult<SocketSdkReturnType<'deleteOrgRepo'>['data']>,\n  repoName: string,\n  outputKind: OutputKind,\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.success(`OK. Repository \\`${repoName}\\` deleted successfully`)\n}\n","import { fetchDeleteRepo } from './fetch-delete-repo.mts'\nimport { outputDeleteRepo } from './output-delete-repo.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleDeleteRepo(\n  orgSlug: string,\n  repoName: string,\n  outputKind: OutputKind,\n) {\n  const data = await fetchDeleteRepo(orgSlug, repoName)\n\n  await outputDeleteRepo(data, repoName, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleDeleteRepo } from './handle-delete-repo.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'del',\n  description: 'Delete a repository in an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: repo:delete\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? 'test-repo' : 'FakeOrg test-repo'}\n  `,\n}\n\nexport const cmdReposDel = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const repoName =\n    (defaultOrgSlug || isTestingV1() ? cli.input[0] : cli.input[1]) || ''\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      test: !!repoName,\n      message: isTestingV1()\n        ? 'Repository name as first argument'\n        : 'Repository name using --repoName',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (dryRun) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleDeleteRepo(orgSlug, repoName, outputKind)\n}\n","import { debugFn } from '@socketsecurity/registry/lib/debug'\n\nimport { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchListAllRepos({\n  direction,\n  orgSlug,\n  sort,\n}: {\n  direction: string\n  orgSlug: string\n  sort: string\n}): Promise<CResult<SocketSdkReturnType<'getOrgRepoList'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  const rows: SocketSdkReturnType<'getOrgRepoList'>['data']['results'] = []\n  let protection = 0\n  let nextPage = 0\n  while (nextPage >= 0) {\n    if (++protection > 100) {\n      return {\n        ok: false,\n        message: 'Infinite loop detected',\n        cause: `Either there are over 100 pages of results or the fetch has run into an infinite loop. Breaking it off now. nextPage=${nextPage}`,\n      }\n    }\n    // eslint-disable-next-line no-await-in-loop\n    const result = await handleApiCall(\n      sockSdk.getOrgRepoList(orgSlug, {\n        sort,\n        direction,\n        per_page: String(100), // max\n        page: String(nextPage),\n      }),\n      'list of repositories',\n    )\n    if (!result.ok) {\n      debugFn('fail: fetch repo\\n', result)\n      return result\n    }\n\n    result.data.results.forEach(row => rows.push(row))\n    nextPage = result.data.nextPage ?? -1\n  }\n\n  return {\n    ok: true,\n    data: {\n      results: rows,\n      nextPage: null,\n    },\n  }\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchListRepos({\n  direction,\n  orgSlug,\n  page,\n  per_page,\n  sort,\n}: {\n  direction: string\n  orgSlug: string\n  page: number\n  per_page: number\n  sort: string\n}): Promise<CResult<SocketSdkReturnType<'getOrgRepoList'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgRepoList(orgSlug, {\n      sort,\n      direction,\n      per_page: String(per_page),\n      page: String(page),\n    }),\n    'list of repositories',\n  )\n}\n","// @ts-ignore\nimport chalkTable from 'chalk-table'\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputListRepos(\n  result: CResult<SocketSdkReturnType<'getOrgRepoList'>['data']>,\n  outputKind: OutputKind,\n  page: number,\n  nextPage: number | null,\n  sort: string,\n  perPage: number,\n  direction: 'asc' | 'desc',\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    if (result.ok) {\n      logger.log(\n        serializeResultJson({\n          ok: true,\n          data: {\n            data: result.data,\n            direction,\n            nextPage: nextPage ?? 0,\n            page,\n            perPage,\n            sort,\n          },\n        }),\n      )\n    } else {\n      logger.log(serializeResultJson(result))\n    }\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.log(\n    `Result page: ${page}, results per page: ${perPage === Infinity ? 'all' : perPage}, sorted by: ${sort}, direction: ${direction}`,\n  )\n\n  const options = {\n    columns: [\n      { field: 'id', name: colors.magenta('ID') },\n      { field: 'name', name: colors.magenta('Name') },\n      { field: 'visibility', name: colors.magenta('Visibility') },\n      { field: 'default_branch', name: colors.magenta('Default branch') },\n      { field: 'archived', name: colors.magenta('Archived') },\n    ],\n  }\n\n  logger.log(chalkTable(options, result.data.results))\n  if (nextPage) {\n    logger.info(\n      `This is page ${page}. Server indicated there are more results available on page ${nextPage}...`,\n    )\n    logger.info(`(Hint: you can use \\`socket repos list --page ${nextPage}\\`)`)\n  } else if (perPage === Infinity) {\n    logger.info(`This should be the entire list available on the server.`)\n  } else {\n    logger.info(\n      `This is page ${page}. Server indicated this is the last page with results.`,\n    )\n  }\n}\n","import { fetchListAllRepos } from './fetch-list-all-repos.mts'\nimport { fetchListRepos } from './fetch-list-repos.mts'\nimport { outputListRepos } from './output-list-repos.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleListRepos({\n  all,\n  direction,\n  orgSlug,\n  outputKind,\n  page,\n  per_page,\n  sort,\n}: {\n  all: boolean\n  direction: 'asc' | 'desc'\n  orgSlug: string\n  outputKind: OutputKind\n  page: number\n  per_page: number\n  sort: string\n}): Promise<void> {\n  if (all) {\n    const data = await fetchListAllRepos({ direction, orgSlug, sort })\n\n    await outputListRepos(data, outputKind, 0, 0, sort, Infinity, direction)\n  } else {\n    const data = await fetchListRepos({\n      direction,\n      orgSlug,\n      page,\n      per_page,\n      sort,\n    })\n\n    if (!data.ok) {\n      await outputListRepos(data, outputKind, 0, 0, '', 0, direction)\n    } else {\n      // Note: nextPage defaults to 0, is null when there's no next page\n      await outputListRepos(\n        data,\n        outputKind,\n        page,\n        data.data.nextPage,\n        sort,\n        per_page,\n        direction,\n      )\n    }\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleListRepos } from './handle-list-repos.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'list',\n  description: 'List repositories in an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    all: {\n      type: 'boolean',\n      default: false,\n      description:\n        'By default view shows the last n repos. This flag allows you to fetch the entire list. Will ignore --page and --perPage.',\n    },\n    direction: {\n      type: 'string',\n      default: 'desc',\n      description: 'Direction option',\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n    perPage: {\n      type: 'number',\n      shortFlag: 'pp',\n      default: 30,\n      description: 'Number of results per page',\n    },\n    page: {\n      type: 'number',\n      shortFlag: 'p',\n      default: 1,\n      description: 'Page number',\n    },\n    sort: {\n      type: 'string',\n      shortFlag: 's',\n      default: 'created_at',\n      description: 'Sorting option',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '' : '<org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: repo:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? '' : '<org slug>'}\n  `,\n}\n\nexport const cmdReposList = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const {\n    all,\n    direction = 'desc',\n    dryRun,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n    {\n      nook: true,\n      test: direction === 'asc' || direction === 'desc',\n      message: 'The --direction value must be \"asc\" or \"desc\"',\n      pass: 'ok',\n      fail: 'unexpected value',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleListRepos({\n    all: Boolean(all),\n    direction: direction === 'asc' ? 'asc' : 'desc',\n    orgSlug,\n    outputKind,\n    page: Number(cli.flags['page']) || 1,\n    per_page: Number(cli.flags['perPage']) || 30,\n    sort: String(cli.flags['sort'] || 'created_at'),\n  })\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchUpdateRepo({\n  default_branch,\n  description,\n  homepage,\n  orgSlug,\n  repoName,\n  visibility,\n}: {\n  orgSlug: string\n  repoName: string\n  description: string\n  homepage: string\n  default_branch: string\n  visibility: string\n}): Promise<CResult<SocketSdkReturnType<'updateOrgRepo'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.updateOrgRepo(orgSlug, repoName, {\n      orgSlug,\n      name: repoName,\n      description,\n      homepage,\n      default_branch,\n      visibility,\n    }),\n    'to update a repository',\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputUpdateRepo(\n  result: CResult<SocketSdkReturnType<'updateOrgRepo'>['data']>,\n  repoName: string,\n  outputKind: OutputKind,\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.success(`Repository \\`${repoName}\\` updated successfully`)\n}\n","import { fetchUpdateRepo } from './fetch-update-repo.mts'\nimport { outputUpdateRepo } from './output-update-repo.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleUpdateRepo(\n  {\n    default_branch,\n    description,\n    homepage,\n    orgSlug,\n    repoName,\n    visibility,\n  }: {\n    orgSlug: string\n    repoName: string\n    description: string\n    homepage: string\n    default_branch: string\n    visibility: string\n  },\n  outputKind: OutputKind,\n): Promise<void> {\n  const data = await fetchUpdateRepo({\n    default_branch,\n    description,\n    homepage,\n    orgSlug,\n    repoName,\n    visibility,\n  })\n\n  await outputUpdateRepo(data, repoName, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleUpdateRepo } from './handle-update-repo.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'update',\n  description: 'Update a repository in an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    defaultBranch: {\n      type: 'string',\n      shortFlag: 'b',\n      default: 'main',\n      description: 'Repository default branch',\n    },\n    homepage: {\n      type: 'string',\n      shortFlag: 'h',\n      default: '',\n      description: 'Repository url',\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n    repoName: {\n      type: 'string',\n      shortFlag: 'n',\n      default: '',\n      description: 'Repository name',\n    },\n    repoDescription: {\n      type: 'string',\n      shortFlag: 'd',\n      default: '',\n      description: 'Repository description',\n    },\n    visibility: {\n      type: 'string',\n      shortFlag: 'v',\n      default: 'private',\n      description: 'Repository visibility (Default Private)',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: repo:update\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? 'test-repo' : 'FakeOrg test-repo'}\n  `,\n}\n\nexport const cmdReposUpdate = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const repoNameFlag = cli.flags['repoName']\n  const repoName = (isTestingV1() ? cli.input[0] : repoNameFlag) || ''\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      test: !!repoName,\n      message: isTestingV1()\n        ? 'Repository name as first argument'\n        : 'Repository name using --repoName',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n    {\n      nook: true,\n      test: !isTestingV1() || !repoNameFlag,\n      message: 'In v1 the first arg should be the repo, not the flag',\n      pass: 'ok',\n      fail: 'received --repo-name flag',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleUpdateRepo(\n    {\n      orgSlug,\n      repoName: String(repoName),\n      description: String(cli.flags['repoDescription'] || ''),\n      homepage: String(cli.flags['homepage'] || ''),\n      default_branch: String(cli.flags['defaultBranch'] || ''),\n      visibility: String(cli.flags['visibility'] || 'private'),\n    },\n    outputKind,\n  )\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchViewRepo(\n  orgSlug: string,\n  repoName: string,\n): Promise<CResult<SocketSdkReturnType<'getOrgRepo'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgRepo(orgSlug, repoName),\n    'repository data',\n  )\n}\n","// @ts-ignore\nimport chalkTable from 'chalk-table'\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputViewRepo(\n  result: CResult<SocketSdkReturnType<'createOrgRepo'>['data']>,\n  outputKind: OutputKind,\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const options = {\n    columns: [\n      { field: 'id', name: colors.magenta('ID') },\n      { field: 'name', name: colors.magenta('Name') },\n      { field: 'visibility', name: colors.magenta('Visibility') },\n      { field: 'default_branch', name: colors.magenta('Default branch') },\n      { field: 'homepage', name: colors.magenta('Homepage') },\n      { field: 'archived', name: colors.magenta('Archived') },\n      { field: 'created_at', name: colors.magenta('Created at') },\n    ],\n  }\n\n  logger.log(chalkTable(options, [result.data]))\n}\n","import { fetchViewRepo } from './fetch-view-repo.mts'\nimport { outputViewRepo } from './output-view-repo.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleViewRepo(\n  orgSlug: string,\n  repoName: string,\n  outputKind: OutputKind,\n): Promise<void> {\n  const data = await fetchViewRepo(orgSlug, repoName)\n\n  await outputViewRepo(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleViewRepo } from './handle-view-repo.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'view',\n  description: 'View repositories in an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n    repoName: {\n      description: 'The repository to check',\n      default: '',\n      type: 'string',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: repo:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? 'test-repo' : 'FakeOrg test-repo'}\n  `,\n}\n\nexport const cmdReposView = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const {\n    dryRun,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n    repoName: repoNameFlag,\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const repoName = (isTestingV1() ? cli.input[0] : repoNameFlag) || ''\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      test: !!repoName,\n      message: isTestingV1()\n        ? 'Repository name as first argument'\n        : 'Repository name using --repoName',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n    {\n      nook: true,\n      test: !isTestingV1() || !repoNameFlag,\n      message: 'In v1 the first arg should be the repo, not the flag',\n      pass: 'ok',\n      fail: 'received --repo-name flag',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleViewRepo(orgSlug, String(repoName), outputKind)\n}\n","import { cmdReposCreate } from './cmd-repos-create.mts'\nimport { cmdReposDel } from './cmd-repos-del.mts'\nimport { cmdReposList } from './cmd-repos-list.mts'\nimport { cmdReposUpdate } from './cmd-repos-update.mts'\nimport { cmdReposView } from './cmd-repos-view.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Repositories related commands'\n\nexport const cmdRepos: CliSubcommand = {\n  description,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        create: cmdReposCreate,\n        view: cmdReposView,\n        list: cmdReposList,\n        del: cmdReposDel,\n        update: cmdReposUpdate,\n      },\n      {\n        argv,\n        description,\n        importMeta,\n        name: `${parentName} repos`,\n      },\n    )\n  },\n}\n","import { select } from '@socketsecurity/registry/lib/prompts'\n\nexport async function suggestTarget(): Promise<string[] | void> {\n  // We could prefill this with sub-dirs of the current\n  // dir ... but is that going to be useful?\n  const proceed = await select<boolean>({\n    message: 'No TARGET given. Do you want to use the current directory?',\n    choices: [\n      {\n        name: 'Yes',\n        value: true,\n        description: 'Target the current directory',\n      },\n      {\n        name: 'No',\n        value: false,\n        description:\n          'Do not use the current directory (this will end in a no-op)',\n      },\n    ],\n  })\n  if (proceed) {\n    return ['.']\n  }\n}\n","import path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleCreateNewScan } from './handle-create-new-scan.mts'\nimport { suggestOrgSlug } from './suggest-org-slug.mts'\nimport { suggestTarget } from './suggest_target.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\nimport { readOrDefaultSocketJson } from '../../utils/socketjson.mts'\nimport { detectManifestActions } from '../manifest/detect-manifest-actions.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'create',\n  description: 'Create a scan',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    autoManifest: {\n      type: 'boolean',\n      description:\n        'Run `socket manifest auto` before collecting manifest files? This would be necessary for languages like Scala, Gradle, and Kotlin, See `socket manifest auto --help`.',\n    },\n    branch: {\n      type: 'string',\n      shortFlag: 'b',\n      description: 'Branch name',\n    },\n    commitMessage: {\n      type: 'string',\n      shortFlag: 'm',\n      default: '',\n      description: 'Commit message',\n    },\n    commitHash: {\n      type: 'string',\n      shortFlag: 'ch',\n      default: '',\n      description: 'Commit hash',\n    },\n    committers: {\n      type: 'string',\n      shortFlag: 'c',\n      default: '',\n      description: 'Committers',\n    },\n    cwd: {\n      type: 'string',\n      description: 'working directory, defaults to process.cwd()',\n    },\n    defaultBranch: {\n      type: 'boolean',\n      default: false,\n      description:\n        'Set the default branch of the repository to the branch of this full-scan. Should only need to be done once, for example for the \"main\" or \"master\" branch.',\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    pullRequest: {\n      type: 'number',\n      shortFlag: 'pr',\n      description: 'Commit hash',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n    readOnly: {\n      type: 'boolean',\n      default: false,\n      description:\n        'Similar to --dry-run except it can read from remote, stops before it would create an actual report',\n    },\n    repo: {\n      type: 'string',\n      shortFlag: 'r',\n      description: 'Repository name',\n    },\n    report: {\n      type: 'boolean',\n      description:\n        'Wait for the scan creation to complete, then basically run `socket scan report` on it',\n    },\n    setAsAlertsPage: {\n      type: 'boolean',\n      default: true,\n      aliases: ['pendingHead'],\n      description:\n        'When true and if this is the \"default branch\" then this Scan will be the one reflected on your alerts page. See help for details. Defaults to true.',\n    },\n    tmp: {\n      type: 'boolean',\n      shortFlag: 't',\n      default: false,\n      description:\n        'Set the visibility (true/false) of the scan in your dashboard.',\n    },\n  },\n  // TODO: your project's \"socket.yml\" file's \"projectIgnorePaths\"\n  help: (command, config) => `\n    Usage\n      $ ${command} [options]${isTestingV1() ? '' : ' <org>'} [TARGET...]\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:create\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Uploads the specified dependency manifest files for Go, Gradle, JavaScript,\n    Kotlin, Python, and Scala. Files like \"package.json\" and \"requirements.txt\".\n    If any folder is specified, the ones found in there recursively are uploaded.\n\n    Details on TARGET:\n\n    - Defaults to the current dir (cwd) if none given\n    - Multiple targets can be specified\n    - If a target is a file, only that file is checked\n    - If it is a dir, the dir is scanned for any supported manifest files\n    - Dirs MUST be within the current dir (cwd), you can use --cwd to change it\n    - Supports globbing such as \"**/package.json\", \"**/requirements.txt\", etc.\n    - Ignores any file specified in your project's \".gitignore\"\n    - Also a sensible set of default ignores from the \"ignore-by-default\" module\n\n    The --repo and --branch flags tell Socket to associate this Scan with that\n    repo/branch. The names will show up on your dashboard on the Socket website.\n\n    Note: for a first run you probably want to set --defaultBranch to indicate\n          the default branch name, like \"main\" or \"master\".\n\n    The \"alerts page\" (https://socket.dev/dashboard/org/YOURORG/alerts) will show\n    the results from the last scan designated as the \"pending head\" on the branch\n    configured on Socket to be the \"default branch\". When creating a scan the\n    --setAsAlertsPage flag will default to true to update this. You can prevent\n    this by using --no-setAsAlertsPage. This flag is ignored for any branch that\n    is not designated as the \"default branch\". It is disabled when using --tmp.\n\n    You can use \\`socket scan setup\\` to configure certain repo flag defaults.\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'}\n      $ ${command} --repo=test-repo --branch=main${isTestingV1() ? '' : ' FakeOrg'} ./package.json\n  `,\n}\n\nexport const cmdScanCreate = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const {\n    commitHash,\n    commitMessage,\n    committers,\n    cwd: cwdOverride,\n    defaultBranch,\n    dryRun = false,\n    interactive = true,\n    json,\n    markdown,\n    org: orgFlag,\n    pullRequest,\n    readOnly,\n    setAsAlertsPage: pendingHeadFlag,\n    tmp,\n  } = cli.flags as {\n    cwd: string\n    commitHash: string\n    commitMessage: string\n    committers: string\n    defaultBranch: boolean\n    dryRun: boolean\n    interactive: boolean\n    json: boolean\n    markdown: boolean\n    org: string\n    pullRequest: number\n    readOnly: boolean\n    setAsAlertsPage: boolean\n    tmp: boolean\n  }\n  let {\n    autoManifest,\n    branch: branchName,\n    repo: repoName,\n    report,\n  } = cli.flags as {\n    autoManifest?: boolean\n    branch: string\n    repo: string\n    report?: boolean\n  }\n  const outputKind = getOutputKind(json, markdown)\n\n  const pendingHead = tmp ? false : pendingHeadFlag\n\n  let [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    interactive,\n    dryRun,\n  )\n  if (!defaultOrgSlug) {\n    // Tmp. just for TS. will drop this later.\n    defaultOrgSlug = ''\n  }\n\n  // Accept zero or more paths. Default to cwd() if none given.\n  let targets =\n    cli.input.slice(isTestingV1() || defaultOrgSlug ? 0 : 1) || process.cwd()\n\n  const cwd =\n    cwdOverride && cwdOverride !== 'process.cwd()'\n      ? path.resolve(process.cwd(), String(cwdOverride))\n      : process.cwd()\n\n  const socketJson = await readOrDefaultSocketJson(cwd)\n\n  // Note: This needs meow booleanDefault=undefined\n  if (typeof autoManifest !== 'boolean') {\n    if (socketJson.defaults?.scan?.create?.autoManifest !== undefined) {\n      autoManifest = socketJson.defaults.scan.create.autoManifest\n      logger.info(\n        'Using default --autoManifest from socket.json:',\n        autoManifest,\n      )\n    } else {\n      autoManifest = false\n    }\n  }\n  if (!branchName) {\n    if (socketJson.defaults?.scan?.create?.branch) {\n      branchName = socketJson.defaults.scan.create.branch\n      logger.info('Using default --branch from socket.json:', branchName)\n    } else {\n      branchName = 'socket-default-branch'\n    }\n  }\n  if (!repoName) {\n    if (socketJson.defaults?.scan?.create?.repo) {\n      repoName = socketJson.defaults.scan.create.repo\n      logger.info('Using default --repo from socket.json:', repoName)\n    } else {\n      repoName = 'socket-default-repository'\n    }\n  }\n  if (typeof report !== 'boolean') {\n    if (socketJson.defaults?.scan?.create?.report !== undefined) {\n      report = socketJson.defaults.scan.create.report\n      logger.info('Using default --report from socket.json:', report)\n    } else {\n      report = false\n    }\n  }\n\n  // We're going to need an api token to suggest data because those suggestions\n  // must come from data we already know. Don't error on missing api token yet.\n  // If the api-token is not set, ignore it for the sake of suggestions.\n  const hasApiToken = hasDefaultToken()\n\n  // If we updated any inputs then we should print the command line to repeat\n  // the command without requiring user input, as a suggestion.\n  let updatedInput = false\n\n  if (!targets.length && !dryRun && interactive) {\n    const received = await suggestTarget()\n    targets = received ?? []\n    updatedInput = true\n  }\n\n  // If the current cwd is unknown and is used as a repo slug anyways, we will\n  // first need to register the slug before we can use it.\n  // Only do suggestions with an apiToken and when not in dryRun mode\n  if (hasApiToken && !dryRun && interactive) {\n    if (!orgSlug) {\n      const suggestion = await suggestOrgSlug()\n      if (suggestion) {\n        orgSlug = suggestion\n      }\n      updatedInput = true\n    }\n  }\n\n  const detected = await detectManifestActions(socketJson, cwd)\n  if (detected.count > 0 && !autoManifest) {\n    logger.info(\n      `Detected ${detected.count} manifest targets we could try to generate. Please set the --autoManifest flag if you want to include languages covered by \\`socket manifest auto\\` in the Scan.`,\n    )\n  }\n\n  if (updatedInput && orgSlug && targets?.length) {\n    logger.info(\n      'Note: You can invoke this command next time to skip the interactive questions:',\n    )\n    logger.info('```')\n    logger.info(\n      `    socket scan create [other flags...] ${defaultOrgSlug ? '' : orgSlug} ${targets.join(' ')}`,\n    )\n    logger.info('```\\n')\n  }\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !isTestingV1() && !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing',\n    },\n    {\n      test: !!targets.length,\n      message: 'At least one TARGET (e.g. `.` or `./package.json`)',\n      pass: 'ok',\n      fail: 'missing (or perhaps you forgot the org slug?)',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message: 'This command requires an API token for access',\n      pass: 'ok',\n      fail: 'missing (try `socket login`)',\n    },\n    {\n      nook: true,\n      test: !pendingHead || !!branchName,\n      message: 'When --pendingHead is set, --branch is mandatory',\n      pass: 'ok',\n      fail: 'missing branch name',\n    },\n    {\n      nook: true,\n      test: !defaultBranch || !!branchName,\n      message: 'When --defaultBranch is set, --branch is mandatory',\n      pass: 'ok',\n      fail: 'missing branch name',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  // Note exiting earlier to skirt a hidden auth requirement\n  if (dryRun) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleCreateNewScan({\n    autoManifest: Boolean(autoManifest),\n    branchName: branchName as string,\n    commitHash: (commitHash && String(commitHash)) || '',\n    commitMessage: (commitMessage && String(commitMessage)) || '',\n    committers: (committers && String(committers)) || '',\n    cwd,\n    defaultBranch: Boolean(defaultBranch),\n    interactive: Boolean(interactive),\n    orgSlug,\n    outputKind,\n    pendingHead: Boolean(pendingHead),\n    pullRequest: Number(pullRequest),\n    readOnly: Boolean(readOnly),\n    repoName: repoName,\n    report,\n    targets,\n    tmp: Boolean(tmp),\n  })\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchDeleteOrgFullScan(\n  orgSlug: string,\n  scanId: string,\n): Promise<CResult<SocketSdkReturnType<'deleteOrgFullScan'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.deleteOrgFullScan(orgSlug, scanId),\n    'to delete a scan',\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputDeleteScan(\n  result: CResult<SocketSdkReturnType<'deleteOrgFullScan'>['data']>,\n  outputKind: OutputKind,\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.success('Scan deleted successfully')\n}\n","import { fetchDeleteOrgFullScan } from './fetch-delete-org-full-scan.mts'\nimport { outputDeleteScan } from './output-delete-scan.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleDeleteScan(\n  orgSlug: string,\n  scanId: string,\n  outputKind: OutputKind,\n): Promise<void> {\n  const data = await fetchDeleteOrgFullScan(orgSlug, scanId)\n\n  await outputDeleteScan(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleDeleteScan } from './handle-delete-scan.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'del',\n  description: 'Delete a scan',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'} <scan ID>\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:delete\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0\n  `,\n}\n\nexport const cmdScanDel = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const scanId =\n    (isTestingV1() || defaultOrgSlug ? cli.input[0] : cli.input[1]) || ''\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing',\n    },\n    {\n      test: !!scanId,\n      message: 'Scan ID to delete',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleDeleteScan(orgSlug, scanId, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { queryApiSafeJson } from '../../utils/api.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchDiffScan({\n  id1,\n  id2,\n  orgSlug,\n}: {\n  id1: string\n  id2: string\n  orgSlug: string\n}): Promise<CResult<SocketSdkReturnType<'GetOrgDiffScan'>['data']>> {\n  logger.info('Scan ID 1:', id1)\n  logger.info('Scan ID 2:', id2)\n  logger.info('Note: this request may take some time if the scans are big')\n\n  return await queryApiSafeJson<SocketSdkReturnType<'GetOrgDiffScan'>['data']>(\n    `orgs/${orgSlug}/full-scans/diff?before=${encodeURIComponent(id1)}&after=${encodeURIComponent(id2)}`,\n    'a scan diff',\n  )\n}\n","import fs from 'node:fs'\nimport util from 'node:util'\n\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nconst { SOCKET_WEBSITE_URL } = constants\n\nconst SOCKET_SBOM_URL_PREFIX = `${SOCKET_WEBSITE_URL}/dashboard/org/SocketDev/sbom/`\n\nexport async function outputDiffScan(\n  result: CResult<SocketSdkReturnType<'GetOrgDiffScan'>['data']>,\n  {\n    depth,\n    file,\n    outputKind,\n  }: {\n    depth: number\n    file: string\n    outputKind: OutputKind\n  },\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const dashboardUrl = result.data.diff_report_url\n  const dashboardMessage = dashboardUrl\n    ? `\\n View this diff scan in the Socket dashboard: ${colors.cyan(dashboardUrl)}`\n    : ''\n\n  // When forcing json, or dumping to file, serialize to string such that it\n  // won't get truncated. The only way to dump the full raw JSON to stdout is\n  // to use `--json --file -` (the dash is a standard notation for stdout)\n  if (outputKind === 'json' || file) {\n    await handleJson(result, file, dashboardMessage)\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    await handleMarkdown(result.data)\n    return\n  }\n\n  // In this case neither the --json nor the --file flag was passed\n  // Dump the JSON to CLI and let NodeJS deal with truncation\n\n  logger.log('Diff scan result:')\n  logger.log(\n    util.inspect(result.data, {\n      showHidden: false,\n      depth: depth > 0 ? depth : null,\n      colors: true,\n      maxArrayLength: null,\n    }),\n  )\n  logger.info(\n    `\\n 📝 To display the detailed report in the terminal, use the --json flag. For a friendlier report, use the --markdown flag.\\n`,\n  )\n  logger.info(dashboardMessage)\n}\n\nasync function handleJson(\n  data: CResult<SocketSdkReturnType<'GetOrgDiffScan'>['data']>,\n  file: string,\n  dashboardMessage: string,\n) {\n  const json = serializeResultJson(data)\n\n  if (file && file !== '-') {\n    logger.log(`Writing json to \\`${file}\\``)\n    fs.writeFile(file, json, err => {\n      if (err) {\n        logger.fail(`Writing to \\`${file}\\` failed...`)\n        logger.error(err)\n      } else {\n        logger.success(`Data successfully written to \\`${file}\\``)\n      }\n      logger.error(dashboardMessage)\n    })\n  } else {\n    // only .log goes to stdout\n    logger.info(`\\n Diff scan result: \\n`)\n    logger.log(json)\n    logger.info(dashboardMessage)\n  }\n}\n\nasync function handleMarkdown(\n  data: SocketSdkReturnType<'GetOrgDiffScan'>['data'],\n) {\n  logger.log('# Scan diff result')\n  logger.log('')\n  logger.log('This Socket.dev report shows the changes between two scans:')\n  logger.log(\n    `- [${data.before.id}](${SOCKET_SBOM_URL_PREFIX}${data.before.id})`,\n  )\n  logger.log(`- [${data.after.id}](${SOCKET_SBOM_URL_PREFIX}${data.after.id})`)\n  logger.log('')\n  logger.log(\n    `You can [view this report in your dashboard](${data.diff_report_url})`,\n  )\n  logger.log('')\n  logger.log('## Changes')\n  logger.log('')\n  logger.log(`- directDependenciesChanged: ${data.directDependenciesChanged}`)\n  logger.log(`- Added packages: ${data.artifacts.added.length}`)\n  if (data.artifacts.added.length > 0) {\n    data.artifacts.added.slice(0, 10).forEach(artifact => {\n      logger.log(`  - ${artifact.type} ${artifact.name}@${artifact.version}`)\n    })\n    if (data.artifacts.added.length > 10) {\n      logger.log(`  ... and ${data.artifacts.added.length - 10} more`)\n    }\n  }\n  logger.log(`- Removed packages: ${data.artifacts.removed.length}`)\n  if (data.artifacts.removed.length > 0) {\n    data.artifacts.removed.slice(0, 10).forEach(artifact => {\n      logger.log(`  - ${artifact.type} ${artifact.name}@${artifact.version}`)\n    })\n    if (data.artifacts.removed.length > 10) {\n      logger.log(`  ... and ${data.artifacts.removed.length - 10} more`)\n    }\n  }\n  logger.log(`- Replaced packages: ${data.artifacts.replaced.length}`)\n  if (data.artifacts.replaced.length > 0) {\n    data.artifacts.replaced.slice(0, 10).forEach(artifact => {\n      logger.log(`  - ${artifact.type} ${artifact.name}@${artifact.version}`)\n    })\n    if (data.artifacts.replaced.length > 10) {\n      logger.log(`  ... and ${data.artifacts.replaced.length - 10} more`)\n    }\n  }\n  logger.log(`- Updated packages: ${data.artifacts.updated.length}`)\n  if (data.artifacts.updated.length > 0) {\n    data.artifacts.updated.slice(0, 10).forEach(artifact => {\n      logger.log(`  - ${artifact.type} ${artifact.name}@${artifact.version}`)\n    })\n    if (data.artifacts.updated.length > 10) {\n      logger.log(`  ... and ${data.artifacts.updated.length - 10} more`)\n    }\n  }\n  logger.log(`- Unchanged packages: ${data.artifacts.unchanged.length}`)\n  if (data.artifacts.unchanged.length > 0) {\n    data.artifacts.unchanged.slice(0, 10).forEach(artifact => {\n      logger.log(`  - ${artifact.type} ${artifact.name}@${artifact.version}`)\n    })\n    if (data.artifacts.unchanged.length > 10) {\n      logger.log(`  ... and ${data.artifacts.unchanged.length - 10} more`)\n    }\n  }\n  logger.log('')\n  logger.log(`## Scan ${data.before.id}`)\n  logger.log('')\n  logger.log(\n    'This Scan was considered to be the \"base\" / \"from\" / \"before\" Scan.',\n  )\n  logger.log('')\n  for (const [key, value] of Object.entries(data.before)) {\n    if (key === 'pull_request' && !value) {\n      continue\n    }\n    if (!['id', 'organization_id', 'repository_id'].includes(key)) {\n      logger.group(\n        `- ${key === 'repository_slug' ? 'repo' : key === 'organization_slug' ? 'org' : key}: ${value}`,\n      )\n      logger.groupEnd()\n    }\n  }\n  logger.log('')\n  logger.log(`## Scan ${data.after.id}`)\n  logger.log('')\n  logger.log('This Scan was considered to be the \"head\" / \"to\" / \"after\" Scan.')\n  logger.log('')\n  for (const [key, value] of Object.entries(data.after)) {\n    if (key === 'pull_request' && !value) {\n      continue\n    }\n    if (!['id', 'organization_id', 'repository_id'].includes(key)) {\n      logger.group(\n        `- ${key === 'repository_slug' ? 'repo' : key === 'organization_slug' ? 'org' : key}: ${value}`,\n      )\n      logger.groupEnd()\n    }\n  }\n  logger.log('')\n}\n","import { fetchDiffScan } from './fetch-diff-scan.mts'\nimport { outputDiffScan } from './output-diff-scan.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleDiffScan({\n  depth,\n  file,\n  id1,\n  id2,\n  orgSlug,\n  outputKind,\n}: {\n  depth: number\n  file: string\n  id1: string\n  id2: string\n  orgSlug: string\n  outputKind: OutputKind\n}): Promise<void> {\n  const data = await fetchDiffScan({\n    id1,\n    id2,\n    orgSlug,\n  })\n\n  await outputDiffScan(data, {\n    depth,\n    file,\n    outputKind,\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleDiffScan } from './handle-diff-scan.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW, SOCKET_WEBSITE_URL } = constants\n\nconst SOCKET_SBOM_URL_PREFIX = `${SOCKET_WEBSITE_URL}/dashboard/org/SocketDev/sbom/`\n\nconst { length: SOCKET_SBOM_URL_PREFIX_LENGTH } = SOCKET_SBOM_URL_PREFIX\n\nconst config: CliCommandConfig = {\n  commandName: 'diff',\n  description: 'See what changed between two Scans',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    depth: {\n      type: 'number',\n      default: 2,\n      description:\n        'Max depth of JSON to display before truncating, use zero for no limit (without --json/--file)',\n    },\n    file: {\n      type: 'string',\n      shortFlag: 'f',\n      default: '',\n      description:\n        'Path to a local file where the output should be saved. Use `-` to force stdout.',\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'} <ID1> <ID2>\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:list\n\n    This command displays the package changes between two scans. The full output\n    can be pretty large depending on the size of your repo and time range. It is\n    best stored to disk (with --json) to be further analyzed by other tools.\n\n    Note: First Scan ID is assumed to be the older ID. This is only relevant for\n          the added/removed list (similar to diffing two files with git).\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 aaa1aa1a-aaaa-1111-1a1a-1111111a11a1\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 aaa1aa1a-aaaa-1111-1a1a-1111111a11a1 --json\n  `,\n}\n\nexport const cmdScanDiff = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const {\n    depth,\n    dryRun,\n    file,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  let id1 = cli.input[isTestingV1() || orgSlug ? 0 : 1] || ''\n  let id2 = cli.input[isTestingV1() || orgSlug ? 1 : 2] || ''\n  if (id1.startsWith(SOCKET_SBOM_URL_PREFIX)) {\n    id1 = id1.slice(SOCKET_SBOM_URL_PREFIX_LENGTH)\n  }\n  if (id2.startsWith(SOCKET_SBOM_URL_PREFIX)) {\n    id2 = id2.slice(SOCKET_SBOM_URL_PREFIX_LENGTH)\n  }\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!(id1 && id2),\n      message:\n        'Specify two Scan IDs.\\nA Scan ID looks like `aaa0aa0a-aaaa-0000-0a0a-0000000a00a0`.',\n      pass: 'ok',\n      fail:\n        !id1 && !id2\n          ? 'missing both Scan IDs'\n          : !id2\n            ? 'missing second Scan ID'\n            : 'missing first Scan ID', // Not sure how this can happen but ok.\n    },\n    {\n      test: !!orgSlug,\n      nook: true,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleDiffScan({\n    id1: String(id1 || ''),\n    id2: String(id2 || ''),\n    depth: Number(depth),\n    orgSlug,\n    outputKind,\n    file: String(file || ''),\n  })\n}\n","import fs from 'node:fs'\nimport os from 'node:os'\nimport path from 'node:path'\nimport { pipeline } from 'node:stream/promises'\n\nimport { debugFn } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { confirm, select } from '@socketsecurity/registry/lib/prompts'\n\nimport { handleCreateNewScan } from './handle-create-new-scan.mts'\nimport { fetchListAllRepos } from '../repos/fetch-list-all-repos.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\n\n// Supported manifest file name patterns\n// Keep in mind that we have to request these files through the GitHub API; that cost is much heavier than local disk searches\n// TODO: get this list from API instead? Is that too much? Has to fetch through gh api...\nconst SUPPORTED_FILE_PATTERNS = [\n  /.*[-.]spdx\\.json/,\n  /bom\\.json/,\n  /.*[-.]cyclonedx\\.json/,\n  /.*[-.]cyclonedx\\.xml/,\n  /package\\.json/,\n  /package-lock\\.json/,\n  /npm-shrinkwrap\\.json/,\n  /yarn\\.lock/,\n  /pnpm-lock\\.yaml/,\n  /pnpm-lock\\.yml/,\n  /pnpm-workspace\\.yaml/,\n  /pnpm-workspace\\.yml/,\n  /pipfile/,\n  /pyproject\\.toml/,\n  /poetry\\.lock/,\n  /requirements[\\\\/].*\\.txt/,\n  /requirements-.*\\.txt/,\n  /requirements_.*\\.txt/,\n  /requirements\\.frozen/,\n  /setup\\.py/,\n  /pipfile\\.lock/,\n  /go\\.mod/,\n  /go\\.sum/,\n  /pom\\.xml/,\n  /.*\\..*proj/,\n  /.*\\.props/,\n  /.*\\.targets/,\n  /.*\\.nuspec/,\n  /nuget\\.config/,\n  /packages\\.config/,\n  /packages\\.lock\\.json/,\n]\n\nexport async function createScanFromGithub({\n  all,\n  githubApiUrl,\n  githubToken,\n  interactive,\n  orgGithub,\n  orgSlug,\n  outputKind,\n  repos,\n}: {\n  all: boolean\n  githubApiUrl: string\n  githubToken: string\n  interactive: boolean\n  orgSlug: string\n  orgGithub: string\n  outputKind: OutputKind\n  repos: string\n}): Promise<CResult<undefined>> {\n  let targetRepos: string[] = repos\n    .trim()\n    .split(',')\n    .map(repo => repo.trim())\n    .filter(Boolean)\n  if (all || targetRepos.length === 0) {\n    // Fetch from Socket API\n    const result = await fetchListAllRepos({\n      direction: 'asc',\n      orgSlug,\n      sort: 'name',\n    })\n    if (!result.ok) {\n      return result\n    }\n    targetRepos = result.data.results.map(obj => obj.slug || '')\n  }\n\n  targetRepos = targetRepos.map(slug => slug.trim()).filter(Boolean)\n\n  logger.info(`Have ${targetRepos.length} repo names to Scan!`)\n  logger.log('')\n\n  if (!targetRepos.filter(Boolean).length) {\n    return {\n      ok: false,\n      message: 'No repo found',\n      cause:\n        'You did not set the --repos value and/or the server responded with zero repos when asked for some. Unable to proceed.',\n    }\n  }\n\n  // Non-interactive or explicitly requested; just do it.\n  if (interactive && targetRepos.length > 1 && !all && !repos) {\n    const which = await selectFocus(targetRepos)\n    if (!which.ok) {\n      return which\n    }\n    targetRepos = which.data\n  }\n\n  // 10 is an arbitrary number. Maybe confirm whenever count>1 ?\n  // Do not ask to confirm when the list was given explicit.\n  if (interactive && (all || !repos) && targetRepos.length > 10) {\n    const sure = await makeSure(targetRepos.length)\n    if (!sure.ok) {\n      return sure\n    }\n  }\n\n  let scansCreated = 0\n  for (const repoSlug of targetRepos) {\n    // eslint-disable-next-line no-await-in-loop\n    const result = await scanRepo(repoSlug, {\n      githubApiUrl,\n      githubToken,\n      orgSlug,\n      orgGithub,\n      outputKind,\n      repos,\n    })\n    if (result.ok && result.data.scanCreated) {\n      scansCreated += 1\n    }\n  }\n\n  logger.success(targetRepos.length, 'GitHub repos detected')\n  logger.success(scansCreated, 'with supported Manifest files')\n\n  return {\n    ok: true,\n    data: undefined,\n  }\n}\n\nasync function scanRepo(\n  repoSlug: string,\n  {\n    githubApiUrl,\n    githubToken,\n    orgGithub,\n    orgSlug,\n    outputKind,\n    repos,\n  }: {\n    githubApiUrl: string\n    githubToken: string\n    orgSlug: string\n    orgGithub: string\n    outputKind: OutputKind\n    repos: string\n  },\n): Promise<CResult<{ scanCreated: boolean }>> {\n  logger.info(\n    `Requesting repo details from GitHub API for: \\`${orgGithub}/${repoSlug}\\`...`,\n  )\n  logger.group()\n  const result = await scanOneRepo(repoSlug, {\n    githubApiUrl,\n    githubToken,\n    orgSlug,\n    orgGithub,\n    outputKind,\n    repos,\n  })\n  logger.groupEnd()\n  logger.log('')\n  return result\n}\n\nasync function scanOneRepo(\n  repoSlug: string,\n  {\n    githubApiUrl,\n    githubToken,\n    orgGithub,\n    orgSlug,\n    outputKind,\n  }: {\n    githubApiUrl: string\n    githubToken: string\n    orgSlug: string\n    orgGithub: string\n    outputKind: OutputKind\n    repos: string\n  },\n): Promise<CResult<{ scanCreated: boolean }>> {\n  const repoResult = await getRepoDetails({\n    orgGithub,\n    repoSlug,\n    githubApiUrl,\n    githubToken,\n  })\n  if (!repoResult.ok) {\n    return repoResult\n  }\n  const { defaultBranch, repoApiUrl } = repoResult.data\n\n  logger.info(`Default branch: \\`${defaultBranch}\\``)\n\n  const treeResult = await getRepoBranchTree({\n    defaultBranch,\n    githubToken,\n    orgGithub,\n    repoSlug,\n    repoApiUrl,\n  })\n  if (!treeResult.ok) {\n    return treeResult\n  }\n  const files = treeResult.data\n\n  if (!files.length) {\n    logger.warn(\n      'No files were reported for the default branch. Moving on to next repo.',\n    )\n    return { ok: true, data: { scanCreated: false } }\n  }\n\n  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), repoSlug))\n  debugFn('init: temp dir for scan root', tmpDir)\n\n  const downloadResult = await testAndDownloadManifestFiles({\n    files,\n    tmpDir,\n    repoSlug,\n    defaultBranch,\n    orgGithub,\n    repoApiUrl,\n    githubToken,\n  })\n  if (!downloadResult.ok) {\n    return downloadResult\n  }\n\n  const commitResult = await getLastCommitDetails({\n    orgGithub,\n    repoSlug,\n    defaultBranch,\n    repoApiUrl,\n    githubToken,\n  })\n  if (!commitResult.ok) {\n    return commitResult\n  }\n\n  const { lastCommitMessage, lastCommitSha, lastCommitter } = commitResult.data\n\n  // Make request for full scan\n  // I think we can just kick off the socket scan create command now...\n\n  await handleCreateNewScan({\n    autoManifest: false,\n    branchName: defaultBranch,\n    commitHash: lastCommitSha,\n    commitMessage: lastCommitMessage || '',\n    committers: lastCommitter || '',\n    cwd: tmpDir,\n    defaultBranch: true,\n    interactive: false,\n    orgSlug,\n    outputKind,\n    pendingHead: true,\n    pullRequest: 0,\n    readOnly: false,\n    repoName: repoSlug,\n    report: false,\n    targets: ['.'],\n    tmp: false,\n  })\n\n  return { ok: true, data: { scanCreated: true } }\n}\n\nasync function testAndDownloadManifestFiles({\n  defaultBranch,\n  files,\n  githubToken,\n  orgGithub,\n  repoApiUrl,\n  repoSlug,\n  tmpDir,\n}: {\n  files: string[]\n  tmpDir: string\n  repoSlug: string\n  defaultBranch: string\n  orgGithub: string\n  repoApiUrl: string\n  githubToken: string\n}): Promise<CResult<unknown>> {\n  logger.info(\n    `File tree for ${defaultBranch} contains`,\n    files.length,\n    `entries. Searching for supported manifest files...`,\n  )\n  logger.group()\n  let fileCount = 0\n  let firstFailureResult\n  for (const file of files) {\n    // eslint-disable-next-line no-await-in-loop\n    const result = await testAndDownloadManifestFile({\n      file,\n      tmpDir,\n      defaultBranch,\n      repoApiUrl,\n      githubToken,\n    })\n    if (result.ok) {\n      if (result.data.isManifest) {\n        fileCount += 1\n      }\n    } else if (!firstFailureResult) {\n      firstFailureResult = result\n    }\n  }\n  logger.groupEnd()\n  logger.info('Found and downloaded', fileCount, 'manifest files')\n\n  if (!fileCount) {\n    if (firstFailureResult) {\n      logger.fail(\n        'While no supported manifest files were downloaded, at least one error encountered trying to do so. Showing the first error.',\n      )\n      return firstFailureResult\n    }\n    return {\n      ok: false,\n      message: 'No manifest files found',\n      cause: `No supported manifest files were found in the latest commit on the branch ${defaultBranch} for repo ${orgGithub}/${repoSlug}. Skipping full scan.`,\n    }\n  }\n\n  return { ok: true, data: undefined }\n}\n\nasync function testAndDownloadManifestFile({\n  defaultBranch,\n  file,\n  githubToken,\n  repoApiUrl,\n  tmpDir,\n}: {\n  file: string\n  tmpDir: string\n  defaultBranch: string\n  repoApiUrl: string\n  githubToken: string\n}): Promise<CResult<{ isManifest: boolean }>> {\n  debugFn('testing: file', file)\n\n  if (!SUPPORTED_FILE_PATTERNS.some(regex => regex.test(file))) {\n    debugFn('  - skip: not a known pattern')\n    // Not an error.\n    return { ok: true, data: { isManifest: false } }\n  }\n\n  debugFn('found: manifest file, going to attempt to download it;', file)\n\n  const result = await downloadManifestFile({\n    file,\n    tmpDir,\n    defaultBranch,\n    repoApiUrl,\n    githubToken,\n  })\n\n  return result.ok ? { ok: true, data: { isManifest: true } } : result\n}\n\nasync function downloadManifestFile({\n  defaultBranch,\n  file,\n  githubToken,\n  repoApiUrl,\n  tmpDir,\n}: {\n  file: string\n  tmpDir: string\n  defaultBranch: string\n  repoApiUrl: string\n  githubToken: string\n}): Promise<CResult<undefined>> {\n  debugFn('request: download url from GitHub')\n\n  const fileUrl = `${repoApiUrl}/contents/${file}?ref=${defaultBranch}`\n  debugFn('url: file', fileUrl)\n\n  const downloadUrlResponse = await fetch(fileUrl, {\n    method: 'GET',\n    headers: {\n      Authorization: `Bearer ${githubToken}`,\n    },\n  })\n  debugFn('complete: request')\n\n  const downloadUrlText = await downloadUrlResponse.text()\n  debugFn('response: raw download url', downloadUrlText)\n\n  let downloadUrl\n  try {\n    downloadUrl = JSON.parse(downloadUrlText).download_url\n  } catch {\n    logger.fail(\n      `GitHub response contained invalid JSON for download url for: ${file}`,\n    )\n\n    return {\n      ok: false,\n      message: 'Invalid JSON response',\n      cause: `Server responded with invalid JSON for download url ${downloadUrl}`,\n    }\n  }\n\n  const localPath = path.join(tmpDir, file)\n  debugFn('download: manifest file started', downloadUrl, '->', localPath)\n\n  // Now stream the file to that file...\n  const result = await streamDownloadWithFetch(localPath, downloadUrl)\n  if (!result.ok) {\n    // Do we proceed? Bail? Hrm...\n    logger.fail(\n      `Failed to download manifest file, skipping to next file. File: ${file}`,\n    )\n    return result\n  }\n\n  debugFn('download: manifest file completed')\n\n  return { ok: true, data: undefined }\n}\n\n// Courtesy of gemini:\nasync function streamDownloadWithFetch(\n  localPath: string,\n  downloadUrl: string,\n): Promise<CResult<string>> {\n  let response // Declare response here to access it in catch if needed\n\n  try {\n    response = await fetch(downloadUrl)\n\n    if (!response.ok) {\n      const errorMsg = `Download failed due to bad server response: ${response.status} ${response.statusText} for ${downloadUrl}`\n      logger.fail(errorMsg)\n      return { ok: false, message: 'Download Failed', cause: errorMsg }\n    }\n\n    if (!response.body) {\n      logger.fail(\n        `Download failed because the server response was empty, for ${downloadUrl}`,\n      )\n      return {\n        ok: false,\n        message: 'Download Failed',\n        cause: 'Response body is null or undefined.',\n      }\n    }\n\n    // Make sure the dir exists. It may be nested and we need to construct that\n    // before starting the download.\n    const dir = path.dirname(localPath)\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true })\n    }\n\n    const fileStream = fs.createWriteStream(localPath)\n\n    // Using stream.pipeline for better error handling and cleanup\n\n    await pipeline(response.body, fileStream)\n    // 'pipeline' will automatically handle closing streams and propagating errors.\n    // It resolves when the piping is fully complete and fileStream is closed.\n    return { ok: true, data: localPath }\n  } catch (error) {\n    logger.fail(\n      'An error was thrown while trying to download a manifest file... url:',\n      downloadUrl,\n    )\n    debugFn('Raw error:')\n    debugFn(error)\n\n    // If an error occurs and fileStream was created, attempt to clean up.\n    if (fs.existsSync(localPath)) {\n      // Check if fileStream was even opened before trying to delete\n      // This check might be too simplistic depending on when error occurs\n      fs.unlink(localPath, unlinkErr => {\n        if (unlinkErr) {\n          logger.fail(\n            `Error deleting partial file ${localPath}: ${unlinkErr.message}`,\n          )\n        }\n      })\n    }\n    // Construct a more informative error message\n    let detailedError = `Error during download of ${downloadUrl}: ${(error as { message: string }).message}`\n    if ((error as { cause: string }).cause) {\n      // Include cause if available (e.g., from network errors)\n      detailedError += `\\nCause: ${(error as { cause: string }).cause}`\n    }\n    if (response && !response.ok) {\n      // If error was due to bad HTTP status\n      detailedError += ` (HTTP Status: ${response.status} ${response.statusText})`\n    }\n    debugFn(detailedError)\n    return { ok: false, message: 'Download Failed', cause: detailedError }\n  }\n}\n\nasync function getLastCommitDetails({\n  defaultBranch,\n  githubToken,\n  orgGithub,\n  repoApiUrl,\n  repoSlug,\n}: {\n  orgGithub: string\n  repoSlug: string\n  defaultBranch: string\n  repoApiUrl: string\n  githubToken: string\n}): Promise<\n  CResult<{\n    lastCommitSha: string\n    lastCommitter: string | undefined\n    lastCommitMessage: string\n  }>\n> {\n  logger.info(\n    `Requesting last commit for default branch ${defaultBranch} for ${orgGithub}/${repoSlug}...`,\n  )\n\n  const commitApiUrl = `${repoApiUrl}/commits?sha=${defaultBranch}&per_page=1`\n  debugFn('url: commit', commitApiUrl)\n\n  const commitResponse = await fetch(commitApiUrl, {\n    headers: {\n      Authorization: `Bearer ${githubToken}`,\n    },\n  })\n\n  const commitText = await commitResponse.text()\n  debugFn('response: commit', commitText)\n\n  let lastCommit\n  try {\n    lastCommit = JSON.parse(commitText)?.[0]\n  } catch {\n    logger.fail(`GitHub response contained invalid JSON for last commit`)\n    logger.error(commitText)\n    return {\n      ok: false,\n      message: 'Invalid JSON response',\n      cause: `Server responded with invalid JSON for last commit of repo ${repoSlug}`,\n    }\n  }\n\n  const lastCommitSha = lastCommit.sha\n  const lastCommitter = Array.from(\n    new Set([lastCommit.commit.author.name, lastCommit.commit.committer.name]),\n  )[0]\n  const lastCommitMessage = lastCommit.message\n\n  if (!lastCommitSha) {\n    return {\n      ok: false,\n      message: 'Missing commit SHA',\n      cause: 'Unable to get last commit for repo',\n    }\n  }\n\n  if (!lastCommitter) {\n    return {\n      ok: false,\n      message: 'Missing committer',\n      cause: 'Last commit does not have information about who made the commit',\n    }\n  }\n\n  return { ok: true, data: { lastCommitSha, lastCommitter, lastCommitMessage } }\n}\n\nasync function selectFocus(repos: string[]): Promise<CResult<string[]>> {\n  const proceed = await select<string>({\n    message: 'Please select the repo to process:',\n    choices: repos\n      .map(slug => ({\n        name: slug,\n        value: slug,\n        description: `Create scan for the ${slug} repo through GitHub`,\n      }))\n      .concat({\n        name: '(Exit)',\n        value: '',\n        description: 'Cancel this action and exit',\n      }),\n  })\n  if (!proceed) {\n    return {\n      ok: false,\n      message: 'Canceled by user',\n      cause: 'User chose to cancel the action',\n    }\n  }\n  return { ok: true, data: [proceed] }\n}\n\nasync function makeSure(count: number): Promise<CResult<undefined>> {\n  if (\n    !(await confirm({\n      message: `Are you sure you want to run this for ${count} repos?`,\n      default: false,\n    }))\n  ) {\n    return {\n      ok: false,\n      message: 'User canceled',\n      cause: 'Action canceled by user',\n    }\n  }\n  return { ok: true, data: undefined }\n}\n\nasync function getRepoDetails({\n  githubApiUrl,\n  githubToken,\n  orgGithub,\n  repoSlug,\n}: {\n  orgGithub: string\n  repoSlug: string\n  githubApiUrl: string\n  githubToken: string\n}): Promise<\n  CResult<{ defaultBranch: string; repoDetails: unknown; repoApiUrl: string }>\n> {\n  const repoApiUrl = `${githubApiUrl}/repos/${orgGithub}/${repoSlug}`\n  debugFn('url: repo', repoApiUrl)\n\n  const repoDetailsResponse = await fetch(repoApiUrl, {\n    method: 'GET',\n    headers: {\n      Authorization: `Bearer ${githubToken}`,\n    },\n  })\n  logger.success(`Request completed.`)\n\n  const repoDetailsText = await repoDetailsResponse.text()\n  debugFn('response: repo', repoDetailsText)\n\n  let repoDetails\n  try {\n    repoDetails = JSON.parse(repoDetailsText)\n  } catch {\n    logger.fail(`GitHub response contained invalid JSON for repo ${repoSlug}`)\n    logger.error(repoDetailsText)\n    return {\n      ok: false,\n      message: 'Invalid JSON response',\n      cause: `Server responded with invalid JSON for repo ${repoSlug}`,\n    }\n  }\n\n  const defaultBranch = repoDetails.default_branch\n  if (!defaultBranch) {\n    return {\n      ok: false,\n      message: 'Default Branch Not Found',\n      cause: `Repo ${repoSlug} does not have a default branch set or it was not reported`,\n    }\n  }\n\n  return { ok: true, data: { defaultBranch, repoDetails, repoApiUrl } }\n}\n\nasync function getRepoBranchTree({\n  defaultBranch,\n  githubToken,\n  orgGithub,\n  repoApiUrl,\n  repoSlug,\n}: {\n  defaultBranch: string\n  githubToken: string\n  orgGithub: string\n  repoApiUrl: string\n  repoSlug: string\n}): Promise<CResult<string[]>> {\n  logger.info(\n    `Requesting default branch file tree; branch \\`${defaultBranch}\\`, repo \\`${orgGithub}/${repoSlug}\\`...`,\n  )\n\n  const treeApiUrl = `${repoApiUrl}/git/trees/${defaultBranch}?recursive=1`\n  debugFn('url: tree', treeApiUrl)\n\n  const treeResponse = await fetch(treeApiUrl, {\n    method: 'GET',\n    headers: {\n      Authorization: `Bearer ${githubToken}`,\n    },\n  })\n\n  const treeText = await treeResponse.text()\n  debugFn('response: tree', treeText)\n\n  let treeDetails\n  try {\n    treeDetails = JSON.parse(treeText)\n  } catch {\n    logger.fail(\n      `GitHub response contained invalid JSON for default branch of repo ${repoSlug}`,\n    )\n    logger.error(treeText)\n    return {\n      ok: false,\n      message: 'Invalid JSON response',\n      cause: `Server responded with invalid JSON for repo ${repoSlug}`,\n    }\n  }\n\n  if (treeDetails.message) {\n    if (treeDetails.message === 'Git Repository is empty.') {\n      logger.warn(\n        `GitHub reports the default branch of repo ${repoSlug} to be empty. Moving on to next repo.`,\n      )\n      return { ok: true, data: [] }\n    }\n\n    logger.fail('Negative response from GitHub:', treeDetails.message)\n    return {\n      ok: false,\n      message: 'Unexpected error response',\n      cause: `GitHub responded with an unexpected error while asking for details on the default branch: ${treeDetails.message}`,\n    }\n  }\n\n  if (!treeDetails.tree || !Array.isArray(treeDetails.tree)) {\n    debugFn('treeDetails.tree:', treeDetails.tree)\n\n    return {\n      ok: false,\n      message: `Tree response for default branch ${defaultBranch} for ${orgGithub}/${repoSlug} was not a list`,\n    }\n  }\n\n  const files = (treeDetails.tree as Array<{ type: string; path: string }>)\n    .filter(obj => obj.type === 'blob')\n    .map(obj => obj.path)\n\n  return { ok: true, data: files }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { createScanFromGithub } from './create-scan-from-github.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleCreateGithubScan({\n  all,\n  githubApiUrl,\n  githubToken,\n  interactive,\n  orgGithub,\n  orgSlug,\n  outputKind,\n  repos,\n}: {\n  all: boolean\n  githubApiUrl: string\n  githubToken: string\n  interactive: boolean\n  orgSlug: string\n  orgGithub: string\n  outputKind: OutputKind\n  repos: string\n}) {\n  const result = await createScanFromGithub({\n    all: Boolean(all),\n    githubApiUrl,\n    githubToken,\n    interactive: Boolean(interactive),\n    orgSlug,\n    orgGithub,\n    outputKind,\n    repos: String(repos || ''),\n  })\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.log('')\n  logger.success('Finished!')\n}\n","import path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleCreateGithubScan } from './handle-create-github-scan.mts'\nimport { suggestOrgSlug } from './suggest-org-slug.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\nimport { readOrDefaultSocketJson } from '../../utils/socketjson.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'github',\n  description: 'Create a scan for given GitHub repo',\n  hidden: true, // wip\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    all: {\n      type: 'boolean',\n      description:\n        'Apply for all known repos reported by the Socket API. Supersedes `repos`.',\n    },\n    githubToken: {\n      type: 'string',\n      description:\n        '(required) GitHub token for authentication (or set GITHUB_TOKEN as an environment variable)',\n    },\n    githubApiUrl: {\n      type: 'string',\n      description:\n        'Base URL of the GitHub API (default: https://api.github.com)',\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n    orgGithub: {\n      type: 'string',\n      description:\n        'Alternate GitHub Org if the name is different than the Socket Org',\n    },\n    repos: {\n      type: 'string',\n      description:\n        'List of repos to target in a comma-separated format (e.g., repo1,repo2). If not specified, the script will pull the list from Socket and ask you to pick one. Use --all to use them all.',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [options] [CWD=.]\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:create\n\n    This is similar to the \\`socket scan create\\` command except it pulls the files\n    from GitHub. See the help for that command for more details.\n\n    A GitHub Personal Access Token (PAT) will at least need read access to the repo\n    (\"contents\", read-only) for this command to work.\n\n    Note: This command cannot run the \\`socket manifest auto\\` things because that\n    requires local access to the repo while this command runs entirely through the\n    GitHub for file access.\n\n    You can use \\`socket scan setup\\` to configure certain repo flag defaults.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}\n      $ ${command} ./proj\n  `,\n}\n\nexport const cmdScanGithub = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const {\n    dryRun = false,\n    // Lazily access constants.ENV.SOCKET_CLI_GITHUB_TOKEN.\n    githubToken = constants.ENV.SOCKET_CLI_GITHUB_TOKEN,\n    interactive = true,\n    json,\n    markdown,\n    org: orgFlag,\n  } = cli.flags as {\n    dryRun: boolean\n    githubToken: string\n    interactive: boolean\n    json: boolean\n    markdown: boolean\n    org: string\n    orgGithub: string\n  }\n  let { all, githubApiUrl, orgGithub, repos } = cli.flags as {\n    all: boolean\n    githubApiUrl: string\n    orgGithub: string\n    repos: string\n  }\n  const outputKind = getOutputKind(json, markdown)\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  let [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    interactive,\n    dryRun,\n  )\n  if (!defaultOrgSlug) {\n    // Tmp. just for TS. will drop this later.\n    defaultOrgSlug = ''\n  }\n\n  const socketJson = await readOrDefaultSocketJson(cwd)\n\n  if (all === undefined) {\n    if (socketJson.defaults?.scan?.github?.all !== undefined) {\n      all = socketJson.defaults?.scan?.github?.all\n    } else {\n      all = false\n    }\n  }\n  if (!githubApiUrl) {\n    if (socketJson.defaults?.scan?.github?.githubApiUrl !== undefined) {\n      githubApiUrl = socketJson.defaults.scan.github.githubApiUrl\n    } else {\n      githubApiUrl = 'https://api.github.com'\n    }\n  }\n  if (!orgGithub) {\n    if (socketJson.defaults?.scan?.github?.orgGithub !== undefined) {\n      orgGithub = socketJson.defaults.scan.github.orgGithub\n    } else {\n      // Default to Socket org slug. Often that's fine. Vanity and all that.\n      orgGithub = orgSlug\n    }\n  }\n  if (!all && !repos) {\n    if (socketJson.defaults?.scan?.github?.repos !== undefined) {\n      repos = socketJson.defaults.scan.github.repos\n    } else {\n      repos = ''\n    }\n  }\n\n  // We're going to need an api token to suggest data because those suggestions\n  // must come from data we already know. Don't error on missing api token yet.\n  // If the api-token is not set, ignore it for the sake of suggestions.\n  const hasSocketApiToken = hasDefaultToken()\n  // We will also be needing that GitHub token.\n  const hasGithubApiToken = !!githubToken\n\n  // If the current cwd is unknown and is used as a repo slug anyways, we will\n  // first need to register the slug before we can use it.\n  // Only do suggestions with an apiToken and when not in dryRun mode\n  if (hasSocketApiToken && !dryRun && interactive) {\n    if (!orgSlug) {\n      const suggestion = await suggestOrgSlug()\n      if (suggestion) {\n        orgSlug = suggestion\n      }\n    }\n  }\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !isTestingV1() && !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one',\n    },\n    {\n      nook: true,\n      test: hasSocketApiToken,\n      message: 'This command requires an API token for access',\n      pass: 'ok',\n      fail: 'missing (try `socket login`)',\n    },\n    {\n      test: hasGithubApiToken,\n      message: 'This command requires a GitHub API token for access',\n      pass: 'ok',\n      fail: 'missing',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  // Note exiting earlier to skirt a hidden auth requirement\n  if (dryRun) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleCreateGithubScan({\n    all: Boolean(all),\n    githubApiUrl,\n    githubToken,\n    interactive: Boolean(interactive),\n    orgSlug,\n    orgGithub,\n    outputKind,\n    repos,\n  })\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchListScans({\n  branch,\n  direction,\n  from_time,\n  orgSlug,\n  page,\n  per_page,\n  repo,\n  sort,\n}: {\n  branch: string\n  direction: string\n  from_time: string\n  orgSlug: string\n  page: number\n  per_page: number\n  repo: string\n  sort: string\n}): Promise<CResult<SocketSdkReturnType<'getOrgFullScanList'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgFullScanList(orgSlug, {\n      ...(branch ? { branch } : {}),\n      ...(repo ? { repo } : {}),\n      sort,\n      direction,\n      per_page: String(per_page),\n      page: String(page),\n      from: from_time,\n    }),\n    'list of scans',\n  )\n}\n","// @ts-ignore\nimport chalkTable from 'chalk-table'\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputListScans(\n  result: CResult<SocketSdkReturnType<'getOrgFullScanList'>['data']>,\n  outputKind: OutputKind,\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const options = {\n    columns: [\n      { field: 'id', name: colors.magenta('ID') },\n      { field: 'report_url', name: colors.magenta('Scan URL') },\n      { field: 'repo', name: colors.magenta('Repo') },\n      { field: 'branch', name: colors.magenta('Branch') },\n      { field: 'created_at', name: colors.magenta('Created at') },\n    ],\n  }\n\n  const formattedResults = result.data.results.map(d => {\n    return {\n      id: d.id,\n      report_url: colors.underline(`${d.html_report_url}`),\n      created_at: d.created_at\n        ? new Date(d.created_at).toLocaleDateString('en-us', {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n          })\n        : '',\n      repo: d.repo,\n      branch: d.branch,\n    }\n  })\n\n  logger.log(chalkTable(options, formattedResults))\n}\n","import { fetchListScans } from './fetch-list-scans.mts'\nimport { outputListScans } from './output-list-scans.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleListScans({\n  branch,\n  direction,\n  from_time,\n  orgSlug,\n  outputKind,\n  page,\n  per_page,\n  repo,\n  sort,\n}: {\n  branch: string\n  direction: string\n  from_time: string\n  orgSlug: string\n  outputKind: OutputKind\n  page: number\n  per_page: number\n  repo: string\n  sort: string\n}): Promise<void> {\n  const data = await fetchListScans({\n    branch,\n    direction,\n    from_time,\n    orgSlug,\n    page,\n    per_page,\n    repo,\n    sort,\n  })\n\n  await outputListScans(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleListScans } from './handle-list-scans.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type {\n  CliCommandConfig,\n  CliSubcommand,\n} from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'list',\n  description: 'List the scans for an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    branch: {\n      type: 'string',\n      description: 'Filter to show only scans with this branch name',\n    },\n    direction: {\n      type: 'string',\n      shortFlag: 'd',\n      default: 'desc',\n      description: 'Direction option (`desc` or `asc`) - Default is `desc`',\n    },\n    fromTime: {\n      type: 'string',\n      shortFlag: 'f',\n      default: '',\n      description: 'From time - as a unix timestamp',\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    page: {\n      type: 'number',\n      shortFlag: 'p',\n      default: 1,\n      description: 'Page number - Default is 1',\n    },\n    perPage: {\n      type: 'number',\n      shortFlag: 'pp',\n      default: 30,\n      description: 'Results per page - Default is 30',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n    repo: {\n      type: 'string',\n      description: 'Filter to show only scans with this repository name',\n    },\n    sort: {\n      type: 'string',\n      shortFlag: 's',\n      default: 'created_at',\n      description:\n        'Sorting option (`name` or `created_at`) - default is `created_at`',\n    },\n    untilTime: {\n      type: 'string',\n      shortFlag: 'u',\n      default: '',\n      description: 'Until time - as a unix timestamp',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'}\n  `,\n}\n\nexport const cmdScanList: CliSubcommand = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n) {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const {\n    branch,\n    dryRun,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n    repo,\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleListScans({\n    branch: branch ? String(branch) : '',\n    direction: String(cli.flags['direction'] || ''),\n    from_time: String(cli.flags['fromTime'] || ''),\n    orgSlug,\n    outputKind,\n    page: Number(cli.flags['page'] || 1),\n    per_page: Number(cli.flags['perPage'] || 30),\n    repo: repo ? String(repo) : '',\n    sort: String(cli.flags['sort'] || ''),\n  })\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchScanMetadata(\n  orgSlug: string,\n  scanId: string,\n): Promise<CResult<SocketSdkReturnType<'getOrgFullScanMetadata'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgFullScanMetadata(orgSlug, scanId),\n    'meta data for a full scan',\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputScanMetadata(\n  result: CResult<SocketSdkReturnType<'getOrgFullScanMetadata'>['data']>,\n  scanId: string,\n  outputKind: OutputKind,\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log('# Scan meta data\\n')\n  }\n  logger.log(`Scan ID: ${scanId}\\n`)\n  for (const [key, value] of Object.entries(result.data)) {\n    if (\n      [\n        'id',\n        'updated_at',\n        'organization_id',\n        'repository_id',\n        'commit_hash',\n        'html_report_url',\n      ].includes(key)\n    ) {\n      continue\n    }\n    logger.log(`- ${key}:`, value)\n  }\n  if (outputKind === 'markdown') {\n    logger.log(\n      `\\nYou can view this report at: [${result.data.html_report_url}](${result.data.html_report_url})\\n`,\n    )\n  } else {\n    logger.log(\n      `\\nYou can view this report at: ${result.data.html_report_url}]\\n`,\n    )\n  }\n}\n","import { fetchScanMetadata } from './fetch-scan-metadata.mts'\nimport { outputScanMetadata } from './output-scan-metadata.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleOrgScanMetadata(\n  orgSlug: string,\n  scanId: string,\n  outputKind: OutputKind,\n): Promise<void> {\n  const data = await fetchScanMetadata(orgSlug, scanId)\n\n  await outputScanMetadata(data, scanId, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleOrgScanMetadata } from './handle-scan-metadata.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type {\n  CliCommandConfig,\n  CliSubcommand,\n} from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'metadata',\n  description: \"Get a scan's metadata\",\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'} <scan ID>\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0\n  `,\n}\n\nexport const cmdScanMetadata: CliSubcommand = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const scanId =\n    (isTestingV1() || defaultOrgSlug ? cli.input[0] : cli.input[1]) || ''\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing',\n    },\n    {\n      test: !!scanId,\n      message: 'Scan ID to inspect as argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleOrgScanMetadata(orgSlug, scanId, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\n\nexport async function outputScanReach(\n  result: CResult<unknown>,\n  cwd: string,\n  outputKind: OutputKind,\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.success('finished on', cwd)\n}\n","import { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\n\nimport type { CResult } from '../../types.mts'\n\nconst { DOT_SOCKET_DOT_FACTS_JSON } = constants\n\nexport async function scanReachability(cwd: string): Promise<CResult<unknown>> {\n  try {\n    const result = await spawn(\n      constants.execPath,\n      [\n        // Lazily access constants.nodeNoWarningsFlags.\n        ...constants.nodeNoWarningsFlags,\n        // Lazily access constants.coanaBinPath.\n        constants.coanaBinPath,\n        'run',\n        cwd,\n        '--output-dir',\n        cwd,\n        '--disable-report-submission',\n        '--socket-mode',\n        DOT_SOCKET_DOT_FACTS_JSON,\n      ],\n      {\n        cwd,\n        env: {\n          ...process.env,\n          // Lazily access constants.ENV.SOCKET_CLI_API_TOKEN\n          SOCKET_CLI_API_TOKEN: constants.ENV.SOCKET_CLI_API_TOKEN,\n        },\n      },\n    )\n    return { ok: true, data: result.stdout.trim() }\n  } catch (e) {\n    const message = (e as any)?.stdout ?? (e as Error)?.message\n    return { ok: false, data: e, message }\n  }\n}\n","import { outputScanReach } from './output-scan-reach.mts'\nimport { scanReachability } from './scan-reachability.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleScanReach(cwd: string, outputKind: OutputKind) {\n  const result = await scanReachability(cwd)\n\n  await outputScanReach(result, cwd, outputKind)\n}\n","import path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleScanReach } from './handle-reach-scan.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'reach',\n  description: 'Compute tier 1 reachability',\n  hidden: true,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [CWD=.]\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}\n      $ ${command} ./proj\n  `,\n}\n\nexport const cmdScanReach = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { dryRun, json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  const wasValidInput = checkCommandInput(outputKind)\n  if (!wasValidInput) {\n    return\n  }\n\n  if (dryRun) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleScanReach(cwd, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleScanReport } from './handle-scan-report.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type {\n  CliCommandConfig,\n  CliSubcommand,\n} from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'report',\n  description:\n    'Check whether a scan result passes the organizational policies (security, license)',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    fold: {\n      type: 'string',\n      default: 'none',\n      description: 'Fold reported alerts to some degree',\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n    reportLevel: {\n      type: 'string',\n      default: 'warn',\n      description: 'Which policy level alerts should be reported',\n    },\n    short: {\n      type: 'boolean',\n      default: false,\n      description: 'Report only the healthy status',\n    },\n    license: {\n      type: 'boolean',\n      default: false,\n      description: 'Also report the license policy status. Default: false',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'} <scan ID> [path to output file]\n\n    API Token Requirements\n      - Quota: 2 units\n      - Permissions: full-scans:list security-policy:read\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    By default the result is a nested object that looks like this:\n      \\`{[ecosystem]: {[pkgName]: {[version]: {[file]: {[type:loc]: policy}}}}\\`\n    You can fold this up to given level: 'pkg', 'version', 'file', and 'none'.\n\n    By default only the warn and error policy level alerts are reported. You can\n    override this and request more ('defer' < 'ignore' < 'monitor' < 'warn' < 'error')\n\n    Short responses: JSON: \\`{healthy:bool}\\`, markdown: \\`healthy = bool\\`, text: \\`OK/ERR\\`\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0 --json --fold=version\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0 --license --markdown --short\n  `,\n}\n\nexport const cmdScanReport: CliSubcommand = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const {\n    fold = 'none',\n    json,\n    license,\n    markdown,\n    reportLevel = 'warn',\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const { dryRun, interactive, org: orgFlag } = cli.flags\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const scanId =\n    (isTestingV1() || defaultOrgSlug ? cli.input[0] : cli.input[1]) || ''\n  const file =\n    (isTestingV1() || defaultOrgSlug ? cli.input[1] : cli.input[2]) || '-'\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing',\n    },\n    {\n      test: !!scanId,\n      message: 'Scan ID to report on',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleScanReport({\n    orgSlug,\n    scanId: scanId,\n    includeLicensePolicy: !!license,\n    outputKind,\n    filePath: file,\n    fold: fold as 'none' | 'file' | 'pkg' | 'version',\n    short: !!cli.flags['short'],\n    reportLevel: reportLevel as\n      | 'warn'\n      | 'error'\n      | 'defer'\n      | 'ignore'\n      | 'monitor',\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\n\nimport type { CResult } from '../../types.mts'\n\nexport async function outputScanConfigResult(result: CResult<unknown>) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.log('')\n  logger.log('Finished')\n  logger.log('')\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { input, select } from '@socketsecurity/registry/lib/prompts'\n\nimport {\n  type SocketJson,\n  readSocketJson,\n  writeSocketJson,\n} from '../../utils/socketjson.mts'\n\nimport type { CResult } from '../../types.mts'\n\nexport async function setupScanConfig(\n  cwd: string,\n  defaultOnReadError = false,\n): Promise<CResult<unknown>> {\n  const jsonPath = path.join(cwd, `socket.json`)\n  if (fs.existsSync(jsonPath)) {\n    logger.info(`Found socket.json at ${jsonPath}`)\n  } else {\n    logger.info(`No socket.json found at ${cwd}, will generate a new one`)\n  }\n\n  logger.log('')\n  logger.log(\n    'Note: This tool will set up flag and argument defaults for certain',\n  )\n  logger.log('      CLI commands. You can still override them by explicitly')\n  logger.log('      setting the flag. It is meant to be a convenience tool.')\n  logger.log('')\n  logger.log(\n    'This command will generate a `socket.json` file in the target cwd.',\n  )\n  logger.log('You can choose to add this file to your repo (handy for collab)')\n  logger.log('or to add it to the ignored files, or neither. This file is only')\n  logger.log('used in CLI workflows.')\n  logger.log('')\n  logger.log('Note: For details on a flag you can run `socket <cmd> --help`')\n  logger.log('')\n\n  const socketJsonResult = await readSocketJson(cwd, defaultOnReadError)\n  if (!socketJsonResult.ok) {\n    return socketJsonResult\n  }\n\n  const socketJson = socketJsonResult.data\n  if (!socketJson.defaults) {\n    socketJson.defaults = {}\n  }\n  if (!socketJson.defaults.scan) {\n    socketJson.defaults.scan = {}\n  }\n\n  const targetCommand = await select({\n    message: 'Which scan command do you want to configure?',\n    choices: [\n      {\n        name: 'socket scan create',\n        value: 'create',\n      },\n      {\n        name: 'socket scan github',\n        value: 'github',\n      },\n      {\n        name: '(cancel)',\n        value: '',\n        description: 'Exit configurator, make no changes',\n      },\n    ],\n  })\n  switch (targetCommand) {\n    case 'create': {\n      if (!socketJson.defaults.scan.create) {\n        socketJson.defaults.scan.create = {}\n      }\n      const result = await configureScan(socketJson.defaults.scan.create)\n      if (!result.ok || result.data.canceled) {\n        return result\n      }\n      break\n    }\n    case 'github': {\n      if (!socketJson.defaults.scan.github) {\n        socketJson.defaults.scan.github = {}\n      }\n      const result = await configureGithub(socketJson.defaults.scan.github)\n      if (!result.ok || result.data.canceled) {\n        return result\n      }\n      break\n    }\n    default: {\n      return canceledByUser()\n    }\n  }\n\n  logger.log('')\n  logger.log('Setup complete. Writing socket.json')\n  logger.log('')\n\n  if (\n    await select({\n      message: `Do you want to write the new config to ${jsonPath} ?`,\n      choices: [\n        {\n          name: 'yes',\n          value: true,\n          description: 'Update config',\n        },\n        {\n          name: 'no',\n          value: false,\n          description: 'Do not update the config',\n        },\n      ],\n    })\n  ) {\n    return await writeSocketJson(cwd, socketJson)\n  }\n\n  return canceledByUser()\n}\n\nasync function configureScan(\n  config: NonNullable<\n    NonNullable<NonNullable<SocketJson['defaults']>['scan']>['create']\n  >,\n): Promise<CResult<{ canceled: boolean }>> {\n  const defaultRepoName = await input({\n    message:\n      '(--repo) What repo name (slug) should be reported to Socket for this dir?',\n    default: config.repo || 'socket-default-repository',\n    required: false,\n    // validate: async string => bool\n  })\n  if (defaultRepoName === undefined) {\n    return canceledByUser()\n  }\n  if (defaultRepoName.trim()) {\n    // Even if it's 'socket-default-repository' store it because if we change\n    // this default then an existing user probably would not expect the change?\n    config.repo = defaultRepoName.trim()\n  } else {\n    delete config.repo\n  }\n\n  const defaultBranchName = await input({\n    message:\n      '(--branch) What branch name (slug) should be reported to Socket for this dir?',\n    default: config.branch || 'socket-default-branch',\n    required: false,\n    // validate: async string => bool\n  })\n  if (defaultBranchName === undefined) {\n    return canceledByUser()\n  }\n  if (defaultBranchName.trim()) {\n    // Even if it's 'socket-default-branch' store it because if we change\n    // this default then an existing user probably would not expect the change?\n    config.branch = defaultBranchName.trim()\n  } else {\n    delete config.branch\n  }\n\n  const autoManifest = await select({\n    message:\n      '(--autoManifest) Do you want to run `socket manifest auto` before creating a scan? You would need this for sbt, gradle, etc.',\n    choices: [\n      {\n        name: 'no',\n        value: 'no',\n        description: 'Do not generate local manifest files',\n      },\n      {\n        name: 'yes',\n        value: 'yes',\n        description:\n          'Locally generate manifest files for languages like gradle, sbt, and conda (see `socket manifest auto`), before creating a scan',\n      },\n      {\n        name: '(leave default)',\n        value: '',\n        description: 'Do not store a setting for this',\n      },\n    ],\n    default:\n      config.autoManifest === true\n        ? 'yes'\n        : config.autoManifest === false\n          ? 'no'\n          : '',\n  })\n  if (autoManifest === undefined) {\n    return canceledByUser()\n  }\n  if (autoManifest === 'yes') {\n    config.autoManifest = true\n  } else if (autoManifest === 'no') {\n    config.autoManifest = false\n  } else {\n    delete config.autoManifest\n  }\n\n  const alwaysReport = await select({\n    message: '(--report) Do you want to enable --report by default?',\n    choices: [\n      {\n        name: 'no',\n        value: 'no',\n        description: 'Do not wait for Scan result and report by default',\n      },\n      {\n        name: 'yes',\n        value: 'yes',\n        description:\n          'After submitting a Scan request, wait for scan to complete, then show a report (like --report would)',\n      },\n      {\n        name: '(leave default)',\n        value: '',\n        description: 'Do not store a setting for this',\n      },\n    ],\n    default:\n      config.report === true ? 'yes' : config.report === false ? 'no' : '',\n  })\n  if (alwaysReport === undefined) {\n    return canceledByUser()\n  }\n  if (alwaysReport === 'yes') {\n    config.report = true\n  } else if (alwaysReport === 'no') {\n    config.report = false\n  } else {\n    delete config.report\n  }\n\n  return notCanceled()\n}\n\nasync function configureGithub(\n  config: NonNullable<\n    NonNullable<NonNullable<SocketJson['defaults']>['scan']>['github']\n  >,\n): Promise<CResult<{ canceled: boolean }>> {\n  // Do not store the github API token. Just leads to a security rabbit hole.\n\n  const all = await select({\n    message:\n      '(--all) Do you by default want to fetch all repos from the GitHub API and scan all known repos?',\n    choices: [\n      {\n        name: 'no',\n        value: 'no',\n        description: 'Fetch repos if not given and ask which repo to run on',\n      },\n      {\n        name: 'yes',\n        value: 'yes',\n        description: 'Run on all remote repos by default',\n      },\n      {\n        name: '(leave default)',\n        value: '',\n        description: 'Do not store a setting for this',\n      },\n    ],\n    default: config.all === true ? 'yes' : config.all === false ? 'no' : '',\n  })\n  if (all === undefined) {\n    return canceledByUser()\n  }\n  if (all === 'yes') {\n    config.all = true\n  } else if (all === 'no') {\n    config.all = false\n  } else {\n    delete config.all\n  }\n\n  if (!all) {\n    const defaultRepos = await input({\n      message:\n        '(--repos) Please enter the default repos to run this on, leave empty (backspace) to fetch from GitHub and ask interactive',\n      default: config.repos,\n      required: false,\n      // validate: async string => bool\n    })\n    if (defaultRepos === undefined) {\n      return canceledByUser()\n    }\n    if (defaultRepos.trim()) {\n      config.repos = defaultRepos.trim()\n    } else {\n      delete config.repos\n    }\n  }\n\n  const defaultGithubApiUrl = await input({\n    message: '(--githubApiUrl) Do you want to override the default github url?',\n    default: config.githubApiUrl || 'https://api.github.com',\n    required: false,\n    // validate: async string => bool\n  })\n  if (defaultGithubApiUrl === undefined) {\n    return canceledByUser()\n  }\n  if (\n    defaultGithubApiUrl.trim() &&\n    defaultGithubApiUrl.trim() !== 'https://api.github.com'\n  ) {\n    config.githubApiUrl = defaultGithubApiUrl.trim()\n  } else {\n    delete config.githubApiUrl\n  }\n\n  const defaultOrgGithub = await input({\n    message:\n      '(--orgGithub) Do you want to change the org slug that is used when talking to the GitHub API? Defaults to your Socket org slug.',\n    default: config.orgGithub || '',\n    required: false,\n    // validate: async string => bool\n  })\n  if (defaultOrgGithub === undefined) {\n    return canceledByUser()\n  }\n  if (defaultOrgGithub.trim()) {\n    config.orgGithub = defaultOrgGithub.trim()\n  } else {\n    delete config.orgGithub\n  }\n\n  return notCanceled()\n}\n\nfunction canceledByUser(): CResult<{ canceled: boolean }> {\n  logger.log('')\n  logger.info('User canceled')\n  logger.log('')\n  return { ok: true, data: { canceled: true } }\n}\n\nfunction notCanceled(): CResult<{ canceled: boolean }> {\n  return { ok: true, data: { canceled: false } }\n}\n","import { outputScanConfigResult } from './output-scan-config-result.mts'\nimport { setupScanConfig } from './setup-scan-config.mts'\n\nexport async function handleScanConfig(\n  cwd: string,\n  defaultOnReadError = false,\n) {\n  const result = await setupScanConfig(cwd, defaultOnReadError)\n\n  await outputScanConfigResult(result)\n}\n","import path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleScanConfig } from './handle-scan-config.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'setup',\n  description:\n    'Start interactive configurator to customize default flag values for `socket scan` in this dir',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    defaultOnReadError: {\n      type: 'boolean',\n      description:\n        'If reading the socket.json fails, just use a default config? Warning: This might override the existing json file!',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [options] [CWD=.]\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Interactive configurator to create a local json file in the target directory\n    that helps to set flag defaults for \\`socket scan create\\`.\n\n    This helps to configure the (Socket reported) repo and branch names, as well\n    as which branch name is the \"default branch\" (main, master, etc). This way\n    you don't have to specify these flags when creating a scan in this dir.\n\n    This generated configuration file will only be used locally by the CLI. You\n    can commit it to the repo (useful for collaboration) or choose to add it to\n    your .gitignore all the same. Only this CLI will use it.\n\n    Examples\n\n      $ ${command}\n      $ ${command} ./proj\n  `,\n}\n\nexport const cmdScanSetup = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n  const { defaultOnReadError = false } = cli.flags\n  let [cwd = '.'] = cli.input\n  // Note: path.resolve vs .join:\n  // If given path is absolute then cwd should not affect it.\n  cwd = path.resolve(process.cwd(), cwd)\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleScanConfig(cwd, Boolean(defaultOnReadError))\n}\n","import { debugFn } from '@socketsecurity/registry/lib/debug'\n\nimport { queryApiSafeText } from '../../utils/api.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketArtifact } from '../../utils/alert/artifact.mts'\n\nexport async function fetchScan(\n  orgSlug: string,\n  scanId: string,\n): Promise<CResult<SocketArtifact[]>> {\n  const result = await queryApiSafeText(\n    `orgs/${orgSlug}/full-scans/${encodeURIComponent(scanId)}`,\n    'a scan',\n  )\n\n  if (!result.ok) {\n    return result\n  }\n\n  const jsonsString = result.data\n\n  // This is nd-json; each line is a json object\n  const lines = jsonsString.split('\\n').filter(Boolean)\n  let ok = true\n  const data = lines.map(line => {\n    try {\n      return JSON.parse(line)\n    } catch {\n      ok = false\n      debugFn('fail: parse NDJSON\\n', line)\n      return null\n    }\n  }) as unknown as SocketArtifact[]\n\n  if (ok) {\n    return { ok: true, data }\n  }\n\n  return {\n    ok: false,\n    message: 'Invalid API response',\n    cause:\n      'The API responded with at least one line that was not valid JSON. Please report if this persists.',\n  }\n}\n","import fs from 'node:fs/promises'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTable } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketArtifact } from '../../utils/alert/artifact.mts'\n\nconst { SOCKET_WEBSITE_URL } = constants\n\nexport async function outputScanView(\n  result: CResult<SocketArtifact[]>,\n  orgSlug: string,\n  scanId: string,\n  filePath: string,\n  outputKind: OutputKind,\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (\n    outputKind === 'json' ||\n    (outputKind === 'text' && filePath && filePath.endsWith('.json'))\n  ) {\n    const json = serializeResultJson(result)\n\n    if (filePath && filePath !== '-') {\n      logger.info('Writing json results to', filePath)\n      try {\n        await fs.writeFile(filePath, json, 'utf8')\n        logger.info(`Data successfully written to ${filePath}`)\n      } catch (e) {\n        process.exitCode = 1\n        logger.fail('There was an error trying to write the markdown to disk')\n        logger.error(e)\n        logger.log(\n          serializeResultJson({\n            ok: false,\n            message: 'File Write Failure',\n            cause: 'Failed to write json to disk',\n          }),\n        )\n      }\n      return\n    }\n\n    logger.log(json)\n    return\n  }\n\n  const display = result.data.map(art => {\n    const author = Array.isArray(art.author)\n      ? `${art.author[0]}${art.author.length > 1 ? ' et.al.' : ''}`\n      : art.author\n    return {\n      type: art.type,\n      name: art.name,\n      version: art.version,\n      author,\n      score: JSON.stringify(art.score),\n    }\n  })\n\n  const md = mdTable<any>(display, [\n    'type',\n    'version',\n    'name',\n    'author',\n    'score',\n  ])\n\n  const report =\n    `\n# Scan Details\n\nThese are the artifacts and their scores found.\n\nScan ID: ${scanId}\n\n${md}\n\nView this report at: ${SOCKET_WEBSITE_URL}/dashboard/org/${orgSlug}/sbom/${scanId}\n  `.trim() + '\\n'\n\n  if (filePath && filePath !== '-') {\n    try {\n      await fs.writeFile(filePath, report, 'utf8')\n      logger.log(`Data successfully written to ${filePath}`)\n    } catch (e) {\n      process.exitCode = 1\n      logger.fail('There was an error trying to write the markdown to disk')\n      logger.error(e)\n    }\n  } else {\n    logger.log(report)\n  }\n}\n","import { fetchScan } from './fetch-scan.mts'\nimport { outputScanView } from './output-scan-view.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleScanView(\n  orgSlug: string,\n  scanId: string,\n  filePath: string,\n  outputKind: OutputKind,\n): Promise<void> {\n  const data = await fetchScan(orgSlug, scanId)\n\n  await outputScanView(data, orgSlug, scanId, filePath, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nexport async function streamScan(\n  orgSlug: string,\n  scanId: string,\n  file: string | undefined,\n) {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  logger.info('Requesting data from API...')\n\n  // Note: this will write to stdout or target file. It's not a noop\n  return await handleApiCall(\n    sockSdk.getOrgFullScan(orgSlug, scanId, file === '-' ? undefined : file),\n    'a scan',\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleScanView } from './handle-scan-view.mts'\nimport { streamScan } from './stream-scan.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type {\n  CliCommandConfig,\n  CliSubcommand,\n} from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'view',\n  description: 'View the raw results of a scan',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    stream: {\n      type: 'boolean',\n      default: false,\n      description:\n        'Only valid with --json. Streams the response as \"ndjson\" (chunks of valid json blobs).',\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'} <scan ID> [path to output file]\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:list\n\n    When no output path is given the contents is sent to stdout.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0 ./stream.txt\n  `,\n}\n\nexport const cmdScanView: CliSubcommand = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const {\n    dryRun,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n    stream,\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const scanId =\n    (isTestingV1() || defaultOrgSlug ? cli.input[0] : cli.input[1]) || ''\n  const file =\n    (isTestingV1() || defaultOrgSlug ? cli.input[1] : cli.input[2]) || '-'\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing',\n    },\n    {\n      test: !!scanId,\n      message: 'Scan ID to view',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n    {\n      nook: true,\n      test: !stream || !!json,\n      message: 'You can only use --stream when using --json',\n      pass: 'ok',\n      fail: 'Either remove --stream or add --json',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  if (json && stream) {\n    await streamScan(orgSlug, scanId, file)\n  } else {\n    await handleScanView(orgSlug, scanId, file, outputKind)\n  }\n}\n","import { cmdScanCreate } from './cmd-scan-create.mts'\nimport { cmdScanDel } from './cmd-scan-del.mts'\nimport { cmdScanDiff } from './cmd-scan-diff.mts'\nimport { cmdScanGithub } from './cmd-scan-github.mts'\nimport { cmdScanList } from './cmd-scan-list.mts'\nimport { cmdScanMetadata } from './cmd-scan-metadata.mts'\nimport { cmdScanReach } from './cmd-scan-reach.mts'\nimport { cmdScanReport } from './cmd-scan-report.mts'\nimport { cmdScanSetup } from './cmd-scan-setup.mts'\nimport { cmdScanView } from './cmd-scan-view.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Scan related commands'\n\nexport const cmdScan: CliSubcommand = {\n  description,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        create: cmdScanCreate,\n        del: cmdScanDel,\n        diff: cmdScanDiff,\n        github: cmdScanGithub,\n        list: cmdScanList,\n        metadata: cmdScanMetadata,\n        reach: cmdScanReach,\n        report: cmdScanReport,\n        setup: cmdScanSetup,\n        view: cmdScanView,\n      },\n      {\n        aliases: {\n          meta: {\n            description: cmdScanMetadata.description,\n            hidden: true,\n            argv: ['metadata'],\n          },\n          reachability: {\n            description: cmdScanReach.description,\n            hidden: true,\n            argv: ['reach'],\n          },\n          // Backwards compat. TODO: Drop next major bump; isTestingV1\n          stream: {\n            description: cmdScanView.description,\n            hidden: true,\n            argv: ['view'], // Original args will be appended (!)\n          },\n        },\n        argv,\n        description,\n        importMeta,\n        name: parentName + ' scan',\n      },\n    )\n  },\n}\n","import { queryApiSafeJson } from '../../utils/api.mts'\n\nimport type { ThreadFeedResponse } from './types.mts'\nimport type { CResult } from '../../types.mts'\n\nexport async function fetchThreatFeed({\n  direction,\n  ecosystem,\n  filter,\n  page,\n  perPage,\n}: {\n  direction: string\n  ecosystem: string\n  filter: string\n  page: string\n  perPage: number\n}): Promise<CResult<ThreadFeedResponse>> {\n  const queryParams = new URLSearchParams([\n    ['direction', direction],\n    ['ecosystem', ecosystem],\n    ['filter', filter],\n    ['page', page],\n    ['per_page', String(perPage)],\n  ])\n\n  return await queryApiSafeJson(\n    `threat-feed?${queryParams}`,\n    'the Threat Feed data',\n  )\n}\n","import { createRequire } from 'node:module'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { ThreadFeedResponse, ThreatResult } from './types.mts'\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { Widgets } from 'blessed'\n\nconst require = createRequire(import.meta.url)\n\nexport async function outputThreatFeed(\n  result: CResult<ThreadFeedResponse>,\n  outputKind: OutputKind,\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (!result.data?.results?.length) {\n    logger.warn('Did not receive any data to display...')\n    return\n  }\n\n  const formattedOutput = formatResults(result.data.results)\n  const descriptions = result.data.results.map(d => d.description)\n\n  // Note: this temporarily takes over the terminal (just like `man` does).\n  const ScreenWidget = require('blessed/lib/widgets/screen.js')\n  // Lazily access constants.blessedOptions.\n  const screen: Widgets.Screen = new ScreenWidget({\n    ...constants.blessedOptions,\n  })\n  // Register these keys first so you can always exit, even when it gets stuck\n  // If we don't do this and the code crashes, the user must hard-kill the\n  // node process just to exit it. That's very bad UX.\n  // eslint-disable-next-line n/no-process-exit\n  screen.key(['escape', 'q', 'C-c'], () => process.exit(0))\n\n  const TableWidget = require('blessed-contrib/lib/widget/table.js')\n  const table: any = new TableWidget({\n    keys: 'true',\n    fg: 'white',\n    selectedFg: 'white',\n    selectedBg: 'magenta',\n    interactive: 'true',\n    label: 'Threat feed',\n    width: '100%',\n    height: '70%', // Changed from 100% to 70%\n    border: {\n      type: 'line',\n      fg: 'cyan',\n    },\n    columnWidth: [10, 30, 20, 18, 15, 200],\n    // TODO: the truncation doesn't seem to work too well yet but when we add\n    //       `pad` alignment fails, when we extend columnSpacing alignment fails\n    columnSpacing: 1,\n    truncate: '_',\n  })\n\n  // Create details box at the bottom\n  const BoxWidget = require('blessed/lib/widgets/box.js')\n  const detailsBox: Widgets.BoxElement = new BoxWidget({\n    bottom: 0,\n    height: '30%',\n    width: '100%',\n    border: {\n      type: 'line',\n      fg: 'cyan',\n    },\n    label: 'Details',\n    content:\n      'Use arrow keys to navigate. Press Enter to select a threat. Press q to exit.',\n    style: {\n      fg: 'white',\n    },\n  })\n\n  table.setData({\n    headers: [\n      ' Ecosystem',\n      ' Name',\n      '  Version',\n      '  Threat type',\n      '  Detected at',\n      ' Details',\n    ],\n    data: formattedOutput,\n  })\n\n  // allow control the table with the keyboard\n  table.focus()\n\n  screen.append(table)\n  screen.append(detailsBox)\n\n  // Update details box when selection changes\n  table.rows.on('select item', () => {\n    const selectedIndex = table.rows.selected\n    if (selectedIndex !== undefined && selectedIndex >= 0) {\n      const selectedRow = formattedOutput[selectedIndex]\n      if (selectedRow) {\n        // Note: the spacing works around issues with the table; it refuses to pad!\n        detailsBox.setContent(\n          `Ecosystem: ${selectedRow[0]}\\n` +\n            `Name: ${selectedRow[1]}\\n` +\n            `Version:${selectedRow[2]}\\n` +\n            `Threat type:${selectedRow[3]}\\n` +\n            `Detected at:${selectedRow[4]}\\n` +\n            `Details: ${selectedRow[5]}\\n` +\n            `Description: ${descriptions[selectedIndex]}`,\n        )\n        screen.render()\n      }\n    }\n  })\n\n  screen.render()\n\n  screen.key(['return'], () => {\n    const selectedIndex = table.rows.selected\n    screen.destroy()\n    const selectedRow = formattedOutput[selectedIndex]\n    logger.log('Last selection:\\n', selectedRow)\n  })\n}\n\nfunction formatResults(data: ThreatResult[]) {\n  return data.map(d => {\n    const ecosystem = d.purl.split('pkg:')[1]!.split('/')[0]!\n    const name = d.purl.split('/')[1]!.split('@')[0]!\n    const version = d.purl.split('@')[1]!\n\n    const timeDiff = msAtHome(d.createdAt)\n\n    // Note: the spacing works around issues with the table; it refuses to pad!\n    return [\n      ecosystem,\n      decodeURIComponent(name),\n      ` ${version}`,\n      ` ${d.threatType}`,\n      ` ${timeDiff}`,\n      d.locationHtmlUrl,\n    ]\n  })\n}\n\nfunction msAtHome(isoTimeStamp: string): string {\n  const timeStart = Date.parse(isoTimeStamp)\n  const timeEnd = Date.now()\n\n  const rtf = new Intl.RelativeTimeFormat('en', {\n    numeric: 'always',\n    style: 'short',\n  })\n\n  const delta = timeEnd - timeStart\n  if (delta < 60 * 60 * 1000) {\n    return rtf.format(-Math.round(delta / (60 * 1000)), 'minute')\n    // return Math.round(delta / (60 * 1000)) + ' min ago'\n  } else if (delta < 24 * 60 * 60 * 1000) {\n    return rtf.format(-(delta / (60 * 60 * 1000)).toFixed(1), 'hour')\n    // return (delta / (60 * 60 * 1000)).toFixed(1) + ' hr ago'\n  } else if (delta < 7 * 24 * 60 * 60 * 1000) {\n    return rtf.format(-(delta / (24 * 60 * 60 * 1000)).toFixed(1), 'day')\n    // return (delta / (24 * 60 * 60 * 1000)).toFixed(1) + ' day ago'\n  } else {\n    return isoTimeStamp.slice(0, 10)\n  }\n}\n","import { fetchThreatFeed } from './fetch-threat-feed.mts'\nimport { outputThreatFeed } from './output-threat-feed.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleThreatFeed({\n  direction,\n  ecosystem,\n  filter,\n  outputKind,\n  page,\n  perPage,\n}: {\n  direction: string\n  ecosystem: string\n  filter: string\n  outputKind: OutputKind\n  page: string\n  perPage: number\n}): Promise<void> {\n  const data = await fetchThreatFeed({\n    direction,\n    ecosystem,\n    filter,\n    page,\n    perPage,\n  })\n\n  await outputThreatFeed(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleThreatFeed } from './handle-threat-feed.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'threat-feed',\n  description: '[beta] View the threat feed',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.',\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config',\n    },\n    perPage: {\n      type: 'number',\n      shortFlag: 'pp',\n      default: 30,\n      description: 'Number of items per page',\n    },\n    page: {\n      type: 'string',\n      shortFlag: 'p',\n      default: '1',\n      description: 'Page token',\n    },\n    direction: {\n      type: 'string',\n      shortFlag: 'd',\n      default: 'desc',\n      description: 'Order asc or desc by the createdAt attribute',\n    },\n    eco: {\n      type: 'string',\n      shortFlag: 'e',\n      default: '',\n      description: 'Only show threats for a particular ecosystem',\n    },\n    filter: {\n      type: 'string',\n      shortFlag: 'f',\n      default: 'mal',\n      description: 'Filter what type of threats to return',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: threat-feed:list\n      - Special access\n\n    This feature requires a Threat Feed license. Please contact\n    sales@socket.dev if you are interested in purchasing this access.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Valid filters:\n\n      - anom    Anomaly\n      - c       Do not filter\n      - fp      False Positives\n      - joke    Joke / Fake\n      - mal     Malware and Possible Malware [default]\n      - secret  Secrets\n      - spy     Telemetry\n      - tp      False Positives and Unreviewed\n      - typo    Typo-squat\n      - u       Unreviewed\n      - vuln    Vulnerability\n\n    Valid ecosystems:\n\n      - gem\n      - golang\n      - maven\n      - npm\n      - nuget\n      - pypi\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'}\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} --perPage=5 --page=2 --direction=asc --filter=joke\n  `,\n}\n\nexport const cmdThreatFeed = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun,\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: 'Org name as the first argument',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one',\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleThreatFeed({\n    direction: String(cli.flags['direction'] || 'desc'),\n    ecosystem: String(cli.flags['eco'] || ''),\n    filter: String(cli.flags['filter'] || 'mal'),\n    outputKind,\n    page: String(cli.flags['page'] || '1'),\n    perPage: Number(cli.flags['perPage']) || 30,\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\n\nimport type { CResult } from '../../types.mts'\n\nexport async function outputUninstallCompletion(\n  result: CResult<{ action: string; left: string[] }>,\n  targetName: string,\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.log(result.message)\n  logger.log('')\n  logger.log(\n    'To remove the tab completion from the current shell (instance of bash) you',\n  )\n  logger.log(\n    'can run this command (due to a bash limitation NodeJS cannot do this):',\n  )\n  logger.log('')\n  logger.log(`    complete -r ${targetName}`)\n  logger.log('')\n  logger.log(\n    'Next time you open a terminal it should no longer be there, regardless.',\n  )\n  logger.log('')\n  if (result.data.left.length) {\n    logger.log(\n      'Detected more Socket Alias completions left in bashrc. Run `socket uninstall <cmd>` to remove them too.',\n    )\n    logger.log('')\n    result.data.left.forEach(str => {\n      logger.log(`  - \\`${str}\\``)\n    })\n    logger.log('')\n  }\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport constants from '../../constants.mts'\nimport {\n  COMPLETION_CMD_PREFIX,\n  getBashrcDetails,\n} from '../../utils/completion.mts'\n\nimport type { CResult } from '../../types.mts'\n\nexport async function teardownTabCompletion(\n  targetName: string,\n): Promise<CResult<{ action: string; left: string[] }>> {\n  const result = getBashrcDetails(targetName)\n  if (!result.ok) {\n    return result\n  }\n\n  const { completionCommand, sourcingCommand, toAddToBashrc } = result.data\n\n  // Remove from ~/.bashrc if found\n  // Lazily access constants.homePath\n  const bashrc = constants.homePath\n    ? path.join(constants.homePath, '.bashrc')\n    : ''\n\n  if (bashrc && fs.existsSync(bashrc)) {\n    const content = fs.readFileSync(bashrc, 'utf8')\n\n    if (content.includes(toAddToBashrc)) {\n      const newContent = content\n        // Try to remove the whole thing with comment first\n        .replaceAll(toAddToBashrc, '')\n        // Comment may have been edited away, try to remove the command at least\n        .replaceAll(sourcingCommand, '')\n        .replaceAll(completionCommand, '')\n\n      fs.writeFileSync(bashrc, newContent, 'utf8')\n\n      return {\n        ok: true,\n        data: {\n          action: 'removed',\n          left: findRemainingCompletionSetups(newContent),\n        },\n        message: 'Removed completion from ~/.bashrc',\n      }\n    } else {\n      const left = findRemainingCompletionSetups(content)\n      return {\n        ok: true,\n        data: {\n          action: 'missing',\n          left,\n        },\n        message: `Completion was not found in ~/.bashrc${left.length ? ' (you may need to manually edit your .bashrc to clean this up...)' : ''}`,\n      }\n    }\n  } else {\n    return {\n      ok: true, // Eh. I think this makes most sense.\n      data: { action: 'not found', left: [] },\n      message: '~/.bashrc not found, skipping',\n    }\n  }\n}\n\nfunction findRemainingCompletionSetups(bashrc: string): string[] {\n  return bashrc\n    .split('\\n')\n    .map(s => s.trim())\n    .filter(s => s.startsWith(COMPLETION_CMD_PREFIX))\n    .map(s => s.slice(COMPLETION_CMD_PREFIX.length).trim())\n}\n","import { outputUninstallCompletion } from './output-uninstall-completion.mts'\nimport { teardownTabCompletion } from './teardown-tab-completion.mts'\n\nexport async function handleUninstallCompletion(targetName: string) {\n  const result = await teardownTabCompletion(targetName)\n  await outputUninstallCompletion(result, targetName)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleUninstallCompletion } from './handle-uninstall-completion.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'completion',\n  description: 'Uninstall bash completion for Socket CLI',\n  hidden: true, // beta; isTestingV1\n  flags: {\n    ...commonFlags,\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [name=socket]\n\n    Uninstalls bash tab completion for the Socket CLI. This will:\n    1. Remove tab completion from your current shell for given command\n    2. Remove the setup for given command from your ~/.bashrc\n\n    The optional name is required if you installed tab completion for an alias\n    other than the default \"socket\". This will NOT remove the command, only the\n    tab completion that is registered for it in bash.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n\n      $ ${command}\n      $ ${command} sd\n  `,\n}\n\nexport const cmdUninstallCompletion = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nexport async function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const targetName = cli.input[0] || 'socket'\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleUninstallCompletion(String(targetName))\n}\n","import { cmdUninstallCompletion } from './cmd-uninstall-completion.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Teardown the Socket command from your environment'\n\nexport const cmdUninstall: CliSubcommand = {\n  description,\n  hidden: true, // beta; isTestingV1\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        completion: cmdUninstallCompletion,\n      },\n      {\n        argv,\n        description,\n        importMeta,\n        name: `${parentName} uninstall`,\n      },\n    )\n  },\n}\n","import fs from 'node:fs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nexport function addSocketWrapper(file: string): void {\n  return fs.appendFile(\n    file,\n    'alias npm=\"socket npm\"\\nalias npx=\"socket npx\"\\n',\n    err => {\n      if (err) {\n        return new Error(`There was an error setting up the alias: ${err}`)\n      }\n      logger.success(\n        `The alias was added to ${file}. Running 'npm install' will now be wrapped in Socket's \"safe npm\" 🎉`,\n      )\n      logger.log(\n        `  If you want to disable it at any time, run \\`socket wrapper --disable\\``,\n      )\n      logger.log('')\n      logger.info(\n        `This will only be active in new terminal sessions going forward.`,\n      )\n      logger.log(\n        `  You will need to restart your terminal or run this command to activate the alias in the current session:`,\n      )\n      logger.log('')\n      logger.log(`    source ${file}`)\n      logger.log('')\n      logger.log(`(You only need to do this once)`)\n    },\n  )\n}\n","import fs from 'node:fs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nexport function checkSocketWrapperSetup(file: string): boolean {\n  const fileContent = fs.readFileSync(file, 'utf8')\n  const linesWithSocketAlias = fileContent\n    .split('\\n')\n    .filter(\n      l => l === 'alias npm=\"socket npm\"' || l === 'alias npx=\"socket npx\"',\n    )\n\n  if (linesWithSocketAlias.length) {\n    logger.log(\n      `The Socket npm/npx wrapper is set up in your bash profile (${file}).`,\n    )\n    logger.log('')\n    logger.log(\n      `If you haven't already since enabling; Restart your terminal or run this command to activate it in the current session:`,\n    )\n    logger.log('')\n    logger.log(`    source ${file}`)\n    logger.log('')\n\n    return true\n  }\n  return false\n}\n","import fs, { existsSync } from 'node:fs'\n\nimport { debugFn } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { confirm } from '@socketsecurity/registry/lib/prompts'\n\nimport { addSocketWrapper } from './add-socket-wrapper.mts'\nimport { checkSocketWrapperSetup } from './check-socket-wrapper-setup.mts'\nimport constants from '../../constants.mts'\nimport { getBashrcDetails } from '../../utils/completion.mts'\nimport { updateInstalledTabCompletionScript } from '../install/setup-tab-completion.mts'\n\nexport async function postinstallWrapper() {\n  // Lazily access constants.bashRcPath and constants.zshRcPath.\n  const { bashRcPath, zshRcPath } = constants\n  const socketWrapperEnabled =\n    (existsSync(bashRcPath) && checkSocketWrapperSetup(bashRcPath)) ||\n    (existsSync(zshRcPath) && checkSocketWrapperSetup(zshRcPath))\n\n  if (!socketWrapperEnabled) {\n    await installSafeNpm(\n      `\nThe Socket CLI is now successfully installed! 🎉\n\nTo better protect yourself against supply-chain attacks, our \"safe npm\" wrapper can warn you about malicious packages whenever you run 'npm install'.\n\nDo you want to install \"safe npm\" (this will create an alias to the socket-npm command)?\n    `.trim(),\n    )\n  }\n\n  // Attempt to update the existing tab completion\n  let updatedTabCompletion = false\n  try {\n    const details = getBashrcDetails('') // Note: command is not relevant, we just want the config path\n    if (details.ok) {\n      if (fs.existsSync(details.data.targetPath)) {\n        // Replace the file with the one from this installation\n        const result = updateInstalledTabCompletionScript(\n          details.data.targetPath,\n        )\n        if (result.ok) {\n          // This will work no matter what alias(es) were registered since that\n          // is controlled by bashrc and they all share the same tab script.\n          logger.success('Updated the installed Socket tab completion script')\n          updatedTabCompletion = true\n        }\n      }\n    }\n  } catch (e) {\n    debugFn('fail: setup tab completion\\n', e)\n    // Ignore. Skip tab completion setup.\n  }\n  if (!updatedTabCompletion) {\n    // Setting up tab completion requires bashrc modification. I'm not sure if\n    // it's cool to just do that from an npm install...\n    logger.log('Run `socket install completion` to setup bash tab completion')\n  }\n}\n\nasync function installSafeNpm(query: string): Promise<void> {\n  logger.log(`\n _____         _       _\n|   __|___ ___| |_ ___| |_\n|__   | . |  _| '_| -_|  _|\n|_____|___|___|_,_|___|_|\n\n`)\n  if (\n    await confirm({\n      message: query,\n      default: true,\n    })\n  ) {\n    // Lazily access constants.bashRcPath and constants.zshRcPath.\n    const { bashRcPath, zshRcPath } = constants\n    try {\n      if (existsSync(bashRcPath)) {\n        addSocketWrapper(bashRcPath)\n      }\n      if (existsSync(zshRcPath)) {\n        addSocketWrapper(zshRcPath)\n      }\n    } catch (e) {\n      throw new Error(\n        `There was an issue setting up the alias: ${(e as any)?.['message']}`,\n      )\n    }\n  }\n}\n","import fs from 'node:fs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nexport function removeSocketWrapper(file: string): void {\n  return fs.readFile(file, 'utf8', function (err, data) {\n    if (err) {\n      logger.fail('There was an error removing the alias:')\n      logger.error(err)\n      return\n    }\n    const linesWithoutSocketAlias = data\n      .split('\\n')\n      .filter(\n        l => l !== 'alias npm=\"socket npm\"' && l !== 'alias npx=\"socket npx\"',\n      )\n\n    const updatedFileContent = linesWithoutSocketAlias.join('\\n')\n\n    fs.writeFile(file, updatedFileContent, function (err) {\n      if (err) {\n        logger.error(err)\n        return\n      }\n      logger.success(\n        `The alias was removed from ${file}. Running 'npm install' will now run the standard npm command in new terminals going forward.`,\n      )\n      logger.log('')\n      logger.info(\n        `Note: We cannot deactivate the alias from current terminal sessions. You have to restart existing terminal sessions to finalize this step.`,\n      )\n    })\n  })\n}\n","import { existsSync } from 'node:fs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { addSocketWrapper } from './add-socket-wrapper.mts'\nimport { checkSocketWrapperSetup } from './check-socket-wrapper-setup.mts'\nimport { postinstallWrapper } from './postinstall-wrapper.mts'\nimport { removeSocketWrapper } from './remove-socket-wrapper.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'wrapper',\n  description: 'Enable or disable the Socket npm/npx wrapper',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    enable: {\n      type: 'boolean',\n      default: false,\n      description: 'Enables the Socket npm/npx wrapper',\n    },\n    disable: {\n      type: 'boolean',\n      default: false,\n      description: 'Disables the Socket npm/npx wrapper',\n    },\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <flag>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} --enable\n      $ ${command} --disable\n  `,\n}\n\nexport const cmdWrapper = {\n  description: config.description,\n  hidden: config.hidden,\n  run,\n}\n\nasync function run(\n  argv: readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string },\n): Promise<void> {\n  // I don't think meow would mess with this but ...\n  if (argv[0] === '--postinstall') {\n    await postinstallWrapper()\n    return\n  }\n\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName,\n  })\n\n  const { json, markdown } = cli.flags\n  let { disable, enable } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n\n  if (isTestingV1()) {\n    const [arg] = cli.input\n    if (arg === 'on' || arg === 'enable' || arg === 'enabled') {\n      enable = true\n      disable = false\n    } else if (arg === 'off' || arg === 'disable' || arg === 'disabled') {\n      enable = false\n      disable = true\n    }\n  }\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!(enable || disable),\n      message: isTestingV1()\n        ? 'Must use on or off argument'\n        : 'Must use --enable or --disable',\n      pass: 'ok',\n      fail: 'missing',\n    },\n    {\n      nook: true,\n      test: !enable || !disable,\n      message: isTestingV1()\n        ? 'Do not use both on and off'\n        : 'Do not use both --enable and --disable',\n      pass: 'ok',\n      fail: 'missing',\n    },\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  // Lazily access constants.bashRcPath and constants.zshRcPath.\n  const { bashRcPath, zshRcPath } = constants\n  if (enable) {\n    if (existsSync(bashRcPath) && !checkSocketWrapperSetup(bashRcPath)) {\n      addSocketWrapper(bashRcPath)\n    }\n    if (existsSync(zshRcPath) && !checkSocketWrapperSetup(zshRcPath)) {\n      addSocketWrapper(zshRcPath)\n    }\n  } else {\n    if (existsSync(bashRcPath)) {\n      removeSocketWrapper(bashRcPath)\n    }\n    if (existsSync(zshRcPath)) {\n      removeSocketWrapper(zshRcPath)\n    }\n  }\n  if (!existsSync(bashRcPath) && !existsSync(zshRcPath)) {\n    logger.fail('There was an issue setting up the alias in your bash profile')\n  }\n}\n","#!/usr/bin/env node\n\nimport { fileURLToPath, pathToFileURL } from 'node:url'\n\nimport meow from 'meow'\nimport { messageWithCauses, stackWithCauses } from 'pony-cause'\nimport updateNotifier from 'tiny-updater'\n\nimport { debugFn, debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { cmdAnalytics } from './commands/analytics/cmd-analytics.mts'\nimport { cmdAuditLog } from './commands/audit-log/cmd-audit-log.mts'\nimport { cmdCdxgen } from './commands/cdxgen/cmd-cdxgen.mts'\nimport { cmdCI } from './commands/ci/cmd-ci.mts'\nimport { cmdConfig } from './commands/config/cmd-config.mts'\nimport { cmdScanCreate } from './commands/dependencies/cmd-dependencies.mts'\nimport { cmdDiffScan } from './commands/diff-scan/cmd-diff-scan.mts'\nimport { cmdFix } from './commands/fix/cmd-fix.mts'\nimport { cmdInfo } from './commands/info/cmd-info.mts'\nimport { cmdInstall } from './commands/install/cmd-install.mts'\nimport { cmdJson } from './commands/json/cmd-json.mts'\nimport { cmdLogin } from './commands/login/cmd-login.mts'\nimport { cmdLogout } from './commands/logout/cmd-logout.mts'\nimport { cmdManifest } from './commands/manifest/cmd-manifest.mts'\nimport { cmdNpm } from './commands/npm/cmd-npm.mts'\nimport { cmdNpx } from './commands/npx/cmd-npx.mts'\nimport { cmdOops } from './commands/oops/cmd-oops.mts'\nimport { cmdOptimize } from './commands/optimize/cmd-optimize.mts'\nimport { cmdOrganizationPolicyLicense } from './commands/organization/cmd-organization-policy-license.mts'\nimport { cmdOrganizationPolicyPolicy } from './commands/organization/cmd-organization-policy-security.mts'\nimport { cmdOrganization } from './commands/organization/cmd-organization.mts'\nimport { cmdPackage } from './commands/package/cmd-package.mts'\nimport { cmdRawNpm } from './commands/raw-npm/cmd-raw-npm.mts'\nimport { cmdRawNpx } from './commands/raw-npx/cmd-raw-npx.mts'\nimport { cmdReport } from './commands/report/cmd-report.mts'\nimport { cmdRepos } from './commands/repos/cmd-repos.mts'\nimport { cmdScan } from './commands/scan/cmd-scan.mts'\nimport { cmdThreatFeed } from './commands/threat-feed/cmd-threat-feed.mts'\nimport { cmdUninstall } from './commands/uninstall/cmd-uninstall.mts'\nimport { cmdWrapper } from './commands/wrapper/cmd-wrapper.mts'\nimport constants from './constants.mts'\nimport { AuthError, InputError, captureException } from './utils/errors.mts'\nimport { failMsgWithBadge } from './utils/fail-msg-with-badge.mts'\nimport { meowWithSubcommands } from './utils/meow-with-subcommands.mts'\nimport { serializeResultJson } from './utils/serialize-result-json.mts'\n\nconst __filename = fileURLToPath(import.meta.url)\n\nconst { SOCKET_CLI_BIN_NAME } = constants\n\n// TODO: Add autocompletion using https://socket.dev/npm/package/omelette\nvoid (async () => {\n  await updateNotifier({\n    name: SOCKET_CLI_BIN_NAME,\n    // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION.\n    version: constants.ENV.INLINED_SOCKET_CLI_VERSION,\n    ttl: 86_400_000 /* 24 hours in milliseconds */,\n  })\n\n  try {\n    await meowWithSubcommands(\n      {\n        ci: cmdCI,\n        cdxgen: cmdCdxgen,\n        config: cmdConfig,\n        fix: cmdFix,\n        info: cmdInfo,\n        install: cmdInstall,\n        json: cmdJson,\n        login: cmdLogin,\n        logout: cmdLogout,\n        npm: cmdNpm,\n        npx: cmdNpx,\n        oops: cmdOops,\n        optimize: cmdOptimize,\n        organization: cmdOrganization,\n        package: cmdPackage,\n        'raw-npm': cmdRawNpm,\n        'raw-npx': cmdRawNpx,\n        report: cmdReport,\n        wrapper: cmdWrapper,\n        scan: cmdScan,\n        'audit-log': cmdAuditLog,\n        repos: cmdRepos,\n        dependencies: cmdScanCreate,\n        analytics: cmdAnalytics,\n        'diff-scan': cmdDiffScan,\n        'threat-feed': cmdThreatFeed,\n        manifest: cmdManifest,\n        uninstall: cmdUninstall,\n      },\n      {\n        aliases: {\n          audit: {\n            description: cmdAuditLog.description,\n            hidden: true,\n            argv: ['audit-log'],\n          },\n          auditLogs: {\n            description: cmdAuditLog.description,\n            hidden: true,\n            argv: ['audit-log'],\n          },\n          deps: {\n            description: cmdScanCreate.description,\n            hidden: true,\n            argv: ['dependencies'],\n          },\n          feed: {\n            description: cmdThreatFeed.description,\n            hidden: true,\n            argv: ['threat-feed'],\n          },\n          license: {\n            description: cmdOrganizationPolicyLicense.description,\n            hidden: true,\n            argv: ['organization', 'policy', 'license'],\n          },\n          org: {\n            description: cmdOrganization.description,\n            hidden: true,\n            argv: ['organization'],\n          },\n          orgs: {\n            description: cmdOrganization.description,\n            hidden: true,\n            argv: ['organization'],\n          },\n          organizations: {\n            description: cmdOrganization.description,\n            hidden: true,\n            argv: ['organization'],\n          },\n          organisation: {\n            description: cmdOrganization.description,\n            hidden: true,\n            argv: ['organization'],\n          },\n          organisations: {\n            description: cmdOrganization.description,\n            hidden: true,\n            argv: ['organization'],\n          },\n          pkg: {\n            description: cmdPackage.description,\n            hidden: true,\n            argv: ['package'],\n          },\n          repo: {\n            description: cmdRepos.description,\n            hidden: true,\n            argv: ['repos'],\n          },\n          repository: {\n            description: cmdRepos.description,\n            hidden: true,\n            argv: ['repos'],\n          },\n          repositories: {\n            description: cmdRepos.description,\n            hidden: true,\n            argv: ['repos'],\n          },\n          security: {\n            description: cmdOrganizationPolicyPolicy.description,\n            hidden: true,\n            argv: ['organization', 'policy', 'security'],\n          },\n        },\n        argv: process.argv.slice(2),\n        name: SOCKET_CLI_BIN_NAME,\n        importMeta: { url: `${pathToFileURL(__filename)}` } as ImportMeta,\n      },\n    )\n  } catch (e) {\n    process.exitCode = 1\n    debugFn('Uncaught error (BAD!):')\n    debugFn(e)\n\n    // Try to parse the flags, find out if --json or --markdown is set\n    let isJson = false\n    try {\n      const cli = meow(``, {\n        argv: process.argv.slice(2),\n        importMeta: { url: `${pathToFileURL(__filename)}` } as ImportMeta,\n        flags: {},\n        // Do not strictly check for flags here.\n        allowUnknownFlags: true,\n        autoHelp: false,\n      })\n      isJson = !!cli.flags['json']\n    } catch {}\n\n    let errorBody: string | undefined\n    let errorTitle: string\n    let errorMessage = ''\n    if (e instanceof AuthError) {\n      errorTitle = 'Authentication error'\n      errorMessage = e.message\n    } else if (e instanceof InputError) {\n      errorTitle = 'Invalid input'\n      errorMessage = e.message\n      errorBody = e.body\n    } else if (e instanceof Error) {\n      errorTitle = 'Unexpected error'\n      errorMessage = messageWithCauses(e)\n      errorBody = stackWithCauses(e)\n    } else {\n      errorTitle = 'Unexpected error with no details'\n    }\n\n    if (isJson) {\n      logger.log(\n        serializeResultJson({\n          ok: false,\n          message: errorTitle,\n          cause: errorMessage,\n        }),\n      )\n    } else {\n      logger.error('\\n') // Any-spinner-newline\n      logger.fail(failMsgWithBadge(errorTitle, errorMessage))\n      if (errorBody) {\n        // Explicitly use debugLog here.\n        debugLog(errorBody)\n      }\n    }\n\n    await captureException(e)\n  }\n})()\n"],"names":["time","process","logger","ok","message","cause","rows","cols","screen","label","barWidth","barSpacing","xOffset","maxHeight","barBgColor","data","formattedData","totalTopAlerts","sortedTopFiveAlerts","top_five_alert_types","formatted","style","line","text","baseline","xLabelPadding","xPadding","wholeNumbersOnly","legend","width","x","y","result","DRY_RUN_BAILING_NOW","commandName","description","hidden","flags","file","type","shortFlag","repo","default","scope","run","parentName","markdown","repoName","nook","test","pass","fail","filePath","perPage","outputJson","outputMarkdown","page","REDACTED","desc","generated","org","nextPage","user_email","debugFn","logType","SOCKET_WEBSITE_URL","interactive","help","YARN_LOCK","__proto__","cleanupPackageLock","configuration","coerce","filter","only","profile","standard","technique","alias","array","key","boolean","string","allowUnknownFlags","argv","length","yargv","branch","commit_hash","commit_message","committers","make_default_branch","set_as_pending_head","spinner","scanStatus","updateProgress","policyStatus","finishedFetching","scan","version","alerts","healthy","addAlert","options","reportLevel","policy","url","manifest","ecomap","pkgmap","vermap","filemap","short","includeLicensePolicy","depth","value","Package","Policy","scanId","socketJson","cdxgen","count","conda","gradle","sbt","verbose","cwd","stdout","stderr","poms","buf","resolve","reject","keeping","collecting","arr","fs","sbtOpts","bin","gradleOpts","tmp","branchName","fold","commitMessage","commitHash","defaultBranch","outputKind","pendingHead","pullRequest","readOnly","report","autoManifest","slug","name","failed","obj","config","full","auto","get","list","set","unset","offset","columns","field","limit","orgSlug","showHidden","colors","maxArrayLength","after","before","json","workspace","newVersion","stdio","email","user","SOCKET_CLI_GITHUB_TOKEN","auth","_octokitGraphql","headers","ttlMs","githubCachePath","recursive","match","number","pull_number","state","context","node_id","pullRequestId","enabled","error","details","GITHUB_REPOSITORY","author","apiType","cacheKey","entry","index","parent","allOpenPrs","per_page","baseRefName","headRefName","baseBranch","head","base","body","consolidate","nothrow","include","existing","unfixable","upgradable","path","testScript","pkgPath","isCi","fixed","pkgEnvDetails","infoEntriesLoop","activeBranches","pkgJsonPathsLoop","editable","hasAnnouncedWorkspace","oldVersionsLoop","vulnerableVersionRange","dependencies","optionalDependencies","peerDependencies","updateNode","updatePackageJsonFromNode","ignoreWhitespace","actualTree","errored","skipPr","purl","editablePkgJson","PNPM","args","lockfileContent","lockfile","cmdName","agent","DRY_RUN_NOT_SAVING","autoMerge","autopilot","isMultiple","rangeStyle","purls","NPM","acc","fallbackToUrl","severityCount","pkgVersion","Maintenance","Quality","Vulnerabilities","Object","outputPackageIssuesDetails","strict","includeAllIssues","toAddToBashrc","bashrcUpdated","actions","targetPath","completion","updateConfigValue","SOCKET_PUBLIC_API_TOKEN","apiBaseUrl","apiProxy","choices","enforcedOrgs","applyLogout","attemptLogout","debugLog","stdin","out","filename","required","canceled","defaultOnReadError","kotlin","scala","setup","aliases","yolo","throw","YARN_CLASSIC","overrides","pkgs","pkgid","names","isPlacingHigher","insertIndex","entries","added","addedInWorkspaces","updated","updatedInWorkspaces","warnedPnpmWorkspaceRequiresNpm","npmExecPath","overridesDataObjects","semver","package","depAliasMap","thisSpec","depObj","newSpec","updateManifestByAgent","NPM_BUGGY_OVERRIDES_PATCHED_VERSION","VLT","prod","pin","mw1","mw2","mw3","security","license","defaultSub","quota","self","capabilities","score","transitively","selfCaps","valid","components","License","console","artifacts","artifact","namespace","supplyChain","maintenance","quality","vulnerability","missing","dupes","blocks","outputPurlsShallowScore","shallowScore","shallow","deep","NPX","meowOrExit","create","view","visibility","outputCreateRepo","homepage","repoDescription","sort","results","all","direction","del","update","setAsAlertsPage","dryRun","defaultOrgSlug","updatedInput","id1","id2","repos","targetRepos","scansCreated","githubToken","repoApiUrl","scanCreated","lastCommitter","tmpDir","fileCount","firstFailureResult","isManifest","method","response","detailedError","repoSlug","lastCommitMessage","repoDetails","treeDetails","githubApiUrl","orgGithub","from","created_at","year","month","day","fromTime","untilTime","DOT_SOCKET_DOT_FACTS_JSON","constants","env","SOCKET_CLI_API_TOKEN","stream","diff","github","metadata","reach","meta","reachability","keys","fg","selectedFg","selectedBg","height","border","columnWidth","columnSpacing","truncate","bottom","content","table","numeric","eco","action","left","zshRcPath","updatedTabCompletion","enable","disable","SOCKET_CLI_BIN_NAME","ci","fix","info","install","login","logout","npm","npx","oops","optimize","organization","wrapper","analytics","uninstall","audit","auditLogs","deps","feed","orgs","organizations","organisation","organisations","pkg","repository","repositories","importMeta","autoHelp","errorTitle","errorMessage","errorBody"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMO;AAGL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACbO;AAIL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACRuC;;AAGvC,iBAAA;AAEA;;AAeA;AACA;AAeO;;;;;AAUHA;AAOF;AAEA;AACEC;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;;AAGE;AAEA;;;AAGIA;;;AAGAA;AAEIC;AACAC;AACAC;AACF;AAEJ;AACF;AACEH;AACF;AAEA;AACF;AAEA;;;;AAME;AACA;;;AAGIA;;AAEAA;AACF;AACF;AACEA;AACF;AACF;;AAEA;AACF;AAkBO;;AAOP;;AAEA;;AAEA;AAoCA;;AAEA;AACA;;AAIA;;AAEA;AACA;AAEA;AAEA;AACE;AACA;AACA;AACE;AACF;AACA;AACA;AAA8BI;AAASC;AAASC;AAAO;;;;;;;;;AA2DvD;AACA;AACEC;AACAC;AACAC;AACAC;AACAC;AACAC;AACF;AAEAN;;;;AAIEO;AACF;;AAGA;AACAP;AACF;AAEO;;;;AAOL;AACEQ;AACF;AAEA;AACE;;AAEE;AACA;AACEC;;AAEAA;AACF;AACF;AACF;AACA;AACE;AACED;AACF;AACF;AAEA;;AAIEE;AACF;;AAGE;AACAC;;AAEJ;AAEO;;;;AAOL;AACEH;AACF;AAEA;AACE;;AAEE;AACA;AACEC;AACF;AACEA;AACF;AACF;AACF;AAEA;AACE;AACA;;AAEE;AACEG;AACF;AACEA;AACF;AACF;AACF;AAEA;;AAIEF;AACF;;AAGE;AACAC;;AAEJ;AAEA;;AAEA;AAEA;AAOE;;AAEEE;AAASC;AAAcC;AAAcC;;AACrCC;AACAC;AACAd;AACAe;AACAC;AACEC;;AAEFpB;AACF;AAEAD;AAEA;AACEsB;AACAC;;AAGFT;AACF;;ACrZO;;;;;AAKLtB;AAOF;AACE;;AAKEgC;;AAEAA;AACF;AACEA;AACE7B;AACAC;;AAEJ;;AAEE4B;AACE7B;;AAEAY;;AAEJ;;;;;;AAOEf;AACF;AACF;;ACnCA;AAAQiC;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAC;AACEC;AACAC;AACAL;;AAGFM;AACEF;AACAC;AACAE;AACAP;;AAEFQ;AACEJ;AACAC;AACAE;AACAP;;AAGFnC;AACEuC;AACAC;AACAE;AACAP;AACF;;;AAEgBE;AAAM;AAE1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACM;AAAA;AAEN;AAEO;;;AAGLO;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;AAEoBC;;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMI;AACE9C;AACF;;AAEA2C;AACA;AACEI;AACF;AACA;AACE/C;AACF;;AAEAA;AACF;AACF;AACE;;AAEA;;;AAGA;AACA;;AAEA;AACF;AAEA;AAEA;AAGI;AACAgD;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACA;;AAEA5C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAGA8C;AACAC;AACF;AAEEH;;AAKA5C;AACA8C;AACAC;AACF;;AAKE/C;AACA8C;AACAC;AAGF;AAEEH;;AAEA5C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;;;AAMEuC;;AAEAW;AACF;AACF;;AChOO;;;;;AAKLC;AAOF;AACE;AACA;AACE;AACF;AACA;;AAII;AACAC;AACA;AACAC;;AAEAhB;AACAiB;;AAEF;AAGJ;;AC3BA;AAAQC;AAAS;AAEV;;;;;AAOHJ;AAOF;AAEA;AACEpD;AACF;;AAGEC;;;;AAKImD;AACF;;AAGFnD;AACF;AACEA;;;;AAKImD;AACF;AAEJ;AACF;AAEO;;;;AAMHA;AAMF;AAEA;;AAEA;AAEA;AACElD;AACAY;AACE2C;AACA;AACAC;AACAC;;;AAGAC;;;AAGE;;;;;;;AAOEC;AACF;;;;;;;AAOEA;;;AAGN;AACF;AACF;AAEO;;;;AAMHT;AAMF;AAEA;;AAEF;;AAEA;;AAEA;AACA;AAUA;;AAEA;AAEA;AACA;AACA;AACA;AACE;;;;AAaF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGInD;;AAIE6D;AACF;AACA;AACF;AACF;;ACjLO;;;;;AAKLV;AAOF;AACE;;;;;AAKEW;AACF;;;;;;AAOEX;AACF;AACF;;AClBA;;AAA6BY;AAAmB;AAEhD;AACE/B;AACAC;AACAC;AACAC;AACE;AACA;AACA6B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFI;AACEA;AACAC;AACAE;AACAP;;AAEFkB;AACEd;AACAC;AACAE;AACAP;;AAEFqB;AACEjB;AACAC;AACAE;AACAP;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAOEe;;;AAGArB;;AAEF;AACA;AAEA;AAOA;AAEA;AAGIS;;AAEA5C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;;AAGEsD;AACAH;AACAW;AACF;AACF;;ACnJA;;;;;;AAAiDI;AAAU;AAE3D;AAWA;AAGE;;AAEA;;AAEA;AAAa;AAAQ;AAAS;AAC5B;AACE;AACF;;AAEE;AACA;AACApC;AACF;AACEA;AACF;;;AAGEA;AACF;AACF;AACA;;AAEA;AACA;AACF;AAEO;;;;;AAEiB;AAAMqC;;;;;AAO1B;;AAEA;AACE;AACA;;AAEE;AAEE;AACA;;AAKFC;;AAEJ;AACF;AACA;AAEE;AACA;AAGF;;AAEI;;AAEJ;AACA;AACA;AACEpE;AACF;AACF;;ACjFA;AAAQ+B;AAAoB;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACEsC;AACE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEFC;AACE;AACA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAtC;;AAEFG;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEFoC;;;;;;;;;;AAUAC;AACIC;AAAezC;AAAe;AAC9ByC;AAAgBzC;AAAe;AAC/ByC;AAAqBzC;AAAe;AACpCyC;AAAsBzC;;AAAkB;AAC1C;AAAEyC;AAAezC;AAAe;AAC9ByC;AAAazC;AAAe;AAC5ByC;AAAiBzC;AAAe;AAChCyC;AAAkBzC;AAAe;AACjCyC;AAAazC;AAAe;AAEhC0C;AAGY;;AAGM;;AAgBhB;AACA;AACA;AAEFC;AAE2B;;AACL;;AACH;AACjB;AACkB;;AACG;AACrB;AAOkB;;AACQ;;AACD;AACzB;AAGgB;AAChB;AAAsB;AAE1B;AAEA;AACEhD;AACAC;AACAC;AACA;AACA;;;AAGF;AAEO;;;AAGLQ;AACF;AAEA;AAGIC;AAAmC;;AAGnCsC;AAEAC;;;AAGAvC;AACF;;AAEA;AACA;AACE;;AAGF;;AACQwC;AAAsB;AAC9B;AACE;AACA;AACA;;;AAKA;AACF;AAEA;AACEnF;AACA;AACF;;AAEA;AACA;AACE;AACA;AACA;AACA;;AAEEoF;AACApF;AAMF;AACA;;AAEA;AACF;;AAGF;;AClSO;AAGH2C;AAAmC;AAErC;AAAgDA;AAAW;AAC7D;;ACDA;AACEX;AAEAE;AAUK;;;AAGLQ;AACF;AAEA;AAGIC;AAAmC;AAErC3C;AAIA;AAAuC2C;AAAW;AACpD;;AC5BA;AACO;AACL;AAEA;AACEkB;;AACS5D;AAAUY;;AACrB;AAEA;AACA;AACE;AACF;AACA;AAEA;AAKA;AACE;AACF;AAEA;AACA;AAEA;;AAEIZ;AACAC;AACAW;;AAEJ;;;;AAMIZ;AACAC;AACAW;;AAEJ;AAEAgD;;AAGE5D;AACAC;AACAW;;AAEJ;;ACtDO;;;;;;AAaHgC;AAQF;AAEA;AACA;AACE;AACF;AACA;;AAMM;AAAmBwC;;AACnB;AAAmBC;;AACnB;AAAsBC;;AACtB;AAAmBC;;AACnBC;AACA;;;;AAC+C;AAC/CC;;AAEF;AAMN;;AChDO;AAGL;AACA;AACE;AACF;AACA;;AAMF;;ACRA;AACA;AACA;AACA;AACO;AAUL;AACA;AACE;AACF;AACA;;;;;AAMA;;AACQC;AAAQ;;AAGdC;AACAC;AACF;;AAGEC;AACAD;AACF;;AAGE;;;AAKA;;AAIA;AACF;;AAGE;;AAMA;AACE;AACF;AAEA;;AAEA;AACA;;AAEA;;AAEI;AACF;AACE5F;AACA4D;AACA;AACF;AACF;AAEA;;;AAEW5D;AAAUY;;AACrB;;;AAKEZ;AACAC;AACAC;;AAGJ;;AAKE;;AAOA;AACF;AAEA0F;AAEA;;;AAOM5F;AACAC;AACAC;;;;;AAMAF;AACAC;AACAC;;AAEJ;AAEA4F;AACAF;AACF;AAEA;AACE;AACF;AACA;AACE;AACF;;;AAII5F;AACAC;AACAC;;AAEJ;;AAGEF;AACAY;;;AAGA;;AAEJ;;AClIA;AACA;AACO;;;;;;AASH8E;AAQF;AAEA;AAEAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAIA;AACA;AACE;AACAK;;;;AAII3D;AACA4D;AACF;AAEAC;AAEI;;AAEA;AACE;AAAc;AACZC;;AAEEC;AAUF;AACA;AACF;AACA;AAAa;AACX;AACEA;AAUF;AACA;AACF;AACA;AAAgB;;AAEZA;AAUF;AACA;AACF;AAEA;AAAe;AACb;AAMEA;AAUF;AACA;AACF;AAEA;AAAc;AACZ;AACA;AACEA;AAUF;AACA;AACF;AAKF;AACF;AAEJ;AACF;AAEAT;AAEA;;AAEI1F;AACAY;AAAQsF;AAAQ;;AAEpB;AAEA;;;;AAIEE;;AAAiBC;;AACjBJ;;;;AAKEjG;AACAC;AAEAW;;AAEJ;;AAGEZ;AACAY;;AAEJ;AAEA;AAKE;;AAEE0F;AACAC;AACAC;;AAEF;AACF;AAEA;AAUE;;AAEA;AACA;;AAEE;;AAEEC;AACF;AACF;AACE;;AAEA;AACA;;AAEE;;AAEEC;AACF;AACF;AACE;;AAEA;AACA;AACA;;AAGE;;AAEEC;AACF;AACF;AACE;;AAEA;AACA;AACA;AACA;;AAEEC;AACF;AACF;AACF;AACF;AACF;AAEA;AAIE;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;AACA;AACA;AACF;;AClUO;;;;;;;;AAaHC;AAUF;AAEA;AACE/G;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;AAEA;;;;;;AASI;;AAEF;AAGF;AACE;AACAD;;AAEA;;AAEEC;AACA;AACF;AACAA;AACA;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAIE;AAIA;AACEA;;AAEF;AAEAA;AACA;AACF;AAEA;AACE;AAGqC;AAC/B+G;AAGN;AACE/G;;AAEF;AAEAA;AACAA;AACA;AACF;AAEA;AACEA;AACF;AACEA;AAA8BgH;AAAY;AAC5C;AACF;AAEO;AAIL;AAEA;;AAEE;AACAd;;AAGF;AACEjG;AACAY;AACF;AACF;AAEO;AAIL;;AACWoG;AAAiD;;;;;AACxBT;AAAI;;AAElC;AACAU;AACA;;AAEA;AACAC;;AAEJ;AAGF;AAEF;;AAEA;AACA;;AAEA;;AAEA;;AAKA;;AAEA;;AAEA;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAKA;AAYA;AAGE;AACF;;ACjNO;;;;;;;;AAQLL;AAUF;;;;;AAMIM;;;;;AAKAN;AACF;AACF;;ACxBO;AAKL;AACE/G;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEA;AACEA;;AAEF;;AAGEA;AACAA;AACA;AACEA;AAGAA;AACF;AACEA;AAGF;AACAA;AACA;AACF;AAEA;AACAA;AAEA;AAGIE;AACAsC;;;AAIJ;AACF;;AChEA;AACA;;AAiBO;AACL;AACA;AACA6E;AAGA;AACEC;AAAe;AACfC;AACAC;AACAC;AACAC;;;;AAKF;;;;AAKA;;;AAIA;;;;AAIA;;;AAIA;;AAEE;;;;;;;AAOA;AACF;AAEA;AACF;;ACxDO;;;;AAILC;AACoE;AACpE;;AAEA;AACA;;AAEA;AACA;AAEA3H;AACAA;;AAEEA;AAGF;AACAA;;AAEEA;AAGF;;;AAIE;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACEA;AACF;;;AAGA;AACEA;AACAA;;AAEF;AACA;;;AAGE;;AAEEA;AACAA;;AAEF;AACA;AACF;AACAA;AACAA;;AAIIA;AACA;AACF;AAEFA;AACAA;;;;AASA;AACEA;AACAA;;AAEF;AACF;AACF;AAEA;AAKE;;AACQ2F;AAAQ;;;AAId3F;AAGAA;AAGA2F;;AAGE;AACA;AACA;AACA;AACAiC;AACF;AAEA5E;;;;AACsB6E;AAAO;;;;AACNC;;AACzB;AACE;AACEnC;AACF;AACEA;AACF;AACF;AACF;;AC5HO;;;;;AAKLgC;AAOF;AACE;;AAEA;;AACQhC;AAAQ;AAEhB3F;AACAA;AACAA;;;;;AAME;AACA;AACA;AACA;AACA;AACA;AAA2D4H;AAAI;;AAI/D;AACE5H;AACAA;;AAEF;;;AAGEA;AACA;;AAEEA;AACAA;;AAEF;AACA;AACF;;;AAGE+H;AACA;AACF;AACA;;AAEE/H;AAGA;AACF;AACA;AACA;AACA;;AAEEA;;AAEAA;AACAA;AACF;;AAEEA;AACAA;AAGAA;AACA+H;AACA;AACE/H;AACAA;AAGF;AACAA;AACAA;AACA;AACF;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA+H;AACA/H;AACF;;;;;AAQA;AACEA;AACAA;;AAEF;AACF;AACF;;AClHO;AAKL;;AAEE;AACEA;AACF;;;;AAKI;AACAgI;AACF;AACAjI;AACEkI;AACF;;AAEE;AACEjI;AACF;;AAEF;AACAD;AACE;AACE;AACEC;AACF;AACAkI;AACF;AACE;AACElI;AAGF;AACAiI;AACF;AACF;AACF;;;AAIIhI;AACAC;AACAC;;AAEJ;AACF;;AAGE;AACEH;AACF;AAEA;;AAEIC;AACAC;;;AAGJ;;;;AAMID;AACAC;;;AAGJ;AACF;;AAGED;AACAY;;;AAGA;;AAEJ;;AAEA;AACO;;;;;;;AAOD;AACA;AACF;AACA;AACE;AACE;AACA;AACF;AACA;AACE;AACA;AACA;AACF;;AAEI;;;AAGE;AACE;AACA;AACA;AACF;AACF;AACF;AACA;AACEsH;AACF;AACE;AACA;AACF;AACF;AACF;AACE;;;AAGEC;AACF;AACF;AACF;AAEA;AACF;;ACpIO;AAKL;AACErI;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;;AAGE;;AAGEA;AACF;;AAEA;AAEA;AACF;;;AAIEqI;AACAA;AACAA;AAGAA;AACAA;;AAEAA;AACAA;AACA;;AAGErI;AACF;;AAEA;AACA;AACF;;;AAIEA;AACF;AACEsI;AACF;AACF;;AC9DO;;;;;AAKLX;AAOF;;AAGE;AACF;;ACTO;;;;AAILA;AAMF;AACE;AAEA;AACE3H;AACF;AAEA;AACEA;AACA;AACE;;;;AAKAuI;;AAMF;AACF;AAEA;AACEvI;AAGA;AACE;AACA;AACA;AACAwI;;AAIAb;AACAc;AAKF;AACF;AAEA;AACEzI;AAGA;;;;;;AAOA;AACF;AACF;;AClEO;;;;;;;;;;;;;;;;;AAiBL0I;AAmBF;AACE;AACE1I;AACA;;AAEA;;;;AAIE2H;AACF;AACA3H;AACF;AAEA;AACA;AACE;AACA;AACF;AAEA;AAMA;AACE8C;AACAC;AACAC;AACAC;AACA/C;AAEF;;AAEE;AACF;AAEA;AACEF;AACA;AACF;AAEA;;;;;;AAaI2I;AACF;AAGF;AACE;AACE;AACEzF;AACA0F;AACA7B;;;AAGAT;AACAc;AACAN;AACF;AACF;AACE;AAEI7G;AACAC;AACAC;;AAEF;AAIJ;AACF;AACE;AACF;AACF;;ACnIO;AACL;AACA;AACA;AACA;AACA;AACA;AACEJ;AACA;AACAC;AACA;AACF;;AAEA;AACA;AACA;;AAEE2I;AACAE;AACAC;AACAtD;AACAoC;AACAmB;AACA/E;;AAEAgF;AACAC;AAAmB;AACnBC;AACArG;AACAsG;AACAC;;;AAGF;AACF;;AC9BA;AAAQrH;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACAkH;AACEhH;AACAG;AAAgB;AAChBP;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;AAEA;AACE3C;AACA;AACF;;AAGF;;AC/DO;AAGL;AACA;AACA;;AAEA;;AAEIC;AACAC;AACAC;;AAEJ;;AAGE;;AAEEF;AACAC;AACAC;;AAGJ;;AAGE;;AAEEF;AACAC;AACAC;;AAGJ;;;AAIIF;AACAC;AACAC;;AAGJ;;AAGE;;;AAGIF;AACAC;AACAC;;AAGJ;AAEA;AACA;;AAEIF;AACAC;AACAC;;AAEJ;AAEA;;AAEIF;AACAY;AACAX;;AAEJ;;AAGED;AACAY;AACAX;;AAEJ;;AAGE;;;AAGID;AACAC;AACAC;;AAGJ;AAEA;AACA;;AAEIF;AACAC;AACAC;;AAGJ;;AAGEF;AACAY;AACAX;;AAEJ;;;AAIID;AACAC;AACAC;;AAEJ;;AAEA;;AAEEF;AACAC;AACAC;;AAEJ;AAEA;AAGE;AACA;AACE;AACF;AACA;AAEA;;;AAOOmJ;;AAEL;AACE;AACF;AACA;;AAEA;AACA;AACF;AAEA;AACF;AAEA;AACE;AACA;AACE;AACF;AACA;AAEA;;;AAOOA;;AAEL;AACE;AACF;AACA;AACF;AAEA;AACF;;AC7KO;AAKL;AACEvJ;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACAA;AACAA;AAGAA;;;;AAIIA;AACAA;AACF;AACF;AACAA;AACF;;AAEIA;AACAA;AACF;;AAEAA;;AAGEA;AAGF;AACE;AACEE;;AAIIqJ;AACAtC;;AAEF;AAEEsC;AACAtC;AACAhF;;AAEN;AACA;AACEjC;AACA;;AAEEA;AAGF;AACEA;AACF;AACF;AACEA;AACF;AACF;AACE;AACEE;;AAIIqJ;AACAtC;;AAEF;AAEEsC;AACAtC;AACAhF;;AAEN;AACA;AACEjC;AACA;;AAEEA;AACF;AACEA;AACF;AACF;AACEA;AACF;AACF;AACF;AACF;;AC3GO;;AAELgJ;AAIF;AACE;AAEA;AACF;;ACFA;AAAQjH;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF8B;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAIA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;AAIA;;AAII1C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACE8E;AACAkE;AACF;AACF;;AC3FO;AAKL;AACEjJ;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEA;;AAGEA;AACAA;;AAEA;AACEA;AACAA;AAGF;AACF;;AAEE;AACEA;AACAA;AAGF;AACF;AACF;;AC1CO;;AAELgJ;AAIF;AACE;AAEA;AACF;;ACFA;AAAQjH;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF8B;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAIA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;AAIA;;AAII1C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACE8E;AACAkE;AACF;AACF;;ACnFO;;AAELA;AAIF;AACE;;;;;AAKI;AACA;AACA;AACE/B;AACAuC;;AAEAvC;AACF;AACA;AACEwC;AACF;AACF;AACA;;AAEA;AACAzJ;AAIUC;AACAC;AACAW;;AAEE6I;AACAP;;AAEJ;AAEElJ;AACAY;;AAEE6I;AACAP;AACF;AACF;AAGV;AACE;AAKAnJ;AACAA;;AAEAA;;AAEE;AACA;;AAEA;AACE;;AAEEiH;AACF;AACA;;AAIA;AACF;AACF;AACA;AACEjH;AACAA;AAGF;AACF;AACF;;ACjFA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAwH;AACEtH;AACAG;AACAP;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAIA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;AAEoBC;;AACpB;AAEA;AACEE;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAEE;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;AAEEgJ;AACF;AACF;;ACjFO;AAIL;AACEjJ;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACAA;AACAA;;AAEEA;AACAA;AACF;AACF;AACEA;AACAA;;AAEEA;AACAA;AACF;AACF;AACF;;AClCO;;;AAGLiH;AAKF;AACE;AAEA;AACF;;ACJA;AAAQlF;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF8B;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAIA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;AAGA;AAEA;;AAII1C;AACA8C;AACAC;AACF;;AAEiB;AACf/C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACE8E;;AAEAmC;AACF;AACF;;ACtGO;AAIL;AACElH;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACAA;AACAA;;AAEEA;AACAA;AACF;AACF;AACEA;AACAA;;AAEEA;AACAA;AACF;AACF;AACF;;AClCO;;AAELgJ;AAIF;AACE;AAEA;AACF;;ACFA;AAAQjH;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF8B;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAIA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;AAIA;;AAII1C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACE8E;AACAkE;AACF;AACF;;ACtFA;AAEO;;AAEL9G;AAAc;AACd;AAA8BS;AAAW;AACvC;AAEIiH;AACAC;AACAC;AACAC;AACAC;AACF;;;;;AAMA;AAEJ;AACF;;ACzBO;;AAELC;AAIF;AACE;AACA;AACE;AACF;AACA;AAEA;;AACsCA;;AAGxC;;ACvBA;AAYO;;;AAKHjB;AAKF;AAEA;AACEjJ;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAWA;AACEkK;AACIC;AAAoBZ;AAA+B;AACnDY;AAAeZ;AAA0B;AACzCY;AAAkBZ;AAA6B;AAC/CY;AAAqBZ;AAAgC;AACrDY;AAAiBZ;AAA4B;AAC7CY;AAAeZ;AAA0B;AACzCY;AAAiBZ;;;AAIvBvJ;AACF;;ACtDO;;;AAGLgJ;AAKF;AACE;;AAAgDiB;AAAO;;;;AAELjB;AAAW;AAC/D;;ACJA;AAAQjH;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACAiI;AACE/H;AACAC;AACAE;AACAP;;AAEFgI;AACE5H;AACAC;AACAE;AACAP;;;;AAIJgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;AAE+BsH;;AAC/B;AAEA;AAEA;AAGInH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;;AAGEgJ;AACF;AACF;;ACvGO;;;AAGLqB;AAKF;AACE;AAIF;;ACLO;;;AAKHrB;AAKF;AAEA;AACEjJ;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;AAEA;AACA;;AAIA;AACA;AACA;AACA;AACE;AAEA;AACEA;AACAsI;AACE;AACEtI;AACAA;AACF;AACEA;AACF;AACAA;AACF;AACF;AACE;AACAA;AACAA;AACAA;AACF;AAEA;AACF;;AAEA;AACA;;AAEAA;;AAGIsK;AACAtD;AACAuD;AACAC;AACF;AAEFxK;AAGAA;AACF;;ACjFO;;;;;;AAMLgJ;AAQF;AACE;;;AAGEqB;AACF;;;;AAKErB;AACF;AACF;;ACjBA;AAAQjH;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACAsI;AACEpI;AACAC;AACAE;AACAP;;AAEFyI;AACErI;AACAC;AACAE;AACAP;;AAEF+E;AACE3E;AACAG;AACAP;;AAGF0I;AACEtI;AACAC;AACAE;AACAP;;AAGFG;AACEC;AACAC;AACAE;AACAP;AAEF;;;AAMJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLS;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;;AAE0CC;;AAC1C;AAEA;;AAGA;AAEA;AAGIG;AACA7C;AAEA8C;AACAC;AAMF;;AAGEH;AACA5C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEAjD;AAIA;AACEA;AACA;AACF;AAEA;AACE0K;AACAD;AACAzD;;;AAGA5E;AACF;AACF;;ACjKA;AAEO;;AAEL;AACA;AACA;AACA;AACAF;AACA;AAA8BS;AAAW;AACvC;AAEIkH;AACF;;;;;AAMA;AAEJ;AACF;;ACpBO;AAIL;AACE9J;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACAA;AACF;;ACDA;AACE;AACF;AAEO;AACL;AACA;AAEE;AACA;;AAGJ;AAEO;AAGL;AACA;AACF;AAEO;;AAQL;;AAIF;AAEO;;AAQL;AACF;AAEO;AAGL;AACF;AAEO;AAKL;AACA;AACA;AACA;AACA;AACA;;AAEF;AAQO;;;;AAGqB4K;AAAU;AAClCzG;;;;;AAKF;AAGA;AAGA;AAGA;AAGA;AAGA;AAGF;AAcO;AAGL;AACA;AACE;;AAIE;AACF;;AAEE;AACA;AACA;AACA;AACA;AACF;;;AAGE0G;;;AAGA5E;;;AAGN;AAEO;AAKL;AACA;AACA;AACF;AAEO;AAKL;AACA;AACA;AACA;AACF;AAEO;AAKL;AACA;AACA;AACF;AAEO;AACL;;AAAgD6E;;AAChD;;AAEF;AAEO;;AAOHlD;AACA;AACAmD;AACA;AACAC;AACF;AAAM7G;;;AACN;;AAAgD2G;;;AAE9C;AACA;AACA;AACA;AACA;AAKA;;AAEAjH;AACF;;AAEE;AACA;;AAEF;AACF;AAEO;AAKL;;AAAgDiH;;AAChD;AAAyClD;;AACzC;;AAK4B;AAAS;AAAS;AAC1C;;AAEE;;;;;AAOE;;AAEA/D;AACF;AACF;AACF;AAEJ;AAEO;AAIL;AAAyC+D;;;;AAWzC;AACE;AACF;AACF;AAEO;AAIL;AACA;AACA;;AAEF;AAEO;AAIL;;AAAgDkD;;AAChD;AACF;AAEO;;AAIH;AAAyClD;;;;;AAKhC3H;;;;AAET4D;;AAGE5D;AACAC;AACAC;;AAEJ;AACF;;ACtSA;AACA;;AAEI;;AACQ8K;;;;AAGR;;AAEEC;AACF;AACF;AACA;AACF;AAEA;AACO;;AAEH;;AACQD;;;;AAGR;AACAE;AACEC;;AAEA;AACF;AACF;AACA;AACF;AAEO;AAKL;AACA;AACA;;AAEA;;;AAGEvK;AACA;AACF;AACA;AACF;AAEA;AAEE;AACAwK;AAEA;AACA;;AAEE;AACA;;AAEE;AACF;;AAEF;AACF;AAEA;AACE;;AACQC;AAAgB;;AAExB;AACE;AAAkCC;AAAgB;AACpD;AACA;AACF;AA6BO;;AAWL;AACE;AACF;AAEA;;AACQV;AAAW;AAAM1G;;;AACzB;AACA;;;AAG0CqH;AAAM;;AACpCC;AAAc;AACtB;AACA;AACA;;AAEA;AACA;;AAEI;;;AAGEC;AACAC;AACF;AACA9H;AACA;;AAEA;;AAEA;;AAEAA;AAIF;AACF;AACA;AACA;AACA;;AAEI;;;;;AAKA;AACAA;AACA;AACA;AACE+H;AACF;AACEA;AACF;AACA;;;AAGA;AACA/H;AACF;AACF;AACA;AACF;;;AAK2B;AAAQ;;AAErC;AAEA;;AAKF;AAOO;AACLgI;AACE;AACF;AACA;;AAEE;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQC;AAAoB;;AAIxB;;AACWC;;AACX;;AAEAC;AACF;AACA;;AAKsC9L;AAAQ;;AACnC6L;AAAgBE;;AAC3B;;AACSF;;AACX;AAOO;AACL;;AACQG;;;;AAGR;;AAEA;AACA;AACE;AACF;;;AAGE3J;;AAEJ;AASO;AAKL;AAGF;AAcA;AAKE;AAAkB4B;;;;AACVgI;AAAO;AACf;AACA;AACA;AACA;;;AAIE;AACA;AACA;;AAIJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACiB5J;AAAK;;AAgBlB;AAAkB4C;;AAChB;AACA;;;;;AAKIyG;AACEQ;AACAC;AACAxL;AACAyL;AACAC;AACAC;;AAEFhB;AACE;;AAEF;AACF;AACF;AACF;;;AAIA;AACF;;AAEA;AACA;AACA;;AAEEiB;;;AAMMd;AACAe;AACF;;;AAKJ;AACF;AAEA;AAAkBvH;;AAChB;AACA;;;;;AAKIyG;AACEQ;;AAEAvL;AACAyL;AACAC;AACAC;;AAEFhB;;AAEEmB;AACAC;AACA;AACA;;;;AAKF;AACF;AACF;AACF;AACA;AACF;AAQO;;AAQGC;AAAqBjC;AAAU;AACrCzG;;;AAGF;AACA;;AAEE;AACF;AACA;AACA;;AAEE;;;;AAIE2I;AACAC;AACAC;AACF;;;AAGA;;AAKE;;AAOF;;AAEF;AACA;AACF;AAEO;AAKL;;;AAEUnM;AAAU;;;AAGhBiM;AACAnB;AACAe;AACF;AACA;;AAEF;AACF;AAEO;AAML;;AAAgD5B;;;;AAG9C;;AAEAjH;AACF;AACF;;ACzhBO;AAEA;;AAIHM;AACA8I;AACAC;AACA;AACAC;AACEhJ;AACAiJ;AACAC;AACAC;AACA;AACF;;AAMJ;;ACkDA;;AAIU1F;AAAoB;AAC1BzD;;;;AAIA;AAA8BoJ;AAAU;;AAExC;;AAEA;;AAEF;AACF;AAEO;;;;;;;AASHC;AASF;AAEA;;AACQ7H;AAAQ;;AACR8H;AAAkB;;AAE1B;AACA;AACA;AACA;;;;AAeA;AACE;AACAC;AAEMvB;;;AAMR;AACEoB;;AAEF;AACA;AACA;AACA;AAEA;;;;;;AASqE;;;AAInE1J;;AAEE5D;AACAC;AACAC;;AAEJ;AAEA;;AAEA;;;AAGEH;;AACSC;AAAUY;AAAQ8M;AAAa;;AAC1C;;;;AAQA;AAEE;AACAC;AAEF;;AAKE/J;;;;AAKE5D;AACAC;AACAC;;;;AAMJ0N;AACe1I;;AAIb;AACA;;AAEA;AAEA;AACA;AACE;AACF;;AAGA;AACE;AACA;AACA;AACE;;AAKE2I;AACF;AACF;;;AAMA;;AAEA;AACF;AAEA9N;;;;AAKE6D;AACF;AACA;AACA;;AAEE7D;;;AAGA;AACF;;AAGA;;AAEA;AACA+N;AACe5I;;AAIb;AACA;AACA;;AAGA;;AAOA;AAMA;AACEtB;AACA;;;AAGA;AACF;;AAEA;AACA;AACA;AACA;AACEmK;AACF;;AAGA;;AAEEnK;AACAoK;;AAEF;AAEAC;AACE;;;;AAKErK;AACA;AACF;;;AAIEsK;AACF;;AAEItK;AACA;AACF;;AAQA;AAMEA;AACA;;;AAGE;AACF;AACA;AACF;;AAMA;;AAIE;AACF;;AAGA;AAEA;AACE;AACEuK;;AAAwD;AAC1D;AACA;AACEC;;AAEA;AACF;AACA;AACEC;;AAAgE;;;AAIpEC;AACAC;AAEE;;AAMF;AACA;AAAmCC;;AACjC5K;AACA;AACA;AACE;AACA;AACF;AACA;AACF;;AAGEoK;;AAEF;;;AAKA;;;AAGE;AACA;AAA6CrG;AAAI;AACjD;AACE8G;AACA;;AAEE;AACA;;AAA2C5D;AAAgB;AAC7D;;AAEF;AACE6D;AACF;;AAEAA;AACA3C;AACF;;;AAIA;AACA;;AAEI;AACA;AACA;AACE;AACA;AACAhM;AAGA;AACF;;AAEE;AACA;AAIF;AAEA;AACEA;AAGA;AACF;;;AAKA;AACE;AACA;AAEA4O;AACA/K;AACF;AACA;;AAEE+K;AACA/K;AACF;AACE;AACA;;AAMIkH;AACAC;;AAIJ4D;AACA5O;AAGF;AACA;AACE;AACA;AACA;AACA;AAA6C4H;AAAI;;AAE/C;;AAEF;AACA8G;AACA;AACF;;AAEA;AACA;;AASIG;AACAjE;;AAGJ;AACA;;;AASIA;AACF;AAEF;;AACU/J;AAAK;AACb;AACAb;AACA;;;AAGE;;;AACiB+L;AAAQ;AACzB;AACE/L;AACF;;AAMEA;AACF;;;AAGF;AACF;;AAEAgM;AACA2C;AACF;AACF;AAEA;;AAEE;AACA;AACA;AACA;AAA6C/G;AAAI;;AAEjD;AACE8G;AACF;AACEC;AACF;AACF;AACA;;;AAGIG;AACA;AACA;AAEyBL;;AAEzB;AACA;AAA6C7G;AAAI;;;AAG/C;;AAEF;AACA8G;AACF;;AAEF;AACA;;;AAGE;AACF;AACF;AACF;;;AAGA;AACF;AAEA;AACE1O;AACF;;;AAGA;;;AAGF;;;AAISC;AAAUY;AAAQ8M;AAAY;AAAE;AAC3C;;AChiBA;;AAAmBoB;AAAK;AAQxB;AACE;AACA;AACA;AACA;AACA;AACExB;;AAEF;AACA;AACF;AAEA;;;;AAIqB5H;AAAQ;AACzBxB;;;;;AAKE6K;AAEE;AACA;;AAEA;AACA;AACA;;AAGFlE;AACF;AACA;;AAEF;AACF;AAEO;;;;;;;AASH0C;AASF;AAEA;;AACQ7H;AAAQ;;AACR8H;AAAkB;;AAE1B;AACA;AACA;AACA;;;;AAeA;AACE;AACAC;AAEMvB;;;AAMR;;AAEA;;AAEA;;AAEE;;AAA4DxG;AAAQ;;AAIpE;AACE+I;AACAO;AACF;AACF;AAEA;AACA;AACA;;AAME;;;AAGEtJ;AACF;;;AAKE+I;AACAO;AACAC;AACF;AACEA;AACF;AACF;;AAEA;AACA;AACA;;;AAGIjP;AACAC;AACAC;;AAEJ;AAEA;;;;;;AASqE;;;AAInE0D;;AAEE5D;AACAC;AACAC;;AAEJ;AAEA;;AAEA;;;AAGEH;;AACSC;AAAUY;AAAQ8M;AAAa;;AAC1C;;;;AAQA;AAEE;AACAC;AAEF;;;;;AASI3N;AACAC;AACAC;;;;AAMJ0N;AACe1I;;AAIb;AACA;;AAEA;AAEA;AACA;AACE;AACF;;AAGA;AACE;AACA;AACA;AACE;;AAKE2I;AACF;AACF;;;AAMA;;AAEA;AACF;AAEA9N;;;;AAKE6D;AACF;AACA;AACA;;AAEE7D;;;AAGA;AACF;;AAGA;;AAEA;AACA+N;AACe5I;;AAIb;AACA;AACA;;AAGA;;;AAOA;;;AAGI;;AAEF;AACA;AAEM;;AAEA;;;AACoCQ;AAAQ;;AAE9C;AACA;;AAGF+I;AACAO;AACF;AACF;;AAEE;;AAEF;;AAQA;AACEpL;AACA;;;AAGA;AACF;;AAEA;AACA;AACA;AACA;AACEmK;AACF;AACA;AACA;AAIA;;AAKA;;AAEEnK;AACAoK;;AAEF;AAEAC;AACE;;;;AAKErK;AACA;AACF;;;AAGEsK;;;AAGEtK;AACA;AACF;;AASA;AAMEA;AACA;;;AAGE;AACF;AACA;AACF;;AAMA;;AAIE;AACF;AAEA;AACA;AAKA;;AAIM;AACE;AACA;AACE;AACA;AACF;AACF;AACF;;;AAQU;AACA;AAGQ;AACA;AACF;AAER;;AAMZ;AACE;AACA;AACEuK;;AAAwD;AAC1D;AACA;AACEC;;AAEA;AACF;AACA;AACEC;;AAAgE;;;AAIpE;AACE;AACA;AACAQ;AACF;;AAQA;AACA;AAAmCL;;AACjC5K;AACA;AACA;AACE;AACA;AACF;AACA;AACF;;AAGEoK;;AAEF;;;AAKA;;;AAGE;AAEA;AACA;;AAEEtI;AACF;;AAEI;AACA;;AAGF+I;AACAO;AACA;AACA;AACAH;AACA;;AAC6BL;AAAuB;AACpD;AAEA;;AAKE;;AAEF;AACA;;AAEE;AACA;;AAA2C3D;AAAgB;AAC7D;;AAEF;AACE6D;AACF;;AAEA3C;AACA2C;AACF;;;AAIA;AACA;;AAEI;AACA;AACA;AACE3O;AAGA;AACF;;AAEE;AACA;AAGF;AACA;AACEA;AAGA;AACF;;;AAIA;AACE;AACA;AAEA4O;AACA/K;AACF;AACA;;AAEE+K;AACA/K;AACF;AACE;AACA;;AAMIkH;AACAC;;AAIJ4D;AACA5O;AAGF;AACA;AACE;AACA;AACA;AACA;;AAEE2F;AACF;;AAEI;AACA;;AAGF+I;AACAO;AACA;AACF;AACA;;AAEF;;AAEA;AACA;;AASIJ;AACAjE;;AAGJ;AACA;;;AASIA;AACF;AAEF;;AACU/J;AAAK;AACb;AACAb;AACA;;;AAGE;;;AACiB+L;AAAQ;AACzB;AACE/L;AACF;;AAMEA;AACF;;;AAGF;AACF;;AAEAgM;AACA2C;AACF;AACF;AAEA;;AAEE;AACA;AACA;AACA;;AAEEhJ;AACF;;AAEI;AACA;;AAGJ;AACE+I;AACAO;AACF;AACEN;AACF;AACF;AACA;;;AAGIG;AACA;AACA;AAEyBL;;AAEzB;AACA;;AAEE9I;AACF;;AAEI;AACA;;AAGJ;AACE+I;AACAO;AACF;AACE;;AAEF;AACF;;AAEEhP;AACAC;AACAC;;AAEJ;AACA0D;AACAA;AACA;;;AAGE;AACF;AACF;AACF;;;AAGA;AACF;AAEA;AACE7D;AACF;;;AAGA;;;AAGF;;;AAIA;;AACSC;AAAUY;AAAQ8M;AAAY;;AACzC;;AC5yBA;;AAAaoB;AAAK;AAEX;;;;;;;AAOLvB;AASF;AACE;AACE2B;AACAnP;AACF;AAEA;AACE;AACF;AACA;;;AAGIC;AACAC;;;AAGJ;;;AAIQkP;AAAM;;AAGZ;;;;;;;AAOE5B;AACF;AACF;AACE;;;;;;;AAOEA;AACF;AACF;;AAEIvN;AACAC;;;AAGJ;AACF;;ACxEO;;;;;;;;AAQLsN;AAUF;AACE;;;;;;;AAOEA;AACF;AAEA;AACF;;ACjBA;AAAQ6B;AAAmB;AAE3B;AACErN;AACAC;AACAC;AACAC;AACE;AACAmN;AACEjN;AACAG;AACAP;;AAKFsN;AACElN;AACAG;AACAP;;AAEFmI;AACE/H;AACAG;AACAP;;AAEF4M;AACExM;AACAG;;AAKAgN;AACAlN;;AAEFmN;AACEpN;AACAG;AACAP;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEIc;AACEV;AACAG;AACAP;;AAEFuL;AACEnL;AACAG;AACAP;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;AAEyBC;;;;;AACIG;;AAC7B;;AAEA;AACA;AACA6E;AAEA;AACE0H;AACAvM;AACF;AAEA;;AAEE7C;AACA8C;AACAC;AACF;;AAEE;AACF;AAEA;AACEjD;AACA;AACF;;AAKA0P;;AAOED;AACF;AAEA;AACEH;;AAEAlF;;;AAMAqF;AACA1M;;AAEF;AACF;;AC9JO;;AAML;AACE;AACF;AACA;AAEA;AAIA;AAKA;;AAOA;AAEA;;AAOA;AAEA;;;;;;AAUF;;ACrCA;AAAQ4M;AAAI;AAEZ;;AAEI;;AAEA;AACF;AACA;AACF;AAEA;;;;AAUYtN;AAAK;AACb;AACE;AACA;;AAEA;AACEuN;AACErP;AACAgH;AACF;AACF;AACF;AACA;AACF;AACA;AACA;AACE;AAGIsI;AAAoB;AAExB;AACE7P;AACF;;AAEA;AACF;AACF;AAEO;;;AACU8P;AAA2B;;;;AAKxCC;AAOF;;AAGE/P;AACA;AACF;;;AAIF;;AAEA;AACA;AAEE;AACEA;AACF;AACA;AACE;AACAgQ;AACAC;AACAC;;;AAGFlQ;AACAmQ;AAGAnQ;AACA;;AAEIA;AACF;;AAIAoQ;AACF;AACEpQ;AACF;;;AAKAA;;AAEEA;AACwE6P;;AAE1E;AACE7P;AACuF6P;;AAEzF;;;AAOA;AACE7P;AACF;AACF;;ACnIO;;;;;;AAMLqQ;AAQF;;AAOE;;;;;AAMIN;AACF;;AAGE;;AAEF;AACF;AACF;;ACrCA;AAAQhO;AAAoB;AAE5B;AACEC;AACAC;AACAC;AAAc;AACdC;AACE;AACA;;;;AAOJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLO;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;AAE6B0N;;AAC7B;;AAIA;;AAIInQ;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACA;AAEA;AAGA;AACEjD;AACA;AACF;AAEA;AACEgC;AACAsO;;;;;AAKF;AACF;;AC1GO;AAYL;AACEvQ;AAEAC;AACA;AACF;AAEAA;;AAIAA;;AAGEA;AACF;AACAA;AACAA;AACAA;AACAA;AAGAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;;;AAGAA;AACAA;AACAA;AACF;;AC1CO;AAYL;AACA;AACE;AACF;;;;;AAEwDuQ;;;AAGxD;AACA;AACA1M;AAEA;;AAEEyE;AAA0BiD;AAAgB;AAC5C;;;;AAMA;AACA;AACA;AAIA;AAEA;;AAEE;AACEjD;AACAkI;AACF;AACF;;AAGEvQ;AACAY;AACE4P;;;;;;;AAcAC;AACF;;AAEJ;AAEA;AACE;;AAGA;;AAEIzQ;AACAC;;;AAGJ;;AAESD;AAAUY;;AACrB;AAEO;AAGL;AACA;AACE;AACF;;AAEA;AACA;;AAEA;AACA;AACAyH;;AAMSrI;AAAUY;;AACrB;;AClHO;AACL;;AAEF;;ACIA;AAAQkB;AAAoB;AAE5B;AACEC;AACAC;AACAC;AAAc;AACdC;;;AAGA8B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAIA;AACE3C;AACA;AACF;AAEA;AACF;;ACtEA;AAEO;;AAELkC;AAAc;AACd;AAA8BS;AAAW;AACvC;AAEIgO;AACF;;;;;AAMA;AAEJ;AACF;;ACfO;AACL3Q;;AAGA;AAEA;AACEA;;AAEA;AACF;;AAGEA;;AAIA;AACF;;AAIAA;AACAA;AACAA;AACF;;AC/BO;;AAEP;;ACIA;AACEgC;AACAC;AAEAC;AAAc;AACdC;;;;AAIF;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLO;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAGA;AACA;AACAiF;;AAGF;;AC/CO;AAMLgJ;AACAA;AACAA;AACAA;AACF;;ACUA;AAAQC;AAAwB;AAEzB;AAILC;AACAC;AACA;AAEI7Q;;;AAOJ;;AAEEF;AACA;AACF;AAEA;AAKA;;AAEEA;AACA;AACF;AAEAA;AAEA;;AAKIuJ;;AAEF;;AAGF;AACE;AACErJ;AAEA8Q;AACEzH;AACAtC;AACAhF;;AAEJ;AACA;;AAEA;AACF;;;AAIMO;AACF;AAEA;AACA;AACEyO;AACF;AACF;AACF;AAEA;AAGI/Q;AACA8Q;AAEIzH;AACAtC;AACAhF;AAEF;AAEEsH;AACAtC;AACAhF;;;AAMNjC;AACA;;AAEEA;AAGF;AACEA;AAGF;AACF;AAEA;;;AAGEA;;AAIEA;AACAA;AAGF;AACF;;AAEEA;AACF;AACF;;ACpIA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA2O;AACEzO;AACAJ;;AAEF8O;AACE1O;AACAJ;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;AAEA;AACA;AAEA;AACE3C;AACA;AACF;AAEA;AACE;AAGF;AAEA;AACF;;AC9EO;AACL4Q;AACAA;AACAA;AACAA;AACF;;ACFO;;AAEHM;AACAlR;;AAEEA;AACAA;AAGF;AACF;AACEA;AACF;AACF;;ACTA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;;;AAGA8B;AACF;AACA;;AAEA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;AAEA;AACE3C;AACA;AACF;AAEAmR;AACF;;AClCA;AAAQpP;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACAwF;AACEtF;AACAG;AACAP;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;AACwBgF;;;AAExB;;AAEA;AACA;AACAC;AAEA;AACE5H;;;;AAIAA;;AAEF;AAEA;;AAGAoR;AAEA;AACEpR;AACA;AACF;AAEA;AACEA;AAGAA;AACAA;AAGAA;AAGAA;;AAEA;AACF;AAEA;;;;AAIE2H;AACF;;AAKF;;AC3GA;AAAQ5F;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACA;AACAC;AACEC;AACAJ;;AAGFoP;AACEhP;AACAJ;;AAEFqP;AACEjP;AACAJ;;AAEF4F;AACExF;AACAJ;;AAGF0F;AACEtF;AACAJ;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAEQgI;AAAc/H;;;AAChBR;;;;AAAoCuF;;AAC1C;;AAEA;AACA;AACAC;AAEA;;AAEA;AACA;;AAKE5H;AACF;AACA;AACEuR;AACF;;;AAGIvR;AACF;AACEuR;AACF;AACF;AACA;;AAKEvR;AACF;AACA;AACEsR;AACF;;;AAGItR;AACF;AACEsR;AACF;AACF;AACA;;AAKEtR;AACF;AACE2H;AACF;AAEA;AACE3H;;;AAGAA;AACAA;;AAEF;AAEA;AAGI8C;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEAjD;AAIA;AACEA;AACA;AACF;AAEA;;AAEEuR;AACAD;;;AAGF;AACF;;AC/KA;AAAQvP;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACAqG;AACEnG;AACAJ;;AAEFwG;AACEpG;AACAJ;;AAGF0F;AACEtF;AACAJ;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAEQgI;AAAc/H;;;;;AACC+E;;;;AAGvB;AACA;AACAC;AAEA;;;AAOA;;;;AAII5H;AACF;;AAEA;AACF;;;;AAIIA;AACF;AACEyI;AACF;AACF;;;;AAIIzI;AACF;AACE2H;AACF;AACF;AAEA;AACE3H;;;;;AAKF;;AAEA;AACA;AACA;;AAEA;AACE8C;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAEE;AACF;AAEA;;AAEEjD;AACAA;;AAEF;AAEA;AACEA;AACA;AACF;AAEA;AACEwI;;;;AAOF;AACF;;AChKA;AAAQzG;AAAoB;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACEC;AACAC;AAEAC;AACAC;AACE;AACAqG;AACEnG;AACAJ;;AAEFwG;AACEpG;AACAJ;;AAGF0F;AACEtF;AACAJ;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAEQgI;AAAc/H;;;;;AACC+E;;;;AAGvB;AACA;AACAC;AAEA;;;AAOA;;;;AAII5H;AACF;;AAEA;AACF;;;;AAIIA;AACF;AACEyI;AACF;AACF;;;;AAIIzI;AACF;AACE2H;AACF;AACF;AAEA;AACE3H;;;;;AAKF;;AAEA;AACA;AACA;;AAEA;AACE8C;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAEE;AACF;AAEA;;AAEEjD;AACAA;;AAEF;AAEA;AACEA;AACA;AACF;AAEA;AACEwI;;;;AAOF;AACF;;ACrKA;AAAQzG;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACAqG;AACEnG;AACAJ;;AAEFqP;AACEjP;AACAJ;;AAGF4F;AACExF;AACAJ;;AAEFsG;AACElG;AACAJ;;AAEF0F;AACEtF;AACAJ;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAEQgI;AAAc/H;;;;;;;AACW+E;;;;AAGjC;AACA;AACAC;AAEA;;;AAOA;;;;AAII5H;AACF;AACEwI;AACF;AACF;AACA;;AAKExI;AACF;AACA;AACEsR;AACF;;;AAGItR;AACF;AACEsR;AACF;AACF;;;;AAIItR;AACF;AACEuI;AACF;AACF;AACA;;AAKEvI;AACF;AACE2H;AACF;AAEA;AACE3H;;;;;AAKF;;AAEA;AACA;AACA;;AAEA;AACE8C;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAEE;AACF;AAEA;;AAEEjD;AACAA;AACAA;;AAEF;AAEA;AACEA;AACA;AACF;AAEA;AACEwI;AACAZ;AACA0J;;;AAMF;AACF;;AC3MO;AACL;AACEvR;AACF;AAEA;AACEC;AACA;AACF;AAEAA;AACF;;ACJO;;AAKLoR;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACEpR;AACF;AACEA;AACF;AAEAA;AACAA;AAGAA;AACAA;AACAA;AACAA;AAGAA;AACAA;AACAA;AACAA;;;AAKIiH;AACAhF;AACF;;AAGEgF;AACAhF;AACF;;AAGEgF;AACAhF;AACF;;AAGEgF;AACAhF;AACF;;AAGEgF;AACAhF;AACF;AAGF+O;AACE;;AAEA;AACF;;AAEA;AACAA;AACE;AAIE;AACF;AACA;AAIE;AACF;;AAEF;;AAEA;;AAEEzH;AACAtC;AACAhF;AACF;;AAEA;AACA;AACE/B;AACA8Q;AACF;;AAGA;AACE;AACF;AACA;AAEA;AACE3J;AACF;AACA;AACEA;AACF;AAEA;AACA;AACE;AAAc;;;AAGZ;;AAEA;AACF;AACA;AAAe;;;AAGb;;AAEA;AACF;AACA;AAAY;;;AAGV;;AAEA;AACF;AACA;AAAS;;AAET;AACF;;AAGE;AACF;AAEArH;AACAA;AACAA;;;AAKIgR;AAEIzH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;;AAGN;AAEA;AACF;;AAGF;AAEA;;;;;;AAUE;;AAEA;;;;;;AAOA;;AAEE;AACEyH;AACF;;AAEA;AACF;;;;AAKA;;AAEA;;AAEA;;AAEA;AAEA;;;;AAIE;;AAEA;;AAEE;AACEA;AACF;;AAEA;AACF;AACF;;;;;AAMEA;AACF;;AAEA;;AAGF;AAEA;;;;AAQE;AACEA;AACF;;AAEA;AAEA;AACExJ;AACAsC;AACAgP;AACA;AACF;;;AAGA;AACE9H;AACF;;AAEA;;;;;AAMEA;AACF;;AAEA;;AAGF;AAEA;;;;AAQE;AACEA;AACF;;AAEA;AAEA;AACExJ;AACAsC;AACAgP;AACA;AACF;;;AAGA;AACE9H;AACF;;AAEA;;;;AAKA;;AAEA;;AAEA;;AAEA;AAEA;;;;AAIE;;AAEA;;AAEE;AACEA;AACF;;AAEA;AACF;AACF;;;;;AAMEA;AACF;;AAEA;;AAGF;AAEA;;AAIIxJ;AACA8Q;AAEIzH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;AACF;AAEFO;AACF;AACF;AAEA;;AAIItC;AAEA8Q;AAEIzH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;AAEF;AAEEsH;AACAtC;AACAhF;AACF;AAEFO;AAMF;AACF;AAEA;;;AAKIA;AACAgP;AACA;AACF;AACF;AAEA;;;AAKIhP;AACAgP;AACA;AACF;AACF;AAEA;;;AAKIhP;AACAgP;AACA;AACF;AACF;AAEA;;AAIItR;AACA8Q;AAEIzH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;AACF;AAEFO;AACF;AACF;AAEA;AACExC;AACAA;AACAA;;AACSC;AAAUY;AAAQ4Q;AAAe;;AAC5C;AAEA;;AACWxR;AAAUY;AAAQ4Q;AAAgB;;AAC7C;;ACleO;;;AAOP;;ACEA;AAAQ1P;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACAuP;AACErP;AACAJ;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AACQ+O;;;AAER;AACA;AACA9J;AAEA;AACE5H;AACA;AACF;;AAGF;;AC5EA;AACEgC;AACAC;AACAC;AACAC;;;AA+BK;;;AAGLO;AACF;AAEA;AAGIC;AAAmC;AAErC;AAEIiH;AACAtC;AACAE;AACAC;AACAkK;AACAC;AACAC;AACF;;AAGEC;AACEC;;AAEE7P;;AAEF;;;;;AAKFqH;AACF;AAEJ;;AC1EA,iBAAA;AAEA;AAAQxH;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;;;AAGA8B;AACF;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;AAGnCsC;;;AAIAtC;AACF;AAEA;AACE3C;AACA;AACF;;AAEA;AACA;AACA;AACF;;AC5CA,iBAAA;AAEA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;;;AAGA8B;AACF;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;AAGnCsC;;;AAIAtC;AACF;AAEA;AACE3C;AACA;AACF;;AAEA;AACA;AACA;AACF;;AC5CA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA6P;AACE3P;AACAG;AACAP;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;AAEwBqP;;AAExB;AACEhS;AACA;AACF;AAEA;;AAEEA;AAEIC;AACAC;AACAC;AACF;AAEJ;AAEA;;;AAKE;AACF;AAEA;AACF;;ACzEA;;;;;;AAAyC8R;AAAa;AAEtD;AACE;AACF;AAEA;AACE;AACF;AAEO;;ACdA;;;;;AAKH3D;AACF;AACA;AAGqBnK;;;AAIGA;;;AAICA;;;AAKfA;;AAAyC;AAGvC;;AACd;;ACxBA;;;;;;;;AAQE8N;AACF;AAEA;AACE;;AAGS5P;AAAkB6P;;AAC7B;;AAEA;AACA;AACA;AACE;;AAES7P;AAAW6P;;AACtB;;AAEA;AACA;AACA;AACE;;AAGS7P;AAAY6P;;AACvB;AAEA;AACE;;AAES7P;AAAW6P;;AACtB;;AAEA;AACA;AACA;AACE;;AAGS7P;AAAkB6P;;AAC7B;;AAEA;AACA;AACA;AACE;;AAGS7P;AAAoB6P;;AAC/B;AAMO;;ACxDP;;;;;;;AAAmDD;AAAa;AAEhE;AACE;AACA;AACA;AACF;AAEA;AACE;AACA;AACA;AACA;;AAIA;AACF;AAEA;AACE;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;;AAIJ;AAEA;AACE;AACA;AACA;AACF;AAEA;AACE;AACA;AACE;AACA;AACA;AACA;AACA;;AAIJ;AAEO;;AC3DP;;;;;;AAAyCA;AAAa;AAEtD;;AAEI;AACF;AACA;;AAEEE;;AAEF;AACE;AACF;AACA;AACA;;;AAAwBC;;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEEC;AACF;AACF;AACA;AACF;AAEA;;AAEI;AACF;AACA;AACA;AACA;;AAEA;AACF;AAEA;;;AAGIxK;;AAGI;;AAEF;;;AAIN;AAEA;;AAEI;AACA;AACA;;AAGI;;AAEF;;AAGJ;AACF;AAEA;;AAEA;AAEA;AAKE;AACA;;AAEE;AACE;AACF;AACF;;;AAGEA;AAGI;AACA;;;AAIE;;AAEF;;;AAKR;AAEA;;;AAGI;AACAA;;AAMM;;AAEF;;;AAKR;AAEA;;AAKI;AACE;AACA;AACA;;AAMM;;AAEF;AAEW;;AAGnB;AACF;AAEA;;AAKI;AACA;AACA;AACA;AACA;;AAGI;;AAEF;;AAGJ;AACF;AAUO;;ACrLA;;ACQP;;;;;;;;AAQEoK;AACF;AAEA;AASA;AAIE;AAIF;AAEA;;AAKA;AAEA;AAIE;AACF;AAEA;AAKE;AACA;AACE;;AAEE;AACA;;AAEI;AACE;AACAC;;;AAGA;AACF;AACF;AACF;AACE;AACApD;AAGQ;AACE;AACAoD;AACF;AACF;AACE;AAAmB;AAE7B;;AAEA;;;AAGA;AACF;;AAC2B;AAAe;AAC1C;AACA;AACF;AACA;AAIE;AACF;AACA;AACA;AACA;;;;;;AAME;AACEI;;AAEF;AACF;AACEA;AACAC;AACF;;AAEE;AACED;AACAC;AACF;AACF;AACA;;AAEA;AACA;AACED;AACAC;AACF;AACA;;;AAGEA;AACF;AACAC;AAEqB;;;AAKvB;AAEA;;AAEA;AAEA;;AAKA;AAEA;;AAEA;AAOO;;ACvHP;;;AAAmBP;AAAa;AAEhC;AAEO;;;;;;AAUHxE;AACF;;;;;;AAME9B;AACE8G;AACAC;AACAC;AACAC;AACAC;AACF;AACF;AAAM1O;;;;AAEN;AACA;AACA;AACA;AACA;AAGE;AACA2O;;AAIA9S;AAMF;;;AAIE+S;AACF;;AAKA;AAEApN;AAEA;AACA;AAEA;AAAuD;;AAEnD;AACA;AACAqN;;AAKJ;AACA;AAAyC;AAAQ;;AACvCzJ;AAAsB0J;AAAsBhN;AAAQ;AAC5D;AACA;AACA;AACA;AAAa;;AACX;AAGA;AACEiN;AACF;AACA;AAGA;;AAEE;AACA;AACA;AACA;AACE;AACA;AAEE;AACA;AACAF;AAIFG;AACAC;AACAzH;;AAEEA;AACF;AACF;AACAuH;AACF;AACF;AACA;AACE;AACA;AACA;AACA;AACA;AAKA;AAE0DJ;AAAY;AACtE;AACA;;AAAyDzQ;AAAK;AAC5D;;;AAME;AACA;AACA;;AAEA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACAgR;AACF;AACE;AAGA;;AAIM;AACA;AACA;AACA;AACA;AACAL;;AAMF;AACEK;AACF;AACF;AACF;AACEA;AACF;AACF;;AAEEnB;AACA;AACAvG;AACF;AACF;AACF;AACF;AACF;AAEA;AACE;;AAEE;;;;AAOIhG;AACF;AAEF;AAcE;AACEgG;AACF;AACF;AACF;AACF;AAEA;;AAIE;AACE;;AAAwBtJ;;AACtBiR;AAIF;AACF;AACA;AACF;AAEA;AACF;;AC9QA;AAAQC;AAAoC;AAQrC;;AAKHpE;;AAEAxJ;AACF;AACExB;;;AAGF;;;AAGA;;;;AAGyCwB;AAAQ;AAC/C;;;AAKA;;;AAIA9B;;AAGE5D;AACAC;AACAC;;AAKJ;AACA;;AAEA;;AAEA;;AAESF;AAAUY;;AACrB;;ACtDA;AAAQ2S;AAAI;AAEL;AAaL;AACErE;;AAEAsE;AACF;AAEA;AACE;AACF;AACA;AAEA;;AAEIxT;AACAC;AACAC;;AAKJ;;AAEA;;AACQwF;AAAQ;AAEhBA;;;;;AAMEA;AACF;AAEA;AACA;;AAGA;AACE;AACEwJ;;AAEAxJ;AACF;AACA;AACE;AACF;AACF;;;AAKE1F;AACAY;;;;AAIE+R;AACAF;AACF;;AAEJ;;AC/EO;AAUL;AACE3S;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEA;AAEA;;AAIA;AACA;AACEA;AAGF;AACA;AACEA;AACF;AAEAA;AACAA;AACAA;AACF;AAEA;;AAMA;;ACrDO;;;;AAILyT;AAMF;;AAGE;AACF;;ACNA;AAAQ1R;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACAuR;AACErR;AACAG;AACAP;;AAEFwR;AACEpR;AACAG;AACAP;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;;;AACD6Q;;AACb;;AAEA;AACA;AACA7L;AAEA;AACE5H;AACA;AACF;AAEA;;AAEE0T;;;AAGF;AACF;;AC5EO;AAGL;AACA;AACE;AACF;AACA;;AAMF;;ACVO;AAIL;AACE3T;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACAA;AACAA;AACAA;AACAA;AACA;;;;AAOAA;AACAA;AACF;;ACnCO;AAIL;AAEA;AACF;;ACGA;AAAQ+B;AAAoB;;AAE5B;AACA;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA6B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;AAOA;AAEA;AAGIZ;;AAEA5C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACF;;ACtHO;AAGL;AACA;AACE;AACF;AACA;;AAMF;;ACVO;AAIL;AACED;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACAA;;AAIAA;AACAA;AAGAA;AACA;;;;AASAA;AACAA;AACF;;AC1CO;AAIL;AAEA;AACF;;ACGA;AAAQ+B;AAAoB;;AAE5B;AACA;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA6B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;AAOA;AAEA;AAGIZ;;AAEA5C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACF;;ACpHO;AAGL;AACA;AACE;AACF;AACA;;AAGF;;ACLO;AAIL;AACED;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGA;AAEA;AACE;AAAiB;AACf;AACA;AACA;AACA;;;;AAIA;AACE2T;AACAC;AACAC;AACF;AACA7T;;AAIAA;;AAMA;;AAIA;;AAIA;AACF;AACA;AAAS;;AAIP;AACA;AACEA;AAGF;AACF;AACF;AACF;;ACxEO;AAGL;AAEA;AACF;;ACEA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF8B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;AAEA;AAEA;AAGIE;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAGF;;AClFA;AAEO;;AAEL;AACA;AACA;AACA;AACAkC;AACA;AAA8BS;AAAW;AACvC;AAEImR;AACAC;AACF;;;AAIEC;AAAoB;;;AAGtB;AAEJ;AACF;;ACxBO;AAGL;AACA;AACE;AACF;AACA;;AAGF;;ACRO;AAIL;AACEjU;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACAA;;AAEAA;AACA;AACF;;AAGAA;AACF;;AC9BO;AAGL;AAEA;AACF;;ACEA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF8B;AACF;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAIA;AAEA;AAEA;AAGIG;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAGF;;AC3EA;AAEO;;AAELkC;AACA;AAA8BS;AAAW;AACvC;AAEImH;AACAmK;AACA1N;AACF;AAEEuL;AACEiC;;AAEE7R;AACAgD;;AAEF4O;;AAEE5R;AACAgD;AACF;;;;AAIF8O;AAAoB;;;AAGtB;AAEJ;AACF;;ACaO;AAGLhU;;AAMF;;ACvDO;AAKL;AACED;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGE;AACAA;AACAA;AACA;AACF;AAEAA;AAGAA;AACAA;AACF;AAEO;;AAEHkU;AACEhO;AACAiO;;AAEAC;;AAEFC;;;;;;AAMED;AACF;AACF;;AAIA/L;AACAA;AACA;;AAIA;AACEA;AAGF;AACAA;AACA;AACEA;AAGF;AACEA;AAGAA;AACAA;AAGF;AACAA;AACA;AACE;AACAA;AAGAA;AACAA;AACAA;AACAA;AAGF;AACEA;AACAA;AACAA;AAGF;AACAA;AACAA;AACAA;AACAA;AACAA;;;;;;;AAOAA;AACAA;AACAA;;AAEEA;AACAA;AACAiM;AACEjM;AACF;AACF;AACEA;AACF;AACAA;AACAA;AACAA;;AAEE;AACEA;AACF;AACEA;AACF;AACAA;AACAA;AAGF;AACEA;AACF;AACAA;AACA;AACEA;AACAA;AACAA;AAGAA;AACAA;AACAA;AACAA;AAGAA;AAGAA;;;;;;;AAOAA;AACAA;AACAA;AACAA;AAGAA;;;;;;;AAOAA;AACAA;AACAA;;AAEEA;AACAA;AACA8L;AACE9L;AACF;AACF;AACEA;AAGF;AACAA;AACAA;AACAA;;AAEEA;AACAA;;AASF;AACEA;AAGF;AACAA;AAEA;AACF;AACF;;ACpNO;AAIL;AAEA;AACF;;ACZA;AACA;AACA;AACA;AACO;;;;AAOHkM;;AAEA;AACE;;AAEEA;AACA;;AAEA;AACA7E;AACF;;AAEA;AACF;AACA;AACE6E;AACF;AACF;AACE;AACApC;AAEA;AACE;AACA;AACE;AACAoC;AACA;;AAEA7E;AACF;AACEA;AACF;AACF;AAEA;AACE6E;AACF;AACF;;;AAEgBA;;AAClB;;ACrCA;AAAQxS;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;;;AAGF8B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;AAIA;;;AAEe2R;AAAM;AAErB;AAGIxR;AACA7C;AACA8C;AACAC;AACF;AAEEF;AACA7C;AACA8C;;AAEF;AAEEF;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAGF;;ACtHO;AAGLA;AAIA;AACA;AACE;AACF;AACA;;AAKMkG;AACF;AACEsO;AAAiC3F;AAAK;;AAK5C;AACE;AACF;;AAEA;;AAEE5O;;;AAGJ;;AC9BA;;AAsBO;AAKL;AACEF;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;;AAEiBI;;;AAGf;AACAJ;AACA;AACF;AAEA;AACAA;AACF;AAEA;AACE;AACE;AACAgQ;AACAC;AACAC;AACAuE;;;AAGF;AACEC;AACF;;AAGA;AAUF;AAEA;AACE;AACA;AACE;AACF;;AAEE;AACF;;AAEE;AACF;AACA;AACF;AAEA;AAIE;;AAEA;;;;;;AAaA;AACA;AACA;AAEA;;AAaA;AACA;AAsBF;AAEO;AAIL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACAC;AACEjF;AAGAA;AACAA;;AAIF;AACA;AACA;AACE;AACE;AACF;;AAKE;AACF;AACA;AACF;;AAEA;AACA;AACA;AACA;AACA;AACAiF;AACE;AACA;AACE;;AAEE;AACA;AACF;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AAEAC;;AAAsCvS;AAAK;;;;AAIzC;AACF;AACF;AACE;AACAuS;;AAAsCvS;AAAK;;;;AAIzC;AACF;AAEAjC;;AAEEyU;;AAEA5O;AACAmO;AACEU;AACAC;AACAC;AACAC;AACAlB;;AAEF7N;AACF;AACF;AACF;;;AAEegP;;AACjB;AAEO;;AAKL;AACAP;;AAEE;AACE;AACF;AACAQ;AACAC;AACF;;AAGF;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AAEO;;AAML/M;AACAA;;;AASA;AAEA;AACAsM;AACE;AACA;AACE;AACF;AACAQ;AACA9M;AACAA;AACF;AACAA;AAEA;AACF;;AC/TO;;AAELqH;AAIF;AACE;AAEA2F;AAKF;;ACPA;AAAQtT;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;;;AAGF8B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEO;;;AAGLW;AACE0Q;;AAEEpT;AACAgD;AACF;;AAEFxC;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;;;AAIe2R;AAAM;AAErB;AAGIxR;AACA7C;AAEA8C;AACAC;AACF;AAEEF;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;AAEE0P;AACF;AACF;;ACxHA;AAEO;;AAELxN;AACA;AAA8BS;AAAW;AACvC;AAEIyR;AACAmB;AACF;AAEEzD;AACE0D;;AAEEtT;;AAEF;;;;;;AAMJ;AAEJ;AACF;;AC3BO;;AAIH;;AAEA4I;AACF;AACA;;AAEE;;AAEA;AACE;AACA/K;AACF;AACF;AACA;AACF;;ACfA;;AAA6B4P;AAAI;AAEjC;AACE3N;;AAEAE;;;AAGF;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLQ;AACF;AAEA;AAGIC;AAAmC;;AAGnCsC;;;AAIAtC;AACF;AAEA;AACE3C;AACA;AACF;;AAGF;;AC5CO;;AAIH;;AAEA8K;AACF;AACA;;AAEE;;AAEA;AACE;AACA/K;AACF;AACF;AACA;AACF;;ACfA;;AAA6B0V;AAAI;AAEjC;AACEzT;;AAEAE;;;AAGF;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLQ;AACF;AAEA;AAGIC;AAAmC;;AAGnCsC;;;AAIAtC;AACF;AAEA;AACE3C;AACA;AACF;;AAGF;;AC1CA;AACEgC;AACAC;AACAC;AACAC;AACE;;;;AAIJ;AACA;AACA;AACA;AAEO;;;AAGLO;AACF;AAEA;AAGIC;AAAmC;AAErC+S;;;;AAIE/S;AACF;AAEA3C;;AAKF;;ACrCA;AACEgC;AACAC;AACAC;AACAC;AACE;;;;AAIJ;AACA;AACA;AACA;AAEO;;;AAGLO;AACF;AAEA;AAGIC;AAAmC;AAErC+S;;;;AAIE/S;AACF;AAEA3C;;AAKF;;ACtCA;AAEO;;AAELkC;AAAc;AACd;AAA8BS;AAAW;AACvC;AAEIgT;AACAC;AACF;;;;;AAMA;AAEJ;AACF;;ACnBO;;;;;;AAMLC;AAQF;AACE;AACA;AACE;AACF;AACA;;AAIItM;;;;AAIAsM;;AAIN;;AC7BO;AAKL;AACE9V;AACF;;AAEEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AACQsJ;;AACRtJ;AAGF;;ACvBO;;;;;;AAOH6V;AAQF;AAGA;;;;;;AAMEA;AACF;AACAC;AACF;;ACjBA;AAAQ/T;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA4G;AACE1G;AACAC;AACAE;AACAP;;AAEF8T;AACE1T;AACAC;AACAE;AACAP;;AAEF+B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGF+T;AACE3T;AACAC;AACAE;AACAP;;AAEFY;AACER;AACAC;AACAE;AACAP;;AAEF4T;AACExT;AACAC;AACAE;AACAP;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAOEe;AACAb;;;;AAIF;AAOA;AAEA;AAEA;AAGIC;;AAEA5C;AAGA8C;AACAC;AACF;;AAGE/C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;AAGI6C;;;;;;AAQN;;AC1KO;AAIL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACZO;AAKL;AACE9C;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACF;;ACtBO;;AAOL;AACF;;ACEA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA6B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;;AAUA;AAEA;AAGIZ;;AAEA5C;AAGA8C;AACAC;AACF;;AAGE/C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACF;;ACnHO;;;AAGLiW;AAKF;AACE;AACA;AACE;AACF;AACA;;;;;AAME;;AAEIhW;AACAC;;;AAGJ;AACA;;;;AAKIwM;AAAuB;;;AAK3B;AACE7I;AACA;AACF;AAEA/B;;AAEF;;AAGE7B;AACAY;AACEqV;AACAvS;AACF;;AAEJ;;ACtDO;;;;;AAKLsS;AAOF;AACE;AACA;AACE;AACF;AACA;;;;AAMIvJ;;;AAKN;;AClCA;AAYO;AASL;AACE3M;AACF;;;AAIIC;AAEIC;AACAY;;;;;;AAMEoV;AACF;AACF;AAEJ;AACEjW;AACF;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AAIA;AACEkK;AACIC;AAAaZ;AAA2B;AACxCY;AAAeZ;AAA6B;AAC5CY;AAAqBZ;AAAmC;AACxDY;AAAyBZ;AAAuC;AAChEY;AAAmBZ;;;AAIzBvJ;AACA;;AAIEA;AACF;AACEA;AACF;AACEA;AAGF;AACF;;ACvEO;;;;;;;AAOLiW;AASF;AACE;AACE;;;AAA2DA;AAAK;AAEhE;AACF;AACE;;;;;AAKEA;AACF;AAEA;AACE;AACF;AACE;AACA;AASF;AACF;AACF;;ACpCA;AAAQlU;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAgU;AACE9T;AACAG;AACAP;;AAGFmU;AACE/T;AACAG;AACAP;;AAEF+B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFkB;AACEd;AACAC;AACAE;AACAP;;AAEFqB;AACEjB;AACAC;AACAE;AACAP;;AAEFgU;AACE5T;AACAC;AACAE;AACAP;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAIEyT;;;;;AAKA1S;;AAEF;AAEA;AAOA;AAEA;AAGIZ;;AAEA5C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACEmW;AACAC;;;;;;AAMF;AACF;;ACtKO;;;;;;AAMLP;AAQF;AACE;AACA;AACE;AACF;AACA;;;AAKItM;;;;AAIAsM;;AAIN;;AC9BO;AAKL;AACE9V;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACF;;ACtBO;;;;;;AAOH6V;AAQF;AAGA;;;;;;AAMEA;AACF;AAEA;AACF;;AClBA;AAAQ9T;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA4G;AACE1G;AACAC;AACAE;AACAP;;AAEF8T;AACE1T;AACAC;AACAE;AACAP;;AAEF+B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFY;AACER;AACAC;AACAE;AACAP;;AAEF+T;AACE3T;AACAC;AACAE;AACAP;;AAEF4T;AACExT;AACAC;AACAE;AACAP;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;;;AAG7C;AAOA;AACA;AAEA;AAEA;AAGIZ;;AAEA5C;AAGA8C;AACAC;AACF;;AAGE/C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;AAGI6C;;;;;;AAQN;;ACpKO;AAIL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACpBA;AAYO;AAIL;AACE9C;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEA;AACEkK;AACIC;AAAaZ;AAA2B;AACxCY;AAAeZ;AAA6B;AAC5CY;AAAqBZ;AAAmC;AACxDY;AAAyBZ;AAAuC;AAChEY;AAAmBZ;AAAiC;AACpDY;AAAmBZ;AAAiC;AACpDY;AAAqBZ;;;AAI3BvJ;AACF;;ACrCO;;AAOL;AACF;;ACEA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA6B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFY;AACEZ;AACAO;AACAH;AACF;;AAEF4B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAOEe;AACAb;;AAEF;AAEA;AAOA;AAEA;AAEA;AAGIC;;AAEA5C;AAGA8C;AACAC;AACF;;AAGE/C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAGF;;AC5IA;AAEO;;AAEL;AAA8B2C;AAAW;AACvC;AAEIgT;AACAC;AACA9L;AACAuM;AACAC;AACF;;;;;AAMA;AAEJ;AACF;;AC5BO;AACL;AACA;AACA;AACEpW;AACA8Q;AAEIzH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;;AAIN;AACA;;AAEA;AACF;;ACHA;AAAQF;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAkH;AACEhH;AACAJ;;AAGFoD;AACEhD;AACAC;AACAL;;AAEF4G;AACExG;AACAC;AACAE;AACAP;;AAEF6G;AACEzG;AACAC;AACAE;AACAP;;AAEFuD;AACEnD;AACAC;AACAE;AACAP;;AAEF2F;AACEvF;AACAJ;;AAEF8G;AACE1G;AACAG;AACAP;;AAGF+B;AACE3B;AACAG;AACAP;;AAGFiH;AACE7G;AACAC;AACAL;;AAEFyB;AACErB;AACAJ;;AAGFkH;AACE9G;AACAG;AACAP;;AAGFM;AACEF;AACAC;AACAL;;AAEFmH;AACE/G;AACAJ;;AAGFsU;AACElU;AACAG;;AAEAP;;AAGFyG;AACErG;AACAC;AACAE;AACAP;AAEF;;AAEF;AACAgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;AAMEiF;;AAEA4O;AACAxS;;;AAGAN;;;AAGA6S;AACA7N;;;;AAmBArD;AACA9C;AACA6G;;AAOF;AAEA;AAEA;;AAOE;AACAqN;AACF;;AAEA;;AAIA;AAKA;;AAEA;AACA;;;AAGIzW;AAIF;AACEqJ;AACF;AACF;;;;AAIIrJ;AACF;AACE2I;AACF;AACF;;;;AAII3I;AACF;AACE6C;AACF;AACF;AACA;;;AAGI7C;AACF;AACEoJ;AACF;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAIE;;AAEAsN;AACF;;AAEA;AACA;AACA;AACA;;AAEI;AACA;AACErM;AACF;AACAqM;AACF;AACF;;;;AAOA;AAEA;AACE1W;AAGAA;AACAA;AAGAA;AACF;AAEA;;AAII+C;AACA7C;AAGA8C;AACAC;AAIF;AAEEF;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;;AAEA;AACA;AACEjD;AACA;AACF;AAEA;AACEqJ;AACAV;;;;;AAKAI;AACA/E;;;AAGAiF;AACAC;AACAC;AACAtG;;;;AAIF;AACF;;ACpZO;AAIL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACZO;AAIL;AACE9C;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACF;;ACrBO;;AAOL;AACF;;ACEA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA6B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;;AASA;AAEA;;AAIIX;AACA7C;AAGA8C;AACAC;AAIF;;AAGE/C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACF;;ACpHO;;;AAGLqK;AAKF;AACErK;AACAA;AACAA;AAEA;AAIF;;ACVA;AAAQ+D;AAAmB;AAE3B;AAEO;;;AAKHiF;AAKF;AAEA;AACEjJ;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;AAEA;AACA;;AAIA;AACA;AACA;AACA;AACE;AACA;AACF;;AAGE;AACA;AACF;;AAEA;AACA;;AAEAA;;AAGIsK;AACAtD;AACAuD;AACAC;AACF;AAEFxK;AAGAA;AACF;AAEA;AAKE;AAEA;AACEA;;AAEE;AACEA;AACAA;AACF;AACEA;AACF;AACAA;AACF;AACF;AACE;AACAA;AACAA;AACAA;AACF;AACF;AAEA;AAGEA;AACAA;AACAA;AACAA;AAGAA;AACAA;;AAIAA;AACAA;AACAA;;AAEAA;;AAEEa;AACEb;AACF;;AAEEA;AACF;AACF;AACAA;;AAEEa;AACEb;AACF;;AAEEA;AACF;AACF;AACAA;;AAEEa;AACEb;AACF;;AAEEA;AACF;AACF;AACAA;;AAEEa;AACEb;AACF;;AAEEA;AACF;AACF;AACAA;;AAEEa;AACEb;AACF;;AAEEA;AACF;AACF;AACAA;;AAEAA;AACAA;AAGAA;AACA;AACE;AACE;AACF;AACA;;;AAKA;AACF;AACAA;;AAEAA;AACAA;AACAA;AACA;AACE;AACE;AACF;AACA;;;AAKA;AACF;AACAA;AACF;;ACtMO;;;;;;AAMLgJ;AAQF;AACE;;;AAGEqB;AACF;;;;AAKErB;AACF;AACF;;AChBA;;AAA6BjF;AAAmB;AAEhD;AAEA;AAAQoB;AAAsC;AAE9C;AACEnD;AACAC;AACAC;AACAC;AACE;AACA;AACA6E;AACE3E;AACAG;AACAP;;AAGFG;AACEC;AACAC;AACAE;AACAP;;AAGF+B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;;;AASEe;;AAEF;AAEA;AAOA;AACA;AACA;AACEiT;AACF;AACA;AACEC;AACF;AAEA;AAEA;AAGI7T;AACA7C;AAEA8C;AACAC;AAMF;;AAGEH;AACA5C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACE2W;AACAC;AACA5P;;;AAGA5E;AACF;AACF;;ACvKA;AACA;AACA;AACA;AAkCO;;;;;;;;AAQLyU;AAUF;;AAME;AACE;AACA;AACET;;AAEAH;AACF;AACA;AACE;AACF;AACAa;AACF;AAEAA;;AAGA9W;;;AAIIC;AACAC;AACAC;;AAGJ;;AAEA;AACA;AACE;AACA;AACE;AACF;;AAEF;;AAEA;AACA;AACA;;AAEE;AACE;AACF;AACF;;AAGA;AACE;AACA;;;;;;AAME0W;AACF;;AAEEE;AACF;AACF;;AAGA/W;;AAGEC;AACAY;;AAEJ;AAEA;;;;;;AAQIgW;AAQF;;;AAMA;;;;;;;AASA7W;AACA;AACF;AAEA;;;;;AAOIgJ;AAQF;AAEA;;;;AAIEgO;AACF;AACA;AACE;AACF;;;AACuBC;;AAEvBjX;AAEA;;;;;AAKEiX;AACF;AACA;AACE;AACF;AACA;AAEA;AACEjX;;AAGSC;AAAUY;AAAQqW;AAAmB;;AAChD;AAEA;AACArT;AAEA;;;;;;;AAOEmT;AACF;AACA;AACE;AACF;AAEA;;;;;AAKEA;AACF;AACA;AACE;AACF;;;;AAE0CG;;;AAE1C;AACA;;AAEA;AACE9N;AACAV;AACAG;;;AAGAlB;AACAmB;AACA/E;;;AAGAiF;AACAC;AACAC;AACAtG;AACAuG;;AAEAV;AACF;;AAESzI;AAAUY;AAAQqW;AAAkB;;AAC/C;AAEA;;;;;;;AAOEE;AASF;AACEpX;;;AAOA;AACA;AACE;AACA;;;;;AAKEgX;AACF;;AAEE;AACEK;AACF;AACF;AACEC;AACF;AACF;;;;AAKE;AACEtX;AAGA;AACF;;AAEEC;AACAC;AACAC;;AAEJ;;AAESF;AAAUY;;AACrB;AAEA;;;;;AAKEuW;AAOF;AACEvT;AAEA;;AAEE;;AACS5D;AAAUY;AAAQ0W;AAAkB;;AAC/C;AAEA1T;AAEA;;;;;AAKEmT;AACF;;AAEqB/W;AAAUY;AAAQ0W;AAAiB;AAAE;AAC5D;AAEA;;;;;AAKEH;AAOF;;;AAIEvT;AAEA;AACE2T;AACApM;;AAEA;AACF;;AAGA;AACAvH;AAEA;;;AAGA;AACE7D;;AAKEC;AACAC;;;AAGJ;;;;AAKA;;AAEA;AACE;AACAF;AAGA;AACF;;;AAISC;AAAUY;;AACrB;;AAEA;AACA;AAIE;;;AAGE4W;AAEA;AACE;AACAzX;;AACSC;AAAWC;AAA4BC;;AAClD;AAEA;AACEH;;AAIEC;AACAC;AACAC;;AAEJ;;AAEA;AACA;AACA;AACA;AACEmI;AAAoBiD;AAAgB;AACtC;AAEA;;AAEA;;AAEA;AACA;AACA;;AACStL;AAAUY;;;AAEnBb;;;;AAOA;AACA;AACE;AACA;AACAsI;AACE;;AAIA;AACF;AACF;AACA;;;AAGE;AACAoP;AACF;AACA;AACE;;AAEF;;;AAESzX;AAAWC;AAA4BC;;AAClD;AACF;AAEA;;;;;AAKEwX;AAOF;;AAWE;AACA9T;AAEA;AACEuH;;AAEA;AACF;AAEA;AACAvH;AAEA;;;AAGA;AACE7D;AACAA;;AAEEC;AACAC;;;AAGJ;AAEA;AACA;AAGA;;;AAIID;AACAC;AACAC;;AAEJ;;;AAIIF;AACAC;AACAC;;AAEJ;;AAESF;AAAUY;;;AAAsC+W;AAAkB;;AAC7E;AAEA;AACE;AACE1X;AACA8Q;AAEIzH;AACAtC;;AAEF;AAEEsC;AACAtC;AACAhF;;AAEN;;;AAGIhC;AACAC;AACAC;;AAEJ;;AACSF;;;AACX;AAEA;;;AAIMuC;;;AAIAvC;AACAC;AACAC;;AAEJ;;AACSF;AAAUY;;AACrB;AAEA;;;;AAIE8W;AAMF;;AAIE9T;AAEA;AACE2T;AACApM;;AAEA;AACF;AACApL;AAEA;AACA6D;AAEA;;AAEEgU;AACF;AACE7X;AACAA;;AAEEC;AACAC;;;AAGJ;AAEA;;;AAGID;AACAC;;;AAGJ;;AAESD;AAAUY;;;AAAoCoW;AAAW;;AACpE;AAEA;;;;;AAKEU;AAOF;;AAKE;AACA9T;AAEA;AACE2T;AACApM;;AAEA;AACF;AAEA;AACAvH;AAEA;;AAEEiU;AACF;AACE9X;AAGAA;;AAEEC;AACAC;;;AAGJ;;AAGE;AACEF;;AAGSC;AAAUY;;AACrB;;;AAIEZ;AACAC;AACAC;;AAEJ;AAEA;AACE0D;;AAGE5D;AACAC;;AAEJ;;;AAMSD;AAAUY;;AACrB;;AChvBO;;;;;;;;AAQLgW;AAUF;AACE;AACEV;;;AAGAnS;;;;AAIA6S;AACF;;AAGE7W;AACA;AACF;AAEA;AACEA;AACA;AACF;AAEAA;AACAA;AACF;;AC/BA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AAAc;AACdC;AACE;AACA;AACAgU;AACE9T;AACAJ;;AAGF+U;AACE3U;AACAJ;;AAGF8V;AACE1V;AACAJ;;AAGF+B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGF+V;AACE3V;AACAJ;;AAGF4U;AACExU;AACAJ;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAGE6T;AACA;AACAQ;AACAhT;;;AAGAN;;;;;;AAUkCmT;;AAMpC;;AAEA;AACA;AACAjP;AAEA;;AAOE;AACA6O;AACF;AAEA;;;;AAKE;AACEN;AACF;AACF;;;;AAIE;AACE4B;AACF;AACF;;;;AAIE;AACE;AACAC;AACF;AACF;AACA;;;AAGE;AACEnB;AACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEI;AACA;AACExM;AACF;AACF;AACF;AAEA;;AAIItH;AACA7C;AAGA8C;AACAC;AAIF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEF;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;;AAEA;AACA;AACEjD;AACA;AACF;AAEA;AACEmW;;;AAGAnS;;;;AAIA6S;AACF;AACF;;AC5PO;;;;;;;;AAQLZ;AAUF;AACE;AACA;AACE;AACF;AACA;;AAII;AAAe5Q;;AACf;AAAa9C;;;;AAGbmK;AACApJ;AACA2U;;AAIN;;AC3CA;AAYO;AAIL;AACElY;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEA;AACEkK;AACIC;AAAaZ;AAA2B;AACxCY;AAAqBZ;AAAiC;AACtDY;AAAeZ;AAA6B;AAC5CY;AAAiBZ;AAA+B;AAChDY;AAAqBZ;;;;;;;AAQvB2O;AAEMC;AACAC;AACAC;;;;;AAMV;;AAGF;;ACnDO;;;;;;;;;AASLpC;AAWF;AACE;;;;;;;;AAQEA;AACF;AAEA;AACF;;ACpBA;AAAQlU;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAkD;AACEhD;AACAJ;;AAEFmU;AACE/T;AACAC;AACAE;AACAP;;AAEFqW;AACEjW;AACAC;AACAE;AACAP;;AAEF+B;AACE3B;AACAG;AACAP;;AAGFqB;AACEjB;AACAC;AACAE;AACAP;;AAEFkB;AACEd;AACAC;AACAE;AACAP;;AAEFyB;AACErB;AACAJ;;AAGFM;AACEF;AACAJ;;AAEFgU;AACE5T;AACAC;AACAE;AACAP;;AAGFsW;AACElW;AACAC;AACAE;AACAP;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;;AAQEe;AACAnB;;AAEF;AAEA;AAOA;AAEA;;AAIIQ;AACA7C;AAGA8C;AACAC;AAIF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;;;;;;;;;AAUA;AACF;;ACtLO;AAIL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACZO;AAKL;AACED;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACF;AACAA;AACA;AACE;AAUE;AACF;;AAEF;;AAEEA;AAGF;;AAIA;AACF;;ACjDO;;AAOL;AACF;;ACKA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA6B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;;AASA;AAEA;;AAIIX;AACA7C;AAGA8C;AACAC;AAIF;;AAGE/C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACF;;AC9HO;AAKL;AACED;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACF;;ACpBA;AAAQwY;AAA0B;AAE3B;;;AAKC;;AAEA;AACAC;;AAWAC;;AAEE;AACAC;AACF;AACF;;AAEO1Y;AAAUY;;;;;AAGVZ;AAAWY;AAASX;;AAC/B;AACF;;AClCO;AACL;AAEA;AACF;;ACKA;AAAQ6B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF8B;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;AAEsBC;;AACtB;;AAEA;AACA;AACAgF;AAEA;;AAEE;AACF;AAEA;AACE5H;AACA;AACF;AAEA;AACF;;ACvDA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACA;AACAyG;AACEvG;AACAG;AACAP;;AAEF+B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFqE;AACEjE;AACAG;AACAP;;AAEF6E;AACEzE;AACAG;AACAP;;AAEF8R;AACE1R;AACAG;AACAP;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAGEiG;;;;AAIAtC;;AAEF;;;;AAE6B5C;;AAE7B;;;AAWA;AAEA;;AAIIX;AACA7C;AAGA8C;AACAC;AAIF;;AAGE/C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;AAEEoH;;;AAGAlE;AACA0F;;AAEAtC;AAMF;AACF;;ACtLO;AACL;AACEvG;AACF;AAEA;AACEC;AACA;AACF;AAEAA;AACAA;AACAA;AACF;;ACLO;;AAKL;AACEA;AACF;AACEA;AACF;AAEAA;AACAA;AAGAA;AACAA;AACAA;AACAA;AAGAA;AACAA;AACAA;AACAA;AACAA;AACAA;;AAGA;AACE;AACF;AAEA;AACA;AACEqH;AACF;AACA;AACEA;AACF;AAEA;AACEnH;AACA8Q;AAEIzH;AACAtC;AACF;AAEEsC;AACAtC;AACF;AAEEsC;AACAtC;AACAhF;;AAGN;AACA;AACE;AAAe;;;AAGb;AACA;;AAEE;AACF;AACA;AACF;AACA;AAAe;;;AAGb;AACA;;AAEE;AACF;AACA;AACF;AACA;AAAS;;AAET;AACF;AAEAjC;AACAA;AACAA;;;AAKIgR;AAEIzH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;;AAGN;AAEA;AACF;;AAGF;AAEA;AAKE;AACE/B;AAEAsC;AACAgP;AACA;AACF;;;AAGA;AACA;AACE;AACA;AACA9H;AACF;;AAEA;AAEA;AACExJ;AAEAsC;AACAgP;AACA;AACF;;;AAGA;AACA;AACE;AACA;AACA9H;AACF;;AAEA;AAEA;AACExJ;AAEA8Q;AAEIzH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;AAEF;AAEEsH;AACAtC;AACAhF;AACF;AAEFO;AAMF;;;AAGA;;;AAGA;;AAEA;;AAEA;AAEA;AACEtC;AACA8Q;AAEIzH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;AAEF;AAEEsH;AACAtC;AACAhF;AACF;AAEFO;AAEF;;;AAGA;;;AAGA;;AAEA;;AAEA;;AAGF;AAEA;AAKE;;AAEA;AACEtC;AAEA8Q;AAEIzH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;AACF;AAEEsH;AACAtC;AACAhF;AACF;AAEFO;AACF;;;AAGA;;;AAGA;;AAEA;;AAEA;;AAGE;AACEtC;;AAGAsR;AACA;AACF;;;AAGA;AACA;AACE9H;AACF;;AAEA;AACF;AAEA;AACExJ;AACAsC;AACAgP;AACA;AACF;;;AAGA;AACA;AAIE9H;AACF;;AAEA;AAEA;AACExJ;AAEAsC;AACAgP;AACA;AACF;;;AAGA;AACA;AACE9H;AACF;;AAEA;;AAGF;AAEA;AACE1J;AACAA;AACAA;;AACSC;AAAUY;AAAQ4Q;AAAe;;AAC5C;AAEA;;AACWxR;AAAUY;AAAQ4Q;AAAgB;;AAC7C;;ACxVO;;;AAOP;;ACEA;AAAQ1P;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACAuP;AACErP;AACAJ;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AACQ+O;;;AAER;AACA;AACA9J;AAEA;AACE5H;AACA;AACF;;AAGF;;AC1EO;AAIL;AAKA;AACE;AACF;AAEA;;AAEA;AACA;;AAEA;;AAEI;AACF;AACEC;AACA4D;AACA;AACF;AACF;AAEA;;AACW5D;AAAUY;;AACrB;;AAGEZ;AACAC;AACAC;;AAGJ;;ACjCA;AAAQ4D;AAAmB;AAEpB;AAOL;AACEhE;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;AAEA;AAIE;AAEA;AACEA;;;AAGEA;;;AAGAA;AACAA;AACAA;AAEIC;AACAC;AACAC;AACF;AAEJ;AACA;AACF;AAEAH;AACA;AACF;;AAGE;;;;;;AAQEoU;;AAEJ;AAEA;AAQA;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AAEE;;;AAGIpU;;;AAGAA;AACAA;AACF;AACF;AACEA;AACF;AACF;;ACzGO;;;AASP;;ACTO;AAKL;AACA;AACE;AACF;AACA;AAEAA;;AAEA;;AAKF;;ACJA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAyW;AACEvW;AACAG;AACAP;;AAGF+B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAOEe;AACAkV;;AAEF;AAEA;;;AAWA;AAEA;;AAII7V;AACA7C;AAGA8C;AACAC;AAIF;;AAGE/C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAGE;AACF;;AAEA;AACF;;ACrJA;AAEO;;AAEL;AAA8B2C;AAAW;AACvC;AAEIgT;AACAU;AACAwC;AACAC;AACAhP;AACAiP;AACAC;AACA5P;AACAyI;AACA+D;AACF;AAEE9D;AACEmH;;AAEE/W;;;AAGFgX;;AAEEhX;;;AAGF;AACA0W;;AAEE1W;AACAgD;AACF;;;;;;AAMJ;AAEJ;AACF;;ACrDO;;;;;AAKL/B;AAOF;AACE;;AAYF;;AClBA,iBAAA;AAEO;AAIL;AACEpD;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACA;AACF;;AAGA;;AAEA;AACA;AACA;AACA;AACE;AACF;AACA;AACA;AACA;AACA;AACAM;AAEA;AACA;AACE6Y;AACAC;AACAC;AACAC;AACAtV;AACAzD;AACAoB;AACA4X;AAAe;AACfC;AACEnX;AACA+W;;AAEFK;AACA;AACA;AACAC;AACAC;AACF;;AAEA;AACA;AACA;AACEC;AACAL;AACA5X;AACA6X;AACEnX;AACA+W;;AAEF7Y;AACAsZ;AAEA1Y;AACEiY;AACF;AACF;;AAGEhO;AAQAvK;AACF;;AAEA;;AAGAP;AACAA;;AAEA;AACAwZ;AACE;AACA;AACE;AACA;AACE;;;AAWF;AACF;AACF;;AAIAxZ;AACE;;AAEA;AACAN;AACF;AACF;AAEA;AACE;;;AAGE;AAEA;;AAEA;;AASF;AACF;AAEA;AACE;AACA;;AAGE+Z;AACA5Y;AACF;AAEA;AACA;AACE;AACA;;;AAGA;AACF;;AAEE;AACF;AACE;AACF;AACF;;AChLO;;;;;;AAMLgC;AAQF;AACE;;;;;AAKEA;AACF;AAEA;AACF;;ACdA;AAAQpB;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA6B;AACE3B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFkB;AACEd;AACAC;AACAE;AACAP;;AAEFqB;AACEjB;AACAC;AACAE;AACAP;;AAEFmU;AACE/T;AACAC;AACAE;AACAP;;AAEF+X;AACE3X;AACAC;AACAE;AACAP;;AAEFsC;AACElC;AACAC;AACAE;AACAP;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;AAOA;AAEA;AAGIZ;;AAEA5C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;;;;;;AAOA;AACF;;AChLO;AAIL;AACED;AAEAC;AACA;AACF;AAEAA;AACAA;AACAA;AAGAA;AAGAA;AACAA;AACAA;AACAA;AAGAA;AACA;AACEA;AAGAA;;AAEEA;AACF;AACAA;AACF;AACF;;AC/BO;AAGL;AACA;AACE;AACF;;;;AAE4CuQ;;;AAE5C;AACA;AACA;;;AAOE;AACE;AACE;AAAA;AAEA;AAAA;;;AAOAtQ;AACAY;AACEoZ;;;AAGF/Z;;AAEJ;AACE;;AAEED;AACAY;AACEoZ;AACAC;;;;AAIN;AACF;;AAEIja;AAAU;AACVY;AAAQoZ;AAAqBC;;AAC7Bha;;AAEJ;AACF;AAEA;;AAMA;;ACvEO;AACL;AACA;AACF;;ACIA;AAAQ6B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AAAc;AACdC;;;AAGA8B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEO;AAGHC;AAAmC;;;;;AAMnCA;AACF;;AAIA;AACE3C;AACA;AACF;AAEA;AACF;;AC9DA;AAEO;;AAELkC;AAAc;AACd;AAA8BS;AAAW;AACvC;AAEIgO;AACF;;;;;AAMA;AAEJ;AACF;;ACnBO;;AAKD;AACE;AACF;AACA3Q;AAGAA;AAGAA;AACAA;AAGAA;AAGAA;AACAA;AACAA;AACAA;AACF;AAEJ;;AC3BO;;;;AASHA;AAGAA;AACAA;AAGAA;AACAA;AACAA;AAEA;AACF;AACA;AACF;;ACfO;AACL;;;AACoBma;AAAU;;;AAM5B;AAEJ;;AAEA;;AAEA;AACA;AAEE;;AAEA;;;AAGE;;;AAGI;;;AAKE;AACA;AACAna;AACAoa;AACF;AACF;AACF;;AAEAvW;AACA;AACF;;AAEE;AACA;AACA7D;AACF;AACF;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAGME;AACAsC;AACF;AAEA;;;AACoB2X;AAAU;;AAE5B;;AAEA;AACA;;AAEA;;;AAKF;AACF;AACF;;ACrFO;AACL;AACE;AACEna;AACAA;AACA;AACF;;AAOA;;AAGE;AACEA;AACA;AACF;AACAA;AAGAA;AACAA;AAGF;AACF;AACF;;ACfA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACAkY;AACEhY;AACAG;AACAP;;AAEFqY;AACEjY;AACAG;AACAP;AACF;;AAEFgC;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLvB;AACF;AAEA;AAGIC;AAAmC;AAErC;AACA;;AAEE;AACF;;;;;AAMEA;AACF;;;AAEcC;;;;AACCyX;;;;;AAIb;;AAEEA;AACAC;AACF;AACED;AACAC;AACF;AACF;AAEA;AAGIvX;AACA7C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAGA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAEA;;;AACoBma;AAAU;AAC9B;;;AAGE;;;AAGA;AACF;AACE;;AAEA;AACA;;AAEA;AACF;;AAEEna;AACF;AACF;;AC3FA;AAEA;AAAQua;AAAoB;;AAE5B;AACA;AACE;AACEhR;AACA;AACAtD;;AAEF;;AAGE;AAEIuU;AACAlT;AACAoC;AACA+Q;AACAC;AACAC;AACAhQ;AACAiQ;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAjI;AACA;AACA;AACA7J;AACA+R;AACAnV;AACA;AACA6Q;AACAzI;AACAgN;AACA;AACA;AACA3U;AACA4U;AACF;AAEEvJ;AACEwJ;;AAEEpZ;;;AAGFqZ;;AAEErZ;;;AAGFsZ;;AAEEtZ;;;AAGFuZ;;AAEEvZ;;;AAGF6R;;AAEE7R;AACAgD;;AAEFxB;;AAEExB;;;AAGFwZ;;AAEExZ;;;AAGFyZ;;AAEEzZ;;;AAGF0Z;;AAEE1Z;;;AAGF2Z;;AAEE3Z;;;AAGF4Z;;AAEE5Z;;;AAGFK;;AAEEL;;;AAGF6Z;;AAEE7Z;;;AAGF8Z;;AAEE9Z;;;AAGF4R;;AAEE5R;AACAgD;AACF;;;AAGFqE;AACA0S;AAAczV;AAAoC;AACpD;;;;;;AAOF;;;AAGE;;AAEEyV;AAAczV;;;AAEd;AACAvB;AACAiX;AACF;;;AAIF;AACA;;;AAGEC;;AAEF;AACEA;;;AAGF;AACEA;AACAC;AACAC;AACF;AACEF;AACF;AAEA;AACEnc;AAEIC;AACAC;AACAC;AACF;AAEJ;AACEH;;AAEA;AACE;;AAEF;AACF;;AAGF;AACF","debugId":"f53da652-ed7e-41d2-baff-cba59a65e6b2"}